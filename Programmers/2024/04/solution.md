# 문제 풀이

### Level 2. 3 * N 타일링
- 가로 1, 세로 2 크기의 타일이 주어졌을 때, 세로 3, 가로 n 크기의 벽을 채우는 방법의 수를 구하는 문제
- 홀수인 경우는 딱 맞게 채울 수 없기 때문에 0을 반환
- 짝수인 경우 2인 경우는 총 3개, 4인 경우는 2인 경우의 수에 2인 경우의 수를 곱해 9인 것 같지만 특이한 경우 2가지가 더 존재해서 11이고
- 6인 경우에도 마찬가지로 4인 경우에 2인 경우의 수를 곱한 뒤(11 * 3), 앞이 2이고 뒤가 4일 때 예외로 있던 2가지 경우를 곱해 3 * 2 = 6, 현재 특수 케이스인 2를 더해 총 41입니다.
- 이를 식으로 표현하면 ```f(n) = f(n - 2) * 3 + (f(n - 4) + f(n - 6) + ... + f(2) * 2 ) + 2``` 가 됩니다.
- 따라서 2차원 배열 dp를 만들고 각 인덱스의 0번째에는 지금 위치에서 구할 수 있는 경우의 수, 1번째에는 이전까지의 합을 저장한 뒤
- 위에 식에 맞게 n / 2 = idx 위치에 나올 수 있는 경우의 수를 구한 뒤, 최종적으로 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n / 2) (n <= 5000)

### Level 2. 유사 칸토어 비트열
- n 번째 유사 칸토어 비트열에서 l부터 r까지 위치에 있는 1의 개수를 구하는 문제
  + 0은 00000, 1은 11011로 변경
- l - 1 부터 r - 1 까지 확인하면서
- 현재 위치의 수를 5의 n - 1 제곱으로 나눕니다.
- 이때 몫이 2라면 중간 부분인 0에 해당하므로 그대로 멈추고 다음 위치를 확인합니다.
- 2가 아니라면 나머지를 현재 숫자로 하고 나누는 수를 5로 나누어 다시 위 과정을 반복합니다.
- 나누는 수가 1이 된 경우 이때 현재 수가 2가 아니라면 1을 최종 응답에 더하는 식으로 모든 위치를 확인한 뒤 해당 값을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(5 ^ n) (n <= 20)

### level 2. 아날로그 시계
- 시작 시간 시,분,초와 종료 시간 시,분,초가 주어졌을 때 시작 시간부터 종료 시간까지 이동할 동안 울리는 알람의 횟수를 구하는 문제
  + 시침, 분침이 초침과 만날 때마다 알람이 울림
- 먼저 시작 시간과 종료 시간을 모두 초로 변경합니다. (h * 60 * 60 + m * 60 + s)
- 그런 다음 ```00시 00분 00초부터 종료 시간까지 울린 알림 수 - 00시 00분 00초부터 시작 시간까지 울린 알림 수 + 시작 시간이 알림 시간이 경우``` 로 총 알림 횟수를 구할 수 있습니다.
- 00시 00분 00초부터 목표 시간까지 울린 알림의 수를 구하는 방법은 다음과 같습니다.
  + 시침은 12시간(43200초)에 한바퀴를 돌고 같은 시간동안 초침은 720 바퀴를 돕니다. 이때 정각에서 만나는 것을 제외하고 시침은 한바퀴를 도는 43200초동안 알람이 719번 울리며 즉, 43200/719 초마다 1회 울리게 되므로 ```현재 시간 * 719 / 43200```으로 알림이 울린 횟수를 구할 수 있습니다.
  + 분침은 1시간 (3600초)에 한바퀴를 돌고 같은 시간동안 초침은 60 바퀴를 돕니다. 이때도 정각에서 만나는 것을 제외하고 3600/59 초마다 울린다고 했을 때 ```현재 시간 * 59 / 3600```으로 알림 횟수를 구할 수 있습니다.
  + 이후 현재 시간이 43200 이상인 경우는 시간에 울리는 알람과 분에 울리는 알람 모두에 포함되어 포함되는 수를 빼줘야 합니다.
- 시간 복잡도: O(1)

### level 2. 당구 연습
- 당구대의 크기와 시작 지점, 목표 지점 목록이 주어졌을 때, 벽을 치고 목표 지점을 치는 최단 거리를 구하는 문제
- 시작점부터 목표 지점까지 입사각과 반사각이 같다면 이는 벽을 기준으로 벽에 찍힌 점에서 목표 지점의 반대에 있는 점까지 그은 선도 같은 각을 가지게 되고 이때 시작점부터 목표 지점의 반대 지점까지의 거리가 최단 거리가 됩니다.
- 먼저 목표 지점을 확인하고 상하좌우 각 끝선을 기준으로 반대편에 있는 점까지의 거리를 구한 뒤 그 중 최소값을 정답 배열에 넣고 최종적으로 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000)

### level 2. 도넛과 막대 그래프
- 정점과 이어진 정점들이 주어졌을 때, 기준점과 도넛, 직선, 8자 그래프의 개수를 구하는 문제
- 이 문제는 규칙이 있습니다. 조건들을 확인해보면
- 기준점이 되는 점은 나간 간선의 수가 2이상이고 들어오는 간선은 없어야 합니다.
- 직선 그래프에 해당하는 점이라면 나간 간선은 없지만 들어오는 간선이 1이상이어야 합니다.
- 8자 그래프에 해당하는 점이 되려면 나간 간선의 수와 들어온 간선의 수 모두 2 이상이어야 합니다.
- 그리고 마지막으로 도넛 그래프의 경우 기준점에서 나간 간선의 수에서 직선과 8자 그래프에 쓰인 수를 빼면 구할 수 있습니다.
- 시간 복잡도: O(2n) (n <= 1000000)

### level 3. 정수 삼각형
- 삼각형 모양의 정수 배열이 주어졌을 때 위에서부터 차례대로 지나오면서 가장 합이 큰 경우를 구하는 문제
  + n번째 m 위치의 숫자는 n + 1 번째 m 또는 m + 1 위치의 숫자로 이동할 수 있습니다.
- 먼저 각 층의 합을 담을 2차원 배열을 만들고 주어진 삼각형의 각 층을 돌면서
- 위치가 0번째인 경우는 이전 0번째 합만 더할 수 있으므로 이전 0번째 합과 자신의 값을 더하고
- 위치가 해당 층의 끝인 경우 이전 끝 위치의 합만 더할 수 있으므로 이전 끝 위치의 합과 자신의 값을 더합니다.
- 그 외 중간 위치인 경우 현재 위치 - 1의 합과 현재 위치의 합 중 더 큰 수와 현재 위치의 합을 더합니다.
- 최종적으로 마지막 열의 값들 중 최대 값을 찾아 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n * n) (n <= 500)

### level 3. 이중 우선순위 큐
- I, D와 숫자가 명령어 형태 배열로 주어졌을 때 최종적으로 가장 큰 수와 작은 수를 배열로 반환하는 문제
  + I 숫자는 숫자를 큐에 저장하는 것이고
  + D -1은 가장 작은 수를 삭제, D 1은 가장 큰 수를 하나만 삭제하는 것
- 최소 힙과 최대 힙을 우선 순위 큐를 사용하여 구현한 뒤
- I인 경우 최소 힙과 최대 힙에 각각 숫자를 추가합니다.
- D -1인 경우 최소 힙에서 최소 값을 하나 꺼내고```poll()``` 그 값을 최대 힙에서 삭제합니다. ```remove()```
- D 1인 경우는 최대 힙에서 최대값을 하나 꺼내고 그 값을 최소 힙에서 삭제합니다.
- 최종적으로 최대 힙에 값이 없는 경우는 [0, 0]을 값이 있는 경우는 [최대 힙에서 최대값, 최소 힙에서 최솟값]을 각각 꺼내 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000000)

### Level 3. 야근 지수
- 근무시간 n과 작업량 목록이 주어졌을 때 n 시간 뒤 남아있는 작업들의 제곱의 합 중 최소값을 구하는 문제
- 큰 수들을 빨리 줄이는 것이 최종 값을 가장 작게 만들 수 있다고 생각해서
- 작업량을 최대힙에 넣고 n 번 반복하면서 최대값을 꺼내 1 줄이고 다시 최대 힙에 넣었습니다.
- 최종적으로 힙의 값들을 하나씩 빼서 제곱해 모두 더한 뒤, 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000000)

### Level 3. 단어 변환
- 시작 단어와 목표 단어 그리고 단어 배열이 주어졌을 때 단어 배열의 단어를 사용해 시작 단어에서 목표 단어를 만드는 최소 횟수를 구하는 문제
  + 단어 변환은 한번에 한 개의 알파벳만 변환이 가능
- 최소 횟수를 단어를 바꿔야 하기 때문에 BFS 를 사용하였습니다.
- 먼저 목표 단어가 목록에 없다면 변경이 불가하므로 바로 0을 반환합니다.
- 이후 변환이 가능한 단어의 위치와 해당 단어까지 선택하는데 걸린 횟수를 배열로 하여 큐에 저장합니다.
- 큐에 값이 있다면 계속 변경할 수 있는 단어를 찾아 큐에 반복해서 넣고 최종적으로 목표 단어를 찾은 경우 이때까지 선택한 단어 개수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N + E)

### Level 3. 최고의 집합
- n개의 개수로 s를 만들 수 있는 숫자 집합 중 각 원소의 곱이 최대가 되는 경우를 구하는 문제
- 각 원소의 차이가 거의 없이 비슷한 값들로 이루어졌을 때 원소의 곱이 최대가 되기 때문에
- 우선 기본값이 되는 base를 s/n 으로 구하고 나머지 s%n을 구한 뒤
- 뒤에서부터 배열을 채워가면서 현재 위치가 n - 나머지 보다 크거나 같은 경우 base 값에 1을 더해 추가하고
- n - 나머지보다 작은 경우는 base만 저장하는 형태로 최종 배열을 생성하여 반환하면 해결할 수 있습니다.
- s가 1인 경우 또는 n이 s보다 큰 경우는 숫자 배열을 만들 수 없기 때문에 바로 -1을 가진 배열을 반환하면 됩니다.git 
- 시간 복잡도: O(n) (n <= 10000)

### Level 3. 등굣길
- m * n 형태의 길과 웅덩이 위치가 리스트로 주어졌을 때 웅덩이를 피해 갈 수 있는 최단 거리의 개수를 구하는 문제
- 오른쪽과 아래로만 움직일 수 있기 때문에 최단 거리가 나옵니다.
- 마지막 학교 위치에 도달할 수 있는 최단 거리의 개수는 위에서 온 경우 + 왼쪽에서 온 경우 입니다.
- 따라서 마지막 위치부터 차례대로 확인하면서 오른쪽 개수 + 아래 개수 를 더해 문제를 해결할 수 있습니다.
- 이때 웅덩이 위치는 -1로 미리 지정하여 -1인 위치는 확인하지 않고 값을 더하지도 않도록 처리하였습니다.
- 시간 복잡도: O(n * m) (n, m <= 100) 

### Level 3. 숫자 게임
- 숫자 배열 A와 B가 주어졌을 때 B가 이기는 최대 횟수를 구하는 문제
- 두 배열을 모두 정렬한 뒤 각각 index를 확인하면서
- A의 숫자보다 B의 숫자가 작거나 같다면 B의 다음 숫자를 이어서 확인하고
- A의 숫자보다 B의 숫자가 크다면 answer를 증가시키고 A, B 모두 다음 숫자를 확인하는 방식으로 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100000)

### Level 3. 단속 카메라
- 차량의 진입, 진출 위치가 배열로 주어졌을 때 모든 차량이 적어도 하나의 단속 카메라를 만나도록 하는 최소 단속카메라 수를 구하는 문제
- 빠져 나가기 전에 모두 만나야하기 때문에 먼저 진출 기준으로 자동차를 정렬시키고
- 이전 차량의 진출 위치보다 진입 위치가 큰 경우 한 카메라에 담을 수 없는 것으로 하여 카메라 수를 증가 시키고 집입 위치가 큰 차량의 진출 위치로 비교 값을 다시 세팅합니다.
- 이렇게 반복한 뒤 지금까지 나온 카메라 수를 반환하여 문제를 해결할 수 있습니다.
- 진입 위치로 오름차순 정렬을 하는 경우 진입-진출 사이가 긴 차량 사이에 짧게 짧게 이어지지 않는 차량들에 대한 검사를 할 수 없습니다.
  + 예시) {{0, 1}, {2, 10}, {3, 4}, {5, 6}}
- 시간 복잡도: O(n) (n <= 10000)

### Level 3. 
