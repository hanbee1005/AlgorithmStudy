# 문제 풀이

### Level 2. 3 * N 타일링
- 가로 1, 세로 2 크기의 타일이 주어졌을 때, 세로 3, 가로 n 크기의 벽을 채우는 방법의 수를 구하는 문제
- 홀수인 경우는 딱 맞게 채울 수 없기 때문에 0을 반환
- 짝수인 경우 2인 경우는 총 3개, 4인 경우는 2인 경우의 수에 2인 경우의 수를 곱해 9인 것 같지만 특이한 경우 2가지가 더 존재해서 11이고
- 6인 경우에도 마찬가지로 4인 경우에 2인 경우의 수를 곱한 뒤(11 * 3), 앞이 2이고 뒤가 4일 때 예외로 있던 2가지 경우를 곱해 3 * 2 = 6, 현재 특수 케이스인 2를 더해 총 41입니다.
- 이를 식으로 표현하면 ```f(n) = f(n - 2) * 3 + (f(n - 4) + f(n - 6) + ... + f(2) * 2 ) + 2``` 가 됩니다.
- 따라서 2차원 배열 dp를 만들고 각 인덱스의 0번째에는 지금 위치에서 구할 수 있는 경우의 수, 1번째에는 이전까지의 합을 저장한 뒤
- 위에 식에 맞게 n / 2 = idx 위치에 나올 수 있는 경우의 수를 구한 뒤, 최종적으로 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n / 2) (n <= 5000)

### Level 2. 유사 칸토어 비트열
- n 번째 유사 칸토어 비트열에서 l부터 r까지 위치에 있는 1의 개수를 구하는 문제
  + 0은 00000, 1은 11011로 변경
- l - 1 부터 r - 1 까지 확인하면서
- 현재 위치의 수를 5의 n - 1 제곱으로 나눕니다.
- 이때 몫이 2라면 중간 부분인 0에 해당하므로 그대로 멈추고 다음 위치를 확인합니다.
- 2가 아니라면 나머지를 현재 숫자로 하고 나누는 수를 5로 나누어 다시 위 과정을 반복합니다.
- 나누는 수가 1이 된 경우 이때 현재 수가 2가 아니라면 1을 최종 응답에 더하는 식으로 모든 위치를 확인한 뒤 해당 값을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(5 ^ n) (n <= 20)

### level 2. 아날로그 시계
- 시작 시간 시,분,초와 종료 시간 시,분,초가 주어졌을 때 시작 시간부터 종료 시간까지 이동할 동안 울리는 알람의 횟수를 구하는 문제
  + 시침, 분침이 초침과 만날 때마다 알람이 울림
- 먼저 시작 시간과 종료 시간을 모두 초로 변경합니다. (h * 60 * 60 + m * 60 + s)
- 그런 다음 ```00시 00분 00초부터 종료 시간까지 울린 알림 수 - 00시 00분 00초부터 시작 시간까지 울린 알림 수 + 시작 시간이 알림 시간이 경우``` 로 총 알림 횟수를 구할 수 있습니다.
- 00시 00분 00초부터 목표 시간까지 울린 알림의 수를 구하는 방법은 다음과 같습니다.
  + 시침은 12시간(43200초)에 한바퀴를 돌고 같은 시간동안 초침은 720 바퀴를 돕니다. 이때 정각에서 만나는 것을 제외하고 시침은 한바퀴를 도는 43200초동안 알람이 719번 울리며 즉, 43200/719 초마다 1회 울리게 되므로 ```현재 시간 * 719 / 43200```으로 알림이 울린 횟수를 구할 수 있습니다.
  + 분침은 1시간 (3600초)에 한바퀴를 돌고 같은 시간동안 초침은 60 바퀴를 돕니다. 이때도 정각에서 만나는 것을 제외하고 3600/59 초마다 울린다고 했을 때 ```현재 시간 * 59 / 3600```으로 알림 횟수를 구할 수 있습니다.
  + 이후 현재 시간이 43200 이상인 경우는 시간에 울리는 알람과 분에 울리는 알람 모두에 포함되어 포함되는 수를 빼줘야 합니다.
- 시간 복잡도: O(1)

### level 2. 당구 연습
- 당구대의 크기와 시작 지점, 목표 지점 목록이 주어졌을 때, 벽을 치고 목표 지점을 치는 최단 거리를 구하는 문제
- 시작점부터 목표 지점까지 입사각과 반사각이 같다면 이는 벽을 기준으로 벽에 찍힌 점에서 목표 지점의 반대에 있는 점까지 그은 선도 같은 각을 가지게 되고 이때 시작점부터 목표 지점의 반대 지점까지의 거리가 최단 거리가 됩니다.
- 먼저 목표 지점을 확인하고 상하좌우 각 끝선을 기준으로 반대편에 있는 점까지의 거리를 구한 뒤 그 중 최소값을 정답 배열에 넣고 최종적으로 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000)

### level 2. 도넛과 막대 그래프
- 정점과 이어진 정점들이 주어졌을 때, 기준점과 도넛, 직선, 8자 그래프의 개수를 구하는 문제
- 이 문제는 규칙이 있습니다. 조건들을 확인해보면
- 기준점이 되는 점은 나간 간선의 수가 2이상이고 들어오는 간선은 없어야 합니다.
- 직선 그래프에 해당하는 점이라면 나간 간선은 없지만 들어오는 간선이 1이상이어야 합니다.
- 8자 그래프에 해당하는 점이 되려면 나간 간선의 수와 들어온 간선의 수 모두 2 이상이어야 합니다.
- 그리고 마지막으로 도넛 그래프의 경우 기준점에서 나간 간선의 수에서 직선과 8자 그래프에 쓰인 수를 빼면 구할 수 있습니다.
- 시간 복잡도: O(2n) (n <= 1000000)

### level 3. 정수 삼각형
- 삼각형 모양의 정수 배열이 주어졌을 때 위에서부터 차례대로 지나오면서 가장 합이 큰 경우를 구하는 문제
  + n번째 m 위치의 숫자는 n + 1 번째 m 또는 m + 1 위치의 숫자로 이동할 수 있습니다.
- 먼저 각 층의 합을 담을 2차원 배열을 만들고 주어진 삼각형의 각 층을 돌면서
- 위치가 0번째인 경우는 이전 0번째 합만 더할 수 있으므로 이전 0번째 합과 자신의 값을 더하고
- 위치가 해당 층의 끝인 경우 이전 끝 위치의 합만 더할 수 있으므로 이전 끝 위치의 합과 자신의 값을 더합니다.
- 그 외 중간 위치인 경우 현재 위치 - 1의 합과 현재 위치의 합 중 더 큰 수와 현재 위치의 합을 더합니다.
- 최종적으로 마지막 열의 값들 중 최대 값을 찾아 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n * n) (n <= 500)

### level 3. 이중 우선순위 큐
- I, D와 숫자가 명령어 형태 배열로 주어졌을 때 최종적으로 가장 큰 수와 작은 수를 배열로 반환하는 문제
  + I 숫자는 숫자를 큐에 저장하는 것이고
  + D -1은 가장 작은 수를 삭제, D 1은 가장 큰 수를 하나만 삭제하는 것
- 최소 힙과 최대 힙을 우선 순위 큐를 사용하여 구현한 뒤
- I인 경우 최소 힙과 최대 힙에 각각 숫자를 추가합니다.
- D -1인 경우 최소 힙에서 최소 값을 하나 꺼내고```poll()``` 그 값을 최대 힙에서 삭제합니다. ```remove()```
- D 1인 경우는 최대 힙에서 최대값을 하나 꺼내고 그 값을 최소 힙에서 삭제합니다.
- 최종적으로 최대 힙에 값이 없는 경우는 [0, 0]을 값이 있는 경우는 [최대 힙에서 최대값, 최소 힙에서 최솟값]을 각각 꺼내 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000000)

### Level 3. 야근 지수
- 근무시간 n과 작업량 목록이 주어졌을 때 n 시간 뒤 남아있는 작업들의 제곱의 합 중 최소값을 구하는 문제
- 큰 수들을 빨리 줄이는 것이 최종 값을 가장 작게 만들 수 있다고 생각해서
- 작업량을 최대힙에 넣고 n 번 반복하면서 최대값을 꺼내 1 줄이고 다시 최대 힙에 넣었습니다.
- 최종적으로 힙의 값들을 하나씩 빼서 제곱해 모두 더한 뒤, 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000000)

### Level 3. 단어 변환
- 시작 단어와 목표 단어 그리고 단어 배열이 주어졌을 때 단어 배열의 단어를 사용해 시작 단어에서 목표 단어를 만드는 최소 횟수를 구하는 문제
  + 단어 변환은 한번에 한 개의 알파벳만 변환이 가능
- 최소 횟수를 단어를 바꿔야 하기 때문에 BFS 를 사용하였습니다.
- 먼저 목표 단어가 목록에 없다면 변경이 불가하므로 바로 0을 반환합니다.
- 이후 변환이 가능한 단어의 위치와 해당 단어까지 선택하는데 걸린 횟수를 배열로 하여 큐에 저장합니다.
- 큐에 값이 있다면 계속 변경할 수 있는 단어를 찾아 큐에 반복해서 넣고 최종적으로 목표 단어를 찾은 경우 이때까지 선택한 단어 개수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N + E)

### Level 3. 최고의 집합
- n개의 개수로 s를 만들 수 있는 숫자 집합 중 각 원소의 곱이 최대가 되는 경우를 구하는 문제
- 각 원소의 차이가 거의 없이 비슷한 값들로 이루어졌을 때 원소의 곱이 최대가 되기 때문에
- 우선 기본값이 되는 base를 s/n 으로 구하고 나머지 s%n을 구한 뒤
- 뒤에서부터 배열을 채워가면서 현재 위치가 n - 나머지 보다 크거나 같은 경우 base 값에 1을 더해 추가하고
- n - 나머지보다 작은 경우는 base만 저장하는 형태로 최종 배열을 생성하여 반환하면 해결할 수 있습니다.
- s가 1인 경우 또는 n이 s보다 큰 경우는 숫자 배열을 만들 수 없기 때문에 바로 -1을 가진 배열을 반환하면 됩니다.git 
- 시간 복잡도: O(n) (n <= 10000)

### Level 3. 등굣길
- m * n 형태의 길과 웅덩이 위치가 리스트로 주어졌을 때 웅덩이를 피해 갈 수 있는 최단 거리의 개수를 구하는 문제
- 오른쪽과 아래로만 움직일 수 있기 때문에 최단 거리가 나옵니다.
- 마지막 학교 위치에 도달할 수 있는 최단 거리의 개수는 위에서 온 경우 + 왼쪽에서 온 경우 입니다.
- 따라서 마지막 위치부터 차례대로 확인하면서 오른쪽 개수 + 아래 개수 를 더해 문제를 해결할 수 있습니다.
- 이때 웅덩이 위치는 -1로 미리 지정하여 -1인 위치는 확인하지 않고 값을 더하지도 않도록 처리하였습니다.
- 시간 복잡도: O(n * m) (n, m <= 100) 

### Level 3. 숫자 게임
- 숫자 배열 A와 B가 주어졌을 때 B가 이기는 최대 횟수를 구하는 문제
- 두 배열을 모두 정렬한 뒤 각각 index를 확인하면서
- A의 숫자보다 B의 숫자가 작거나 같다면 B의 다음 숫자를 이어서 확인하고
- A의 숫자보다 B의 숫자가 크다면 answer를 증가시키고 A, B 모두 다음 숫자를 확인하는 방식으로 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100000)

### Level 3. 단속 카메라
- 차량의 진입, 진출 위치가 배열로 주어졌을 때 모든 차량이 적어도 하나의 단속 카메라를 만나도록 하는 최소 단속카메라 수를 구하는 문제
- 빠져 나가기 전에 모두 만나야하기 때문에 먼저 진출 기준으로 자동차를 정렬시키고
- 이전 차량의 진출 위치보다 진입 위치가 큰 경우 한 카메라에 담을 수 없는 것으로 하여 카메라 수를 증가 시키고 집입 위치가 큰 차량의 진출 위치로 비교 값을 다시 세팅합니다.
- 이렇게 반복한 뒤 지금까지 나온 카메라 수를 반환하여 문제를 해결할 수 있습니다.
- 진입 위치로 오름차순 정렬을 하는 경우 진입-진출 사이가 긴 차량 사이에 짧게 짧게 이어지지 않는 차량들에 대한 검사를 할 수 없습니다.
  + 예시) {{0, 1}, {2, 10}, {3, 4}, {5, 6}}
- 시간 복잡도: O(n) (n <= 10000)

### Level 3. 기지국 설치
- 전체 아파트 길이와 설치된 기지국의 위치, 전파 도달 거리가 주어졌을 때 모든 아파트에 전파를 전달하기 위해 세워야하는 최소 기지국의 수를 구하는 문제
- 최소 위치를 지정하고 (초기 1)
- 설치된 기지국 위치를 돌면서 해당 기지국에서 왼쪽으로 보낸 전파의 길이보다 최소 위치가 작은 경우 전파가 닿지 않은 곳이 있다는 의미로 전파가 닿지 않은 곳의 개수를 확인하고 (```station - w - min```)
- 기지국을 몇개 세워야 모두 채울 수 있는지 확인한 뒤 그 수를 정답 개수에 더해줍니다. (```cnt / (w * 2 + 1) + 나머지가 있다면 1 추가```)
- 그런 다음 최소 위치를 오른쪽으로 미치는 전파의 다음 위치로 지정합니다. (```station + w + 1```)
- 이렇게 설치된 기지국을 기준으로 모두 확인한 뒤 아직도 최소 위치가 아파트 전체 길이보다 작거나 같다면 남은 아파트에 대해 최소 기지국 수를 구한 뒤 이전 정답에 합쳐서 반환하면 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 10000)

### Level 3. 스티커 모으기 (2)
- 스티커 정보가 배열로 주어졌을 때 스티커를 떼서 그 합이 가장 큰 경우를 구하는 문제
- 첫 번째 스티커를 떼는 경우와 아니 경우에 따라 마지막 스티커를 뗄 수 있는지 여부가 결정되기 때문에 2가지 경우로 나눠서 확인합니다.
- i 번째 위치의 스티커는 (i-1)번째 스티커를 뗀 경우와 (i-2)번째 스티커를 떼고 i 번째 스티커까지 뗀 경우를 비교하여 (i-2)번째 스티커를 떼고 i 번째 스티커까지 뗀 경우가 더 큰 경우 해당 값으로 아니면 (i-1)번째 스티커를 뗀 경우로 저장합니다.
- 이렇게 계산하여 첫 번째 스티커를 떼서 나온 최대값과 첫 번째 스티커를 떼지 않았을 때 나온 최대값 중 더 큰 값을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(2n) (n <= 100000)

### Level 3. 보석 쇼핑
- 보석 진열대의 상태가 주어졌을 때 모든 보석을 1개 이상 구입할 수 있는 가장 작은 범위를 구하는 문제
- 어떤 보석들이 있는지 알 수 없기 때문에 어떤 보석의 가장 마지막 위치를 저장할 Map을 하나 생성합니다.
- 그런 다음 시작 위치, 종료 위치를 모두 0으로 설정하고 진열대를 하나씩 돌면서
- 해당 보석이 이전에 나온적이 없다면 해당 보석 위치까지는 무조건 확인을 해야하기 때문에 Map 에 마지막 위치를 저장하고 종료 위치도 현재 위치로 변경한 뒤 최종 범위를 저장해둡니다.
- 만약 이전에 나온적이 있는 보석이라면 먼저 Map에 해당 보석의 마지막 위치를 갱신하고 종료 위치도 갱신합니다.
- 이후 현재 위치의 보석과 시작 위치의 보석이 같다면 시작 위치를 Map 내 최소 값으로 변경하고
  + 현재 위치 보석과 시작 위치 보석이 같지 않을 때도 start 를 갱신하고 answer를 비교해도 되지만 
  + 현재 위치 보석과 시작 위치 보석이 같지 않을 때는 최소 위치도 변경이 없기 때문에 의미 없는 비교
- 이렇게 변경한 end - start 가 기존에 종료 위치 - 시작 위치 범위보다 작은 경우에는 시작, 종료 범위를 현재 start, end로 수정합니다.
- 이렇게 마지막 보석까지 확인한 뒤, 그 결과를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(2n) (n <= 100000)

### Level 3. 불량 사용자
- 사용자 id 목록과 불량 사용자 id가 마스킹된 목록이 주어졌을 때 불량 사용자 목록의 경우의 수를 구하는 문제
- 먼저 각 불량 사용자 id의 마스킹 경우에 해당하는 사용자 id들을 찾아 list로 저장합니다.
- 이후 각 리스트에서 이전 값과 중복되지 않게 하나씩 사용자 id를 뽑고 그 수가 불량 사용자 id의 수와 같을 때 이전에 뽑은 조합이 아니라면 1을 증가 시킵니다.
- 이렇게 모든 경우의 수를 계산하여 반환된 값의 합을 구하면 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n ^ 3) (n <= 8)

### Level 3. 섬 연결하기 (탐욕법)
- 섬의 개수와 '섬-섬-다리건설비용'이 배열로 주어졌을 때 모든 섬을 연결하는 다리를 건설하는데 드는 최소 비용을 구하는 문제
- 먼저 연결된 섬의 정보를 이차원 배열에 저장합니다. (```[i][j]의 값은 i번째 섬과 연결된 j번째 섬의 다리 건설 비용을 의미합니다.```)
- 이후 bfs 탐색을 통해 연결된 다리를 확인하고 건설을 할텐데 이때 탐색의 조건은 연결이 되어 있으면서 다리 건설 비용이 적게 드는 경우를 가장 먼저 확인합니다.
- 따라서 해당 섬을 방문한 적이 없을 때 해당 섬에 방문해 다리를 건설하는 것으로 하고 (```visited = true, answer += 다리 건설 비용```) 해당 섬과 연결된 다른 섬의 값도 섬 번호와 다리 건설 비용을 int 배열로 만들어 우선 순위 큐에 저장합니다.
- 이렇게 연결한 모든 다리를 확인한 뒤 나온 answer 값을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N + E) (N <= 100)

### Level 3. 가장 먼 노드
- 노드의 개수와 연결된 정보가 배열로 주어졌을 때 최단 거리로 이동해서 가장 멀리 있는 노드의 개수를 구하는 문제
- 먼저 연결된 노드들을 노드의 값을 key로 하고 연결된 노드를 list로 하여 맵 형태로 저장합니다. ({i, j} 리고 하면 i 번째 노드와 j 번째 노드가 연결되어 있으므로 i를 키로 한 경우와 j를 키로 한 경우 모두 데이터를 저장합니다.)
- 그리고 BFS 탐색으로 최단 거리를 찾아가면서 i 노드와 연결된 노드들을 확인하며 아직 방문하지 않은 경우 방문한 것으로 하고 {연결된 노드, 이전 노드까지 오는데 연결된 간선 수 + 1} 을 하여 데이터를 큐에 저장합니다.
- 모든 노드를 방문한 경우에는 현재 노드까지 오는데 연결된 간선의 수와 결과값을 비교하여 연결된 간선의 수가 더 크다면 최대값을 갱신하고 결과값을 1로 초기화합니다.
- 만약 두 값이 같다면 결과값만 1 증가시킵니다.
- 위 같은 방식으로 연결된 모든 노드를 확인하여 결과값을 반환하면 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N + E) (N <= 20000)

### Level 3. 징검다리 건너기
- 징검다리 돌에 대한 배열과 한번에 건널 수 있는 돌의 수가 주어졌을 때 건널 수 있는 최대 인원을 구하는 문제
- 이분법을 통해 구현할 수 있는데 먼저 시작은 0 종료는 징검다리 돌의 가장 큰 값으로 설정합니다.
- 시작 값이 종료 값과 같거나 작은 동안 반복하면서 중간 값을 구하고 모든 돌을 확인하면서 한번에 건널 수 있는 경우 (```stone[i] < mid```) 개수를 셉니다.
- 한번에 건널 수 없다면 지금까지 한번에 건넌 개수를 별도로 저장하고 모든 돌을 끝까지 반복하면서 최대로 한번에 건널 수 있는 값을 구합니다.
- 이후 한번에 건널 수 있는 다리의 수가 k보다 큰 경우 종료 값을 줄이고
- 작거나 같은 경우 정답을 중간 값으로 저장하고 시작 값을 증가 시키면서 반복한 뒤
- 최종적으로 정답을 반환하여 문제를 해결할 수 있습니다.
- ~~추가로 돌을 k개수만큼 잘라 최대값을 구한 뒤 그 중 최소 값을 구해 반환하는 것도 방법이지만 시간초과 이슈가 있었습니다.~~
- 시간 복잡도: O(NlogM) (N <= 200000, M <= 200000000)

### Level 3. 여행 경로 (DFS/BFS)
- 출발 공항과 도착 공항이 적힌 티켓이 주어졌을 때 티켓을 모두 사용하여 모든 공항을 방문할 때 방문한 공항을 순서대로 출력하는 문제
- 공항은 다시 방문할 수 있지만 티켓은 모두 1회 사용해야 하기 때문에
- 먼저 출발 공항을 키로 하고 도착 공항과 티켓 인덱스를 값으로 맵을 생성합니다.
- 이때 값에 저장된 도착 공항을 알파벳 기준 오름차순 정렬합니다.
- 이후 BFS 탐색을 위해 큐를 생성하고 사용한 티켓 수를 담은 리스트를 저장하도록 합니다.
- 먼저 -1 값을 넣고 큐가 빌 때까지 반복하면서
- 사용한 티켓의 개수가 (티켓 길이 + 1)보다 작다면 마지막으로 사용한 티켓의 도착 공항을 기준으로 해당 공항과 연결된 공항의 티켓을 확인해 아직 사용하지 않은 티켓이라면 기존 사용한 티켓 뒤에 추가한 뒤 큐에 넣는 작업을 반복합니다.
- 사용한 티켓의 개수가 (티켓 길이 + 1)인 경우 각 티켓에 해당하는 도착 공항을 순서대로 목록으로 만들어 반환합니다.
- 시간 복잡도: O(N^2logN) (N <= 99,990,000)

### Level 3. 디스크 컨트롤러 (Heap)
- 일의 시작 시간과 소요 시간이 배열로 주어졌을 때 작업 요청부터 종료까지 걸린 시간의 평균 합의 가장 작은 값을 구하는 문제
- 시작 시간이 빠른 경우 먼저 실행이 되어야 하고 작업의 시간이 짧은 것을 먼저 수행하는 것이 유리하기 때문에
- 먼저 작업을 시작 시간 순으로 정렬한 뒤, 작업 시간이 짧은게 우선 순위를 가지는 큐를 생성합니다.
- 이후 작업을 하나씩 확인하면서 작업의 시작 시간이 이전 작업들의 종료 시간보다 작은 경우 큐에 넣고
- 해당 큐를 돌면서 작업시간 + 대기 시간을 total에 더한 뒤 기존 종료 시간에 해당 작업 시간을 더해 종료시간을 늘리고 수행한 작업의 수를 증가시킵니다.
- 이렇게 모두 확인한 뒤 최종적으로 total / total.length 를 통해 평균 시간을 구해 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n^2) (n <= 500)

### Level 3. 입국 심사 (이분 탐색)
- 심사를 받아야 하는 사람의 수와 심사관이 한번 심사할 때 걸리는 시간이 주어졌을 때 심사 완료까지 걸리는 최소 시간을 구하는 문제
- 주어진 값의 범위가 매우 크기 때문에 완전 탐색 등을 통해서는 문제를 해결할 수 없을 것으로 판단하고 시간을 기준으로 이분 탐색을 시작합니다.
- 어떤 시간(시작과 종료 시간 중간)이 주어졌을 때 그 시간 안에 각 검색대에서 처리할 수 있는 사람의 수를 계산하여 
- 심사 받아야하는 모든 사람을 처리할 수 있다면 현재 시간과 정답을 비교하여 최소값을 저장하고 종료 시간을 중간 시간에서 -1한 값으로 변경합니다.
- 만약 모든 사람을 처리할 수 없었다면 시작 시간을 중간 시간 + 1한 값으로 변경하고 같은 로직을 반복하며 확인합니다.
- 이렇게 시작 시간과 종료 시간이 같을 때까지 비교한 뒤 이때의 최소 시간을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(NLogM) (N <= 100000, M <= 100000000000000)

### Level 3. 경주로 건설
- 도로의 정보가 주어졌을 때 경주로를 건설할 때 드는 최소 비용을 구하는 문제
- {0,0} 위치에서 출발하기 때문에 BFS 사용을 위해 큐를 생성하고 해당 값을 저장합니다. 이때 이전 위치를 나타내는 값도 함께 추가합니다.
- 그리고 각 위치까지 오는데 필요한 비용을 저장할 3차원 배열을 만드는데 각 위치를 나타내는 {x,y}와 상하좌우 어디에서 왔을 때의 비용인지를 저장하게 됩니다.
  + 즉, {1,1} 위치를 기준으로 {0,1}에서 온 비용이면 {1,1,0}에 비용 값이 저장됩니다.
  + 하나의 위치에 대해 총 4개의 방향이 존재합니다.
- 그리고 큐가 빌때까지 큐에서 현재 위치를 구하고
- 해당 위치가 종료 지점이라면 종료지점의 방향에 해당하는 값을 최종값과 비교하여 최소값을 저장합니다.
- 그렇지 않은 경우 다음으로 이동할 방향을 구하고 해당 위치의 값이 0으로 이동할 수 있다면 현재 위치의 방향 값과 코너인지 아닌지 확인 후 추가 비용을 더해 다음 건설 비용을 확인하고
- 아직 해당 방향에서 방문한 적이 없거나 이전에 같은 방향으로 방문했을 때보다 지금의 건설 비용이 더 적다면 다음 위치의 방향에 다음 건설 비용을 저장하고 다음 위치와 이동한 방향을 배열로 만들어 큐에 저장합니다.
- 이후 큐에 값이 없다면 더 이상 이동할 곳이 없다는 것이므로 구한 최소값을 반환하여 문제를 해결할 수 있습니다. 
- 시간 복잡도: O(n^2) (n <= 25)

### Level 3. 가장 긴 팰린드롬
- 문자열이 주어졌을 때 부분 문자들 중 가장 긴 팰린드롬을 구하는 문제
- 가장 긴 길이를 구해야 하기 때문에 길이가 최대일 때부터 길이를 줄여가면서 해당 문자열이 팰린드롬에 맞는지 확인합니다.
- 문자의 시작과 끝 인덱스를 지정하고 두 문자가 같다면 시작 인덱스를 하나 증가시키고 끝 인덱스는 하나 감소시키면서 팰린드롬에 맞는지 확인하고 만약 문자가 같지 않다면 그대로 다음 문자를 확인합니다.
- 이렇게 길이를 줄여가면서 그 길이에 해당하는 문자열을 잘라가면서 확인한 뒤 팰린드롬에 해당하는 경우 이때의 길이를 정답으로 간주하여 저장하고 그대로 최상위 반복문을 종료합니다.
- 이후 저장된 정답을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n^3) (n <= 2500)

### level 3. 연속 펄스 부분 수열의 합
- 숫자 배열이 주어졌을 때 펄스 수열을 곱했을 때 부분 수열의 합이 가장 큰 값을 구하는 문제
- 이 문제는 dp 방식으로 해결할 수 있는데 펄스 수열의 경우는 -1부터 시작하는 경우, 1부터 시작하는 경우 이렇게 2가지이므로 
- 각각에 맞는 수를 더해가면서 각각 0과 합 중 큰 수를 구하고 그 수들과 기존 최댓값 중 최댓값을 구해 최종적으로 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 500000)

### level 3.
