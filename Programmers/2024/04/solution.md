# 문제 풀이

### Level 2. 3 * N 타일링
- 가로 1, 세로 2 크기의 타일이 주어졌을 때, 세로 3, 가로 n 크기의 벽을 채우는 방법의 수를 구하는 문제
- 홀수인 경우는 딱 맞게 채울 수 없기 때문에 0을 반환
- 짝수인 경우 2인 경우는 총 3개, 4인 경우는 2인 경우의 수에 2인 경우의 수를 곱해 9인 것 같지만 특이한 경우 2가지가 더 존재해서 11이고
- 6인 경우에도 마찬가지로 4인 경우에 2인 경우의 수를 곱한 뒤(11 * 3), 앞이 2이고 뒤가 4일 때 예외로 있던 2가지 경우를 곱해 3 * 2 = 6, 현재 특수 케이스인 2를 더해 총 41입니다.
- 이를 식으로 표현하면 ```f(n) = f(n - 2) * 3 + (f(n - 4) + f(n - 6) + ... + f(2) * 2 ) + 2``` 가 됩니다.
- 따라서 2차원 배열 dp를 만들고 각 인덱스의 0번째에는 지금 위치에서 구할 수 있는 경우의 수, 1번째에는 이전까지의 합을 저장한 뒤
- 위에 식에 맞게 n / 2 = idx 위치에 나올 수 있는 경우의 수를 구한 뒤, 최종적으로 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n / 2) (n <= 5000)

### Level 2. 유사 칸토어 비트열
- n 번째 유사 칸토어 비트열에서 l부터 r까지 위치에 있는 1의 개수를 구하는 문제
  + 0은 00000, 1은 11011로 변경
- l - 1 부터 r - 1 까지 확인하면서
- 현재 위치의 수를 5의 n - 1 제곱으로 나눕니다.
- 이때 몫이 2라면 중간 부분인 0에 해당하므로 그대로 멈추고 다음 위치를 확인합니다.
- 2가 아니라면 나머지를 현재 숫자로 하고 나누는 수를 5로 나누어 다시 위 과정을 반복합니다.
- 나누는 수가 1이 된 경우 이때 현재 수가 2가 아니라면 1을 최종 응답에 더하는 식으로 모든 위치를 확인한 뒤 해당 값을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(5 ^ n) (n <= 20)

### level 2. 아날로그 시계
- 시작 시간 시,분,초와 종료 시간 시,분,초가 주어졌을 때 시작 시간부터 종료 시간까지 이동할 동안 울리는 알람의 횟수를 구하는 문제
  + 시침, 분침이 초침과 만날 때마다 알람이 울림
- 먼저 시작 시간과 종료 시간을 모두 초로 변경합니다. (h * 60 * 60 + m * 60 + s)
- 그런 다음 ```00시 00분 00초부터 종료 시간까지 울린 알림 수 - 00시 00분 00초부터 시작 시간까지 울린 알림 수 + 시작 시간이 알림 시간이 경우``` 로 총 알림 횟수를 구할 수 있습니다.
- 00시 00분 00초부터 목표 시간까지 울린 알림의 수를 구하는 방법은 다음과 같습니다.
  + 시침은 12시간(43200초)에 한바퀴를 돌고 같은 시간동안 초침은 720 바퀴를 돕니다. 이때 정각에서 만나는 것을 제외하고 시침은 한바퀴를 도는 43200초동안 알람이 719번 울리며 즉, 43200/719 초마다 1회 울리게 되므로 ```현재 시간 * 719 / 43200```으로 알림이 울린 횟수를 구할 수 있습니다.
  + 분침은 1시간 (3600초)에 한바퀴를 돌고 같은 시간동안 초침은 60 바퀴를 돕니다. 이때도 정각에서 만나는 것을 제외하고 3600/59 초마다 울린다고 했을 때 ```현재 시간 * 59 / 3600```으로 알림 횟수를 구할 수 있습니다.
  + 이후 현재 시간이 43200 이상인 경우는 시간에 울리는 알람과 분에 울리는 알람 모두에 포함되어 포함되는 수를 빼줘야 합니다.
- 시간 복잡도: O(1)

### level 2. 당구 연습
- 당구대의 크기와 시작 지점, 목표 지점 목록이 주어졌을 때, 벽을 치고 목표 지점을 치는 최단 거리를 구하는 문제
- 시작점부터 목표 지점까지 입사각과 반사각이 같다면 이는 벽을 기준으로 벽에 찍힌 점에서 목표 지점의 반대에 있는 점까지 그은 선도 같은 각을 가지게 되고 이때 시작점부터 목표 지점의 반대 지점까지의 거리가 최단 거리가 됩니다.
- 먼저 목표 지점을 확인하고 상하좌우 각 끝선을 기준으로 반대편에 있는 점까지의 거리를 구한 뒤 그 중 최소값을 정답 배열에 넣고 최종적으로 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000)

### level 2. 도넛과 막대 그래프
- 정점과 이어진 정점들이 주어졌을 때, 기준점과 도넛, 직선, 8자 그래프의 개수를 구하는 문제
- 이 문제는 규칙이 있습니다. 조건들을 확인해보면
- 기준점이 되는 점은 나간 간선의 수가 2이상이고 들어오는 간선은 없어야 합니다.
- 직선 그래프에 해당하는 점이라면 나간 간선은 없지만 들어오는 간선이 1이상이어야 합니다.
- 8자 그래프에 해당하는 점이 되려면 나간 간선의 수와 들어온 간선의 수 모두 2 이상이어야 합니다.
- 그리고 마지막으로 도넛 그래프의 경우 기준점에서 나간 간선의 수에서 직선과 8자 그래프에 쓰인 수를 빼면 구할 수 있습니다.
- 시간 복잡도: O(2n) (n <= 1000000)

### level 3. 정수 삼각형
- 삼각형 모양의 정수 배열이 주어졌을 때 위에서부터 차례대로 지나오면서 가장 합이 큰 경우를 구하는 문제
  + n번째 m 위치의 숫자는 n + 1 번째 m 또는 m + 1 위치의 숫자로 이동할 수 있습니다.
- 먼저 각 층의 합을 담을 2차원 배열을 만들고 주어진 삼각형의 각 층을 돌면서
- 위치가 0번째인 경우는 이전 0번째 합만 더할 수 있으므로 이전 0번째 합과 자신의 값을 더하고
- 위치가 해당 층의 끝인 경우 이전 끝 위치의 합만 더할 수 있으므로 이전 끝 위치의 합과 자신의 값을 더합니다.
- 그 외 중간 위치인 경우 현재 위치 - 1의 합과 현재 위치의 합 중 더 큰 수와 현재 위치의 합을 더합니다.
- 최종적으로 마지막 열의 값들 중 최대 값을 찾아 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n * n) (n <= 500)

### level 3. 이중 우선순위 큐
- I, D와 숫자가 명령어 형태 배열로 주어졌을 때 최종적으로 가장 큰 수와 작은 수를 배열로 반환하는 문제
  + I 숫자는 숫자를 큐에 저장하는 것이고
  + D -1은 가장 작은 수를 삭제, D 1은 가장 큰 수를 하나만 삭제하는 것
- 최소 힙과 최대 힙을 우선 순위 큐를 사용하여 구현한 뒤
- I인 경우 최소 힙과 최대 힙에 각각 숫자를 추가합니다.
- D -1인 경우 최소 힙에서 최소 값을 하나 꺼내고```poll()``` 그 값을 최대 힙에서 삭제합니다. ```remove()```
- D 1인 경우는 최대 힙에서 최대값을 하나 꺼내고 그 값을 최소 힙에서 삭제합니다.
- 최종적으로 최대 힙에 값이 없는 경우는 [0, 0]을 값이 있는 경우는 [최대 힙에서 최대값, 최소 힙에서 최솟값]을 각각 꺼내 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000000)

### Level 3. 야근 지수
- 근무시간 n과 작업량 목록이 주어졌을 때 n 시간 뒤 남아있는 작업들의 제곱의 합 중 최소값을 구하는 문제
- 큰 수들을 빨리 줄이는 것이 최종 값을 가장 작게 만들 수 있다고 생각해서
- 작업량을 최대힙에 넣고 n 번 반복하면서 최대값을 꺼내 1 줄이고 다시 최대 힙에 넣었습니다.
- 최종적으로 힙의 값들을 하나씩 빼서 제곱해 모두 더한 뒤, 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000000)

### Level 3. 

