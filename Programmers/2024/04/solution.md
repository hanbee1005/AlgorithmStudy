# 문제 풀이

### Level 2. 3 * N 타일링
- 가로 1, 세로 2 크기의 타일이 주어졌을 때, 세로 3, 가로 n 크기의 벽을 채우는 방법의 수를 구하는 문제
- 홀수인 경우는 딱 맞게 채울 수 없기 때문에 0을 반환
- 짝수인 경우 2인 경우는 총 3개, 4인 경우는 2인 경우의 수에 2인 경우의 수를 곱해 9인 것 같지만 특이한 경우 2가지가 더 존재해서 11이고
- 6인 경우에도 마찬가지로 4인 경우에 2인 경우의 수를 곱한 뒤(11 * 3), 앞이 2이고 뒤가 4일 때 예외로 있던 2가지 경우를 곱해 3 * 2 = 6, 현재 특수 케이스인 2를 더해 총 41입니다.
- 이를 식으로 표현하면 ```f(n) = f(n - 2) * 3 + (f(n - 4) + f(n - 6) + ... + f(2) * 2 ) + 2``` 가 됩니다.
- 따라서 2차원 배열 dp를 만들고 각 인덱스의 0번째에는 지금 위치에서 구할 수 있는 경우의 수, 1번째에는 이전까지의 합을 저장한 뒤
- 위에 식에 맞게 n / 2 = idx 위치에 나올 수 있는 경우의 수를 구한 뒤, 최종적으로 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n / 2) (n <= 5000)

### Level 2. 유사 칸토어 비트열
- n 번째 유사 칸토어 비트열에서 l부터 r까지 위치에 있는 1의 개수를 구하는 문제
  + 0은 00000, 1은 11011로 변경
- l - 1 부터 r - 1 까지 확인하면서
- 현재 위치의 수를 5의 n - 1 제곱으로 나눕니다.
- 이때 몫이 2라면 중간 부분인 0에 해당하므로 그대로 멈추고 다음 위치를 확인합니다.
- 2가 아니라면 나머지를 현재 숫자로 하고 나누는 수를 5로 나누어 다시 위 과정을 반복합니다.
- 나누는 수가 1이 된 경우 이때 현재 수가 2가 아니라면 1을 최종 응답에 더하는 식으로 모든 위치를 확인한 뒤 해당 값을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(5 ^ n) (n <= 20)

### level 2. 아날로그 시계
- 시작 시간 시,분,초와 종료 시간 시,분,초가 주어졌을 때 시작 시간부터 종료 시간까지 이동할 동안 울리는 알람의 횟수를 구하는 문제
  + 시침, 분침이 초침과 만날 때마다 알람이 울림
- 먼저 시작 시간과 종료 시간을 모두 초로 변경합니다. (h * 60 * 60 + m * 60 + s)
- 그런 다음 ```00시 00분 00초부터 종료 시간까지 울린 알림 수 - 00시 00분 00초부터 시작 시간까지 울린 알림 수 + 시작 시간이 알림 시간이 경우``` 로 총 알림 횟수를 구할 수 있습니다.
- 00시 00분 00초부터 목표 시간까지 울린 알림의 수를 구하는 방법은 다음과 같습니다.
  + 시침은 12시간(43200초)에 한바퀴를 돌고 같은 시간동안 초침은 720 바퀴를 돕니다. 이때 정각에서 만나는 것을 제외하고 시침은 한바퀴를 도는 43200초동안 알람이 719번 울리며 즉, 43200/719 초마다 1회 울리게 되므로 ```현재 시간 * 719 / 43200```으로 알림이 울린 횟수를 구할 수 있습니다.
  + 분침은 1시간 (3600초)에 한바퀴를 돌고 같은 시간동안 초침은 60 바퀴를 돕니다. 이때도 정각에서 만나는 것을 제외하고 3600/59 초마다 울린다고 했을 때 ```현재 시간 * 59 / 3600```으로 알림 횟수를 구할 수 있습니다.
  + 이후 현재 시간이 43200 이상인 경우는 시간에 울리는 알람과 분에 울리는 알람 모두에 포함되어 포함되는 수를 빼줘야 합니다.
- 시간 복잡도: O(1)

### level 2. 당구 연습
- 당구대의 크기와 시작 지점, 목표 지점 목록이 주어졌을 때, 벽을 치고 목표 지점을 치는 최단 거리를 구하는 문제
- 시작점부터 목표 지점까지 입사각과 반사각이 같다면 이는 벽을 기준으로 벽에 찍힌 점에서 목표 지점의 반대에 있는 점까지 그은 선도 같은 각을 가지게 되고 이때 시작점부터 목표 지점의 반대 지점까지의 거리가 최단 거리가 됩니다.
- 먼저 목표 지점을 확인하고 상하좌우 각 끝선을 기준으로 반대편에 있는 점까지의 거리를 구한 뒤 그 중 최소값을 정답 배열에 넣고 최종적으로 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000)

### level 2. 도넛과 막대 그래프
- 정점과 이어진 정점들이 주어졌을 때, 기준점과 도넛, 직선, 8자 그래프의 개수를 구하는 문제
- 이 문제는 규칙이 있습니다. 조건들을 확인해보면
- 기준점이 되는 점은 나간 간선의 수가 2이상이고 들어오는 간선은 없어야 합니다.
- 직선 그래프에 해당하는 점이라면 나간 간선은 없지만 들어오는 간선이 1이상이어야 합니다.
- 8자 그래프에 해당하는 점이 되려면 나간 간선의 수와 들어온 간선의 수 모두 2 이상이어야 합니다.
- 그리고 마지막으로 도넛 그래프의 경우 기준점에서 나간 간선의 수에서 직선과 8자 그래프에 쓰인 수를 빼면 구할 수 있습니다.
- 시간 복잡도: O(2n) (n <= 1000000)

### level 3. 정수 삼각형
- 삼각형 모양의 정수 배열이 주어졌을 때 위에서부터 차례대로 지나오면서 가장 합이 큰 경우를 구하는 문제
  + n번째 m 위치의 숫자는 n + 1 번째 m 또는 m + 1 위치의 숫자로 이동할 수 있습니다.
- 먼저 각 층의 합을 담을 2차원 배열을 만들고 주어진 삼각형의 각 층을 돌면서
- 위치가 0번째인 경우는 이전 0번째 합만 더할 수 있으므로 이전 0번째 합과 자신의 값을 더하고
- 위치가 해당 층의 끝인 경우 이전 끝 위치의 합만 더할 수 있으므로 이전 끝 위치의 합과 자신의 값을 더합니다.
- 그 외 중간 위치인 경우 현재 위치 - 1의 합과 현재 위치의 합 중 더 큰 수와 현재 위치의 합을 더합니다.
- 최종적으로 마지막 열의 값들 중 최대 값을 찾아 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n * n) (n <= 500)

### level 3. 이중 우선순위 큐
- I, D와 숫자가 명령어 형태 배열로 주어졌을 때 최종적으로 가장 큰 수와 작은 수를 배열로 반환하는 문제
  + I 숫자는 숫자를 큐에 저장하는 것이고
  + D -1은 가장 작은 수를 삭제, D 1은 가장 큰 수를 하나만 삭제하는 것
- 최소 힙과 최대 힙을 우선 순위 큐를 사용하여 구현한 뒤
- I인 경우 최소 힙과 최대 힙에 각각 숫자를 추가합니다.
- D -1인 경우 최소 힙에서 최소 값을 하나 꺼내고```poll()``` 그 값을 최대 힙에서 삭제합니다. ```remove()```
- D 1인 경우는 최대 힙에서 최대값을 하나 꺼내고 그 값을 최소 힙에서 삭제합니다.
- 최종적으로 최대 힙에 값이 없는 경우는 [0, 0]을 값이 있는 경우는 [최대 힙에서 최대값, 최소 힙에서 최솟값]을 각각 꺼내 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000000)

### Level 3. 야근 지수
- 근무시간 n과 작업량 목록이 주어졌을 때 n 시간 뒤 남아있는 작업들의 제곱의 합 중 최소값을 구하는 문제
- 큰 수들을 빨리 줄이는 것이 최종 값을 가장 작게 만들 수 있다고 생각해서
- 작업량을 최대힙에 넣고 n 번 반복하면서 최대값을 꺼내 1 줄이고 다시 최대 힙에 넣었습니다.
- 최종적으로 힙의 값들을 하나씩 빼서 제곱해 모두 더한 뒤, 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000000)

### Level 3. 단어 변환
- 시작 단어와 목표 단어 그리고 단어 배열이 주어졌을 때 단어 배열의 단어를 사용해 시작 단어에서 목표 단어를 만드는 최소 횟수를 구하는 문제
  + 단어 변환은 한번에 한 개의 알파벳만 변환이 가능
- 최소 횟수를 단어를 바꿔야 하기 때문에 BFS 를 사용하였습니다.
- 먼저 목표 단어가 목록에 없다면 변경이 불가하므로 바로 0을 반환합니다.
- 이후 변환이 가능한 단어의 위치와 해당 단어까지 선택하는데 걸린 횟수를 배열로 하여 큐에 저장합니다.
- 큐에 값이 있다면 계속 변경할 수 있는 단어를 찾아 큐에 반복해서 넣고 최종적으로 목표 단어를 찾은 경우 이때까지 선택한 단어 개수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N + E)

### Level 3. 최고의 집합
- n개의 개수로 s를 만들 수 있는 숫자 집합 중 각 원소의 곱이 최대가 되는 경우를 구하는 문제
- 각 원소의 차이가 거의 없이 비슷한 값들로 이루어졌을 때 원소의 곱이 최대가 되기 때문에
- 우선 기본값이 되는 base를 s/n 으로 구하고 나머지 s%n을 구한 뒤
- 뒤에서부터 배열을 채워가면서 현재 위치가 n - 나머지 보다 크거나 같은 경우 base 값에 1을 더해 추가하고
- n - 나머지보다 작은 경우는 base만 저장하는 형태로 최종 배열을 생성하여 반환하면 해결할 수 있습니다.
- s가 1인 경우 또는 n이 s보다 큰 경우는 숫자 배열을 만들 수 없기 때문에 바로 -1을 가진 배열을 반환하면 됩니다.git 
- 시간 복잡도: O(n) (n <= 10000)

### Level 3. 등굣길
- m * n 형태의 길과 웅덩이 위치가 리스트로 주어졌을 때 웅덩이를 피해 갈 수 있는 최단 거리의 개수를 구하는 문제
- 오른쪽과 아래로만 움직일 수 있기 때문에 최단 거리가 나옵니다.
- 마지막 학교 위치에 도달할 수 있는 최단 거리의 개수는 위에서 온 경우 + 왼쪽에서 온 경우 입니다.
- 따라서 마지막 위치부터 차례대로 확인하면서 오른쪽 개수 + 아래 개수 를 더해 문제를 해결할 수 있습니다.
- 이때 웅덩이 위치는 -1로 미리 지정하여 -1인 위치는 확인하지 않고 값을 더하지도 않도록 처리하였습니다.
- 시간 복잡도: O(n * m) (n, m <= 100) 

### Level 3. 숫자 게임
- 숫자 배열 A와 B가 주어졌을 때 B가 이기는 최대 횟수를 구하는 문제
- 두 배열을 모두 정렬한 뒤 각각 index를 확인하면서
- A의 숫자보다 B의 숫자가 작거나 같다면 B의 다음 숫자를 이어서 확인하고
- A의 숫자보다 B의 숫자가 크다면 answer를 증가시키고 A, B 모두 다음 숫자를 확인하는 방식으로 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100000)

### Level 3. 단속 카메라
- 차량의 진입, 진출 위치가 배열로 주어졌을 때 모든 차량이 적어도 하나의 단속 카메라를 만나도록 하는 최소 단속카메라 수를 구하는 문제
- 빠져 나가기 전에 모두 만나야하기 때문에 먼저 진출 기준으로 자동차를 정렬시키고
- 이전 차량의 진출 위치보다 진입 위치가 큰 경우 한 카메라에 담을 수 없는 것으로 하여 카메라 수를 증가 시키고 집입 위치가 큰 차량의 진출 위치로 비교 값을 다시 세팅합니다.
- 이렇게 반복한 뒤 지금까지 나온 카메라 수를 반환하여 문제를 해결할 수 있습니다.
- 진입 위치로 오름차순 정렬을 하는 경우 진입-진출 사이가 긴 차량 사이에 짧게 짧게 이어지지 않는 차량들에 대한 검사를 할 수 없습니다.
  + 예시) {{0, 1}, {2, 10}, {3, 4}, {5, 6}}
- 시간 복잡도: O(n) (n <= 10000)

### Level 3. 기지국 설치
- 전체 아파트 길이와 설치된 기지국의 위치, 전파 도달 거리가 주어졌을 때 모든 아파트에 전파를 전달하기 위해 세워야하는 최소 기지국의 수를 구하는 문제
- 최소 위치를 지정하고 (초기 1)
- 설치된 기지국 위치를 돌면서 해당 기지국에서 왼쪽으로 보낸 전파의 길이보다 최소 위치가 작은 경우 전파가 닿지 않은 곳이 있다는 의미로 전파가 닿지 않은 곳의 개수를 확인하고 (```station - w - min```)
- 기지국을 몇개 세워야 모두 채울 수 있는지 확인한 뒤 그 수를 정답 개수에 더해줍니다. (```cnt / (w * 2 + 1) + 나머지가 있다면 1 추가```)
- 그런 다음 최소 위치를 오른쪽으로 미치는 전파의 다음 위치로 지정합니다. (```station + w + 1```)
- 이렇게 설치된 기지국을 기준으로 모두 확인한 뒤 아직도 최소 위치가 아파트 전체 길이보다 작거나 같다면 남은 아파트에 대해 최소 기지국 수를 구한 뒤 이전 정답에 합쳐서 반환하면 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 10000)

### Level 3. 스티커 모으기 (2)
- 스티커 정보가 배열로 주어졌을 때 스티커를 떼서 그 합이 가장 큰 경우를 구하는 문제
- 첫 번째 스티커를 떼는 경우와 아니 경우에 따라 마지막 스티커를 뗄 수 있는지 여부가 결정되기 때문에 2가지 경우로 나눠서 확인합니다.
- i 번째 위치의 스티커는 (i-1)번째 스티커를 뗀 경우와 (i-2)번째 스티커를 떼고 i 번째 스티커까지 뗀 경우를 비교하여 (i-2)번째 스티커를 떼고 i 번째 스티커까지 뗀 경우가 더 큰 경우 해당 값으로 아니면 (i-1)번째 스티커를 뗀 경우로 저장합니다.
- 이렇게 계산하여 첫 번째 스티커를 떼서 나온 최대값과 첫 번째 스티커를 떼지 않았을 때 나온 최대값 중 더 큰 값을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(2n) (n <= 100000)

### Level 3. 보석 쇼핑
- 보석 진열대의 상태가 주어졌을 때 모든 보석을 1개 이상 구입할 수 있는 가장 작은 범위를 구하는 문제
- 어떤 보석들이 있는지 알 수 없기 때문에 어떤 보석의 가장 마지막 위치를 저장할 Map을 하나 생성합니다.
- 그런 다음 시작 위치, 종료 위치를 모두 0으로 설정하고 진열대를 하나씩 돌면서
- 해당 보석이 이전에 나온적이 없다면 해당 보석 위치까지는 무조건 확인을 해야하기 때문에 Map 에 마지막 위치를 저장하고 종료 위치도 현재 위치로 변경한 뒤 최종 범위를 저장해둡니다.
- 만약 이전에 나온적이 있는 보석이라면 먼저 Map에 해당 보석의 마지막 위치를 갱신하고 종료 위치도 갱신합니다.
- 이후 현재 위치의 보석과 시작 위치의 보석이 같다면 시작 위치를 Map 내 최소 값으로 변경하고
  + 현재 위치 보석과 시작 위치 보석이 같지 않을 때도 start 를 갱신하고 answer를 비교해도 되지만 
  + 현재 위치 보석과 시작 위치 보석이 같지 않을 때는 최소 위치도 변경이 없기 때문에 의미 없는 비교
- 이렇게 변경한 end - start 가 기존에 종료 위치 - 시작 위치 범위보다 작은 경우에는 시작, 종료 범위를 현재 start, end로 수정합니다.
- 이렇게 마지막 보석까지 확인한 뒤, 그 결과를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(2n) (n <= 100000)

### Level 3. 불량 사용자
- 사용자 id 목록과 불량 사용자 id가 마스킹된 목록이 주어졌을 때 불량 사용자 목록의 경우의 수를 구하는 문제
- 먼저 각 불량 사용자 id의 마스킹 경우에 해당하는 사용자 id들을 찾아 list로 저장합니다.
- 이후 각 리스트에서 이전 값과 중복되지 않게 하나씩 사용자 id를 뽑고 그 수가 불량 사용자 id의 수와 같을 때 이전에 뽑은 조합이 아니라면 1을 증가 시킵니다.
- 이렇게 모든 경우의 수를 계산하여 반환된 값의 합을 구하면 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n ^ 3) (n <= 8)

### Level 3. 

