# 문제 풀이

### level 3. [1차] 셔틀 버스
- 셔틀 운행 횟수 n, 셔틀 운행 간격 t, 한 셔틀에 탈 수 있는 크루의 수 m과 크루 도착 시간이 배열로 주어졌을 때 셔틀을 탈 수 있는 가장 늦은 시간을 구하는 문제
- 먼저 크루의 도착 시간은 분으로 변경하고 시간순으로 정렬합니다.
- 셔틀의 마지막 시간보다 모두 늦게 오는 경우 셔틀의 마지막 시간을 바로 반환합니다.
- 이제 총 셔틀 운행 횟수만큼 돌면서 크루의 도착 시간을 하나씩 확인하며 출발 시간보다 빠르고 좌석이 아직 남아 있다면 좌석을 채운 뒤, 해당 버스를 타려면 현재 크루의 도착 시간보다 빨리 와야 하므로 1분을 뺀 값을 저장해둡니다.
- 현재 크루가 셔틀을 탈 수 없는 경우 크루 확인을 종료하고 셔틀 시간을 다음 시간으로 변경합니다.
- 모든 셔틀을 운행하고 난 뒤 마지막 셔틀에 자리가 남은 경우 마지막 버스 출발 시간을 저장합니다.
- 이후 확인한 마지막 도착 시간을 문자열로 바꿔 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(c + n) (c <= 2000, n <= 10)

### level 3. 풍선 터트리기
- 숫자가 쓰인 풍선 배열이 주어졌을 때 작은 풍선을 한번만 터트려서 남길 수 있는 풍선의 수를 구하는 문제
- 최솟값보다 왼쪽에 있는 숫자들은 자신의 왼쪽에 있는 수가 모두 크면 끝까지 살아 남을 수 있고
- 최솟값보다 오른쪽에 있는 숫자들은 자신의 오른쪽에 있는 수가 모두 크면 끝까지 살아남을 수 있습니다.
- 따라서 먼저 가장 최솟값의 인덱스를 찾고
- 0부터 최솟값 인덱스까지 확인하면서 이전 최솟값보다 현재 값이 작은 경우 최솟값을 변경하고 해당 값은 끝까지 살아남을 수 있기 때문에 최종 응답을 증가시킵니다.
- 이후 다시 배열을 끝부터 최솟값 인덱스까지 거꾸로 확인하면서 이전 최솟값(다시 초기화 후)보다 현재 값이 작은 경우 최솟값을 변경하고 최종 응답을 증가시킵니다. 
- 이후 최솟값은 항상 끝까지 남을 수 있기 때문에 최종 응답에 1을 더해 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000000000)

### level 3. 다단계 칫솔 판매
- 각 판매원의 이름을 담은 배열 enroll, 각 판매원을 다단계 조직에 참여시킨 다른 판매원의 이름을 담은 배열 referral, 판매량 집계 데이터의 판매원 이름을 나열한 배열 seller, 판매량 집계 데이터의 판매 수량을 나열한 배열 amount가 매개변수로 주어질 때, 각 판매원이 득한 이익금을 나열한 배열을 return 하도록 solution 함수를 완성하는 문제
- 각 판매원의 이름을 키로 하고 판매원을 조직에 참여시킨 다른 판매원의 이름과 그 판매원을 참여시킨 상위 판매원까지의 리스트를 값으로 하는 맵 구조를 만든 다음
- 판매원의 이름을 돌면서 상위 판매원들에게 10% 주면서 조건에 맞게 분배하고 이후 결과를 반환하여 문제를 해결할 수 있습니다.
- 주의할 점은 같은 판매자가 여러번 나올 수 있기 때문에 map에서 판매원을 꺼내서 앞에 현재 판매원을 추가하는 방식으로 개발하는 경우 map에서 꺼낼 때 복사를 해서 새로운 리스트로 반복해야 합니다.
- 또한, 수수료가 0보다 작은 경우로 하면 0인 경우에 계속 반복하여 시간 초과가 날 수 있기 때문에 먼저 내가 가질 금액을 계산하여 저장하고 수수료가 1보다 작으면 종료하는 방식으로 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n * m) (n <= 10000, m <= 100000)

### level 3. 부대 복귀
- 강철부대가 위치한 지역을 포함한 총지역의 수 n, 두 지역을 왕복할 수 있는 길 정보를 담은 2차원 정수 배열 roads, 각 부대원이 위치한 서로 다른 지역들을 나타내는 정수 배열 sources, 강철부대의 지역 destination이 주어졌을 때, 주어진 sources의 원소 순서대로 강철부대로 복귀할 수 있는 최단시간을 담은 배열을 return하는 문제
- 먼저 각 지역의 연결 정보를 map으로 저장한 다음
- 도착 지점부터 연결된 지점들을 확인하면서 각 지점에 도달할 때까지 지나온 지점의 수를 배열로 저장합니다.
- 이후 sources 배열을 차례대로 확인하면서 해당 위치의 값이 있는 경우 그 값을 저장하고 만약 0이면서 도착 지점이 아니라면 도달할 수 없었던 것으로 간주하고 -1을 저장한 뒤, 최종적으로 저장한 배열을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N + E) (N <= 100000)

### level 3. 거스름돈
- 구하고자 하는 거스름돈과 동전의 종류가 배열 money로 주어졌을 때, 가진 돈으로 해당 거스름돈을 만들 수 있는 방법을 구하는 문제
- dp 방식을 통해 문제를 풀 수 있는데 ```dp[i] += dp[i - money]```
- 먼저 거스름돈보다 크기가 1 큰 dp 배열을 만들고
- money에서 돈을 하나씩 꺼내서 구하고자 하는 거스름돈보다 크다면 다음으로 넘기고
- 크지 않다면 해당 돈을 구할 수 있는 것으로 간주하여 dp 배열을 1 증가시킵니다.
- 이후 1원부터 거스름돈 금액까지 돌면서 특정 돈 j에서 해당 돈 cur을 뺐을 때 0보다 크거나 같다면 해당 돈을 사용해 특정 돈을 구할 수 있다고 간주하고 dp[j] += dp[j - cur] 을 한 뒤 다시 dp[j] 를 1000000007로 나눈 나머지를 저장하도록 합니다.
- 위 방식을 계속 반복한 뒤 dp[n] 의 돈을 반환하여 문제를 해결할 수 있습니다.
- 참고: https://20240228.tistory.com/66
- 시간 복잡도: O(n * m) (n <= 100000, m < 100)

### level 3. 합승 택시 요금
- 전체 위치 n, 시작 위치 s, A의 집 위치 a, B의 집 위치 b, 그리고 각 지점과 지점 사이의 거리가 배열로 주어졌을 때 각 집으로 갈 수 있는 최단 거리의 합을 구하는 문제 (겹치는 지점을 하나로 계산)
- 다익스트라 알고리즘을 통해 문제를 해결할 수 있습니다.
- 일단 s부터 x 지점까지 합승을 한다고 하면 (s -> x까지의 최단거리) + (x -> a까지의 최단 거리) + (x -> b까지의 최단 거리) 를 구하면 됩니다.
- 이때 방향성이 없기 때문에 x -> a의 최단거리는 a -> x의 최단거리와 동일합니다. (b도 마찬가지)
- 따라서 다익스트라 알고리즘을 통해 s 부터 각 지점까지의 최단거리, a 부터 각 지점까지의 최단거리, b부터 각 지점까지의 최단거리를 각각 구한 다음
- 각 지점까지의 최단거리의 합 중 가장 최소를 구하면 문제를 해결할 수 있습니다.
- 시간 복잡도: O(E log N) (2 <= E <= 199, 3 <= N <= 200)

### level 3. 순위 (그래프)
- 전체 선수의 수와 경기 결과가 담긴 배열이 주어졌을 때 정확하게 순위를 알 수 있는 선수의 수를 구하는 문제
- 다음과 같은 2가지 전재를 잘 지키면 DFS로 문제를 해결할 수 있습니다.
  + DFS로 탐색한다. = 첫번째 부모 노드는 다음 자식 노드를 무조건 이길 수 있다.
  + 순위를 알 수 있다. = 모든 노드와의 관계를 알 수 있다.
- 따라서 먼저 이긴 선수를 기준으로 해당 선수에게 진 선수들의 목록을 Map 형태로 저장합니다.
- 이후 어떤 선수의 경기 결과를 담은 이차원 배열을 생성합니다. 배열의 [n][0]은 이긴 횟수, [n][1]은 진 횟수를 저장하도록 합니다.
- 모든 선수에 대해서 dfs 탐색을 하면서 먼저 해당 선수는 경기를 한 것으로 간주하고 ```visited[cur] = true``` 현재 선수와 탐색을 하는 선수(base)가 다르다면 탐색을 하는 선수의 진 횟수를 1 증가시키고, 현재 선수의 이긴 횟수를 1 증가 시킵니다.
- 이어 현재 선수에게 진 선수들의 목록을 순회하면서 다음 선수가 아직 경기를 하지 않은 경우 다시 dfs 탐색을 반복하게 됩니다.
- 이후 모든 선수의 경기 결과를 확인하면서 이긴 횟수와 진 횟수의 합이 n-1 인 경우 (나 제외) 모든 선수와의 관계를 알 수 있어 순위를 확정할 수 있기 때문에 정답을 증가시킵니다.
- 이런 방식으로 모두 확인한 뒤, 결과를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N*(N+E)) (N <= 100, E <= 4500)

### level 3. 좌물쇠와 열쇠
- key에 해당하는 2차원 배열과 lock에 해당하는 2차원 배열이 주어졌을 때 key를 사용하여 lock을 풀 수 있는지 여부를 구하는 문제
- lock 중 홈이 파진 곳을 확인해야하기 때문에 우선 홈이 파진 최대 범위를 구합니다.
- 이때 모든 홈이 파져있지 않고 1이라면 해당 좌물쇠는 무조건 열린다고 생각해야 합니다. (좌물쇠의 모든 홈이 채워졌기 때문에) -> true
- 또한 유효한 범위가 key의 크기보다 크다면 해당 키로는 열 수 없다고 판단합니다. -> false
- 이제 유효한 좌물쇠를 키처럼 사용할 것인데 4번 시계방향으로 돌릴 수 있기 때문에 최상단에 4번 반복을 하고
- 현재 유효한 좌물쇠의 크기만큼 key를 [0,0]부터 잘라서 일치하는지 확인합니다. 일치한다는 것은 같은 위치의 값이 서로 다른 것을 의미합니다.
- 일치하면 바로 true를 반환하고 아닌 경우 유효한 좌물쇠를 90도 돌린 뒤 다시 key를 [0,0] 위치부터 확인하여 결과를 알 수 있고 최종적으로 모두 돌려도 맞지 않는다면 false를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(4 * (K-L+1)^2 * L^2) (3 <= K, L <= 20)

### level 3. 파괴되지 않은 건물
- board 이차원 배열과 공격인지 복구인지가 담긴 이차원 배열이 주어졌을 때 마지막까지 무너지지 않은 건물의 수를 구하는 문제
- 해당 문제를 그냥 풀게 되면 시간 초과가 발생하기 때문에 누적합을 계산하는 방식으로 문제를 해결할 수 있습니다.
- 먼저 board의 크기보다 x, y가 하나씩 큰 배열을 생성한 뒤, (x1, y1)과 (x2, y2) 사이에 n 만큼의 변화가 있다고 하면 (x1, y2) += n, (x1 + 1, y2) -= n, (x2, y1 + 1) -= n, (x2 + 1, y2 + 1) += n 으로 설정합니다.
- 해당 설정을 모두 마친 뒤, 좌에서 우로 합을 먼저 구하고 위에서 아래로도 합을 구합니다.
- 이후 board 배열의 각 위치와 비교하면서 위치의 값이 0보다 큰 경우를 모두 찾아서 반환하면 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N * M) (N <= 1000, M <= 1000)
- 참고: https://tech.kakao.com/2022/01/14/2022-kakao-recruitment-round-1/#%EB%AC%B8%EC%A0%9C-6-%ED%8C%8C%EA%B4%B4%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EA%B1%B4%EB%AC%BC

### level 3. 인사 고과
- 원호의 점수를 포함한 직원들의 점수가 배열로 주어졌을 때 원호의 순위를 구하는 문제
- 먼저 합이 원호의 점수보다 낮다면 확인할 필요가 없기 때문에 필터로 제외하고
- 합, 0번째 점수, 1번째 점수가 낮은 순으로 정렬합니다.
- 그리고 맨 앞에 다시 원호의 점수를 추가합니다. (처음 필터링 때 빠졌기 때문)
- 그리고 필터링 후 정렬된 배열을 차례로 확인하면서 자신보다 큰 점수를 가진 모든 사람과 비교했을 때 한번이라도 0, 1 점수 모두 작다면 인센티브를 받을 수 없는 것으로 처리합니다.
- 이때 원호가 인센티브를 받을 수 없다면 바로 -1을 반환하면 되고
- 인센티브를 받을 수 있다면 원호보다 높은 순위이므로 정답을 증가시킵니다.
- 최종적으로 지금까지 나온 값에 1을 더하면 원호의 순위를 구할 수 있습니다.
- 시간 복잡도: O(n^2) (n <= 100000)

### level 3. 표 편집
- 총 행의 개수 n, 현재 위치 k, 명령 배열이 주어졌을 때 삭제된 행과 아닌 행을 X, O로 표시하는 문제
- 이 문제는 삭제를 하고 삭제된 것 중 최신 것부터 해당 위치로 다시 되돌리는 것에 초점을 맞춰 Stack을 통해 해결할 수 있습니다.
- 먼저 이전 위치와 다음 위치를 같이 저장할 Node라는 클래스를 구현합니다.
- 그리고 각 위치의 이전 위치를 담은 배열 pre, 다음 위치를 담은 배열 next를 만들고 초기화를 합니다. (맨 앞의 이전, 맨 뒤의 다음은 -1로 초기화)
- Node를 담을 stack도 생성합니다. 이전 위치로 돌려야하기 때문에 삭제 당시의 이전 위치, 다음 위치를 함께 저장할 수 있어야 합니다.
- 그리고 우선 결과를 모두 'O'으로 초기화 합니다.
- 그리고 명령을 하나씩 확인하면서 작업을 수행하면 됩니다.
  + D 인 경우 다음 나오는 숫자만큼 pre 배열에서 현재 위치의 이전 위치를 확인하면서 현재 위치를 이동시킵니다.
  + U 인 경우 다음 나오는 숫자만큼 nect 배열에서 현재 위치의 다음 위치를 확인하면서 현재 위치를 이동시킵니다.
  + C 인 경우 현재 위치의 이전 위치, 다음 위치를 담은 Node 인스턴스를 만들어서 Stack 에 저장하고 (최신꺼부터 복원하기 위함) 현재 위치의 문자를 'X'로 변경합니다. 그리고 현재의 다음 위치가 -1로 맨 끝을 삭제한거라면 현재의 이전 위치의 다음 위치를 -1로 변경하고, 현재의 이전 위치가 -1로 맨 앞을 삭제한거라면 현재의 다음 위치의 이전 위치를 -1로 변경합니다. 그외의 경우에는 현재의 이전 위치의 다음 위치를 현재 위치의 다음 위치로, 현재의 다음 위치의 이전 위치를 현재의 이전 위치로 변경합니다. 이후 현재의 다음 위치가 -1로 맨 끝인 경우는 현재의 이전 위치를 현재 위치로 그 외의 경우는 모두 현재의 다음 위치를 현재 위치로 갱신합니다.
  + Z 인 경우 Stack에서 Node를 뽑고 해당 노드의 현재 위치 문자를 다시 'O'로 변경합니다. 그리고 노드의 다음 위치가 -1로 맨 끝인 경우 노드의 이전 위치의 다음 위치를 노드의 현재 위치로, 노드의 이전 위치가 -1로 맨 앞인 경우 노드의 다음 위치의 이전 위치를 현재 노드 위치로 변경합니다. 그 외의 경우는 두가지 모두 갱신합니다.
- 이렇게 모든 명령을 확인하고 문자열을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n * m) (n <= 1000000, m <= 200000)

### level 3. 길 찾기 게임
- {x, y} 좌표 목록이 주어졌을 때 이진 트리로 만들어 전위 순회, 후위 순회한 결과를 2차원 배열로 만들어 반환하는 문제
- 전위 순회의 경우 현재 위치를 먼저 탐색하고 좌,우를 탐색하고 후위 순회의 경우는 좌,우를 탐색하고 현재 위치를 탐색하게 됩니다.
- 따라서 x 좌표를 기준으로 {x, y, i} 형태를 만들어 순서대로 정렬합니다. (현재 위치를 기준으로 x 좌표가 더 작은 위치를 탐색하고 그 다음 x 좌표가 큰 위치를 탐색하기 위해)
- 그런 다음 재귀를 돌면서 root 노드를 찾고 찾은 root 노드의 i 값을 전위 순회 결과 배열에 추가한 뒤
- 루트보다 이전에 위치한 노드들을 재귀 돌리고 루트보다 이후 노드들을 재귀 돌립니다.
- 이후 다시 현재 루트 노드의 i 값을 후위 순회 결과 배열에 추가합니다.
- 재귀로 루트 탐색을 마친 뒤 결과 배열을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(NlogN) (N <= 10000)

### level 3. 


