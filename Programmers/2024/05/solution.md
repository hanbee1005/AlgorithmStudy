# 문제 풀이

### level 3. [1차] 셔틀 버스
- 셔틀 운행 횟수 n, 셔틀 운행 간격 t, 한 셔틀에 탈 수 있는 크루의 수 m과 크루 도착 시간이 배열로 주어졌을 때 셔틀을 탈 수 있는 가장 늦은 시간을 구하는 문제
- 먼저 크루의 도착 시간은 분으로 변경하고 시간순으로 정렬합니다.
- 셔틀의 마지막 시간보다 모두 늦게 오는 경우 셔틀의 마지막 시간을 바로 반환합니다.
- 이제 총 셔틀 운행 횟수만큼 돌면서 크루의 도착 시간을 하나씩 확인하며 출발 시간보다 빠르고 좌석이 아직 남아 있다면 좌석을 채운 뒤, 해당 버스를 타려면 현재 크루의 도착 시간보다 빨리 와야 하므로 1분을 뺀 값을 저장해둡니다.
- 현재 크루가 셔틀을 탈 수 없는 경우 크루 확인을 종료하고 셔틀 시간을 다음 시간으로 변경합니다.
- 모든 셔틀을 운행하고 난 뒤 마지막 셔틀에 자리가 남은 경우 마지막 버스 출발 시간을 저장합니다.
- 이후 확인한 마지막 도착 시간을 문자열로 바꿔 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(c + n) (c <= 2000, n <= 10)

### level 3. 풍선 터트리기
- 숫자가 쓰인 풍선 배열이 주어졌을 때 작은 풍선을 한번만 터트려서 남길 수 있는 풍선의 수를 구하는 문제
- 최솟값보다 왼쪽에 있는 숫자들은 자신의 왼쪽에 있는 수가 모두 크면 끝까지 살아 남을 수 있고
- 최솟값보다 오른쪽에 있는 숫자들은 자신의 오른쪽에 있는 수가 모두 크면 끝까지 살아남을 수 있습니다.
- 따라서 먼저 가장 최솟값의 인덱스를 찾고
- 0부터 최솟값 인덱스까지 확인하면서 이전 최솟값보다 현재 값이 작은 경우 최솟값을 변경하고 해당 값은 끝까지 살아남을 수 있기 때문에 최종 응답을 증가시킵니다.
- 이후 다시 배열을 끝부터 최솟값 인덱스까지 거꾸로 확인하면서 이전 최솟값(다시 초기화 후)보다 현재 값이 작은 경우 최솟값을 변경하고 최종 응답을 증가시킵니다. 
- 이후 최솟값은 항상 끝까지 남을 수 있기 때문에 최종 응답에 1을 더해 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000000000)

### level 3. 다단계 칫솔 판매
- 각 판매원의 이름을 담은 배열 enroll, 각 판매원을 다단계 조직에 참여시킨 다른 판매원의 이름을 담은 배열 referral, 판매량 집계 데이터의 판매원 이름을 나열한 배열 seller, 판매량 집계 데이터의 판매 수량을 나열한 배열 amount가 매개변수로 주어질 때, 각 판매원이 득한 이익금을 나열한 배열을 return 하도록 solution 함수를 완성하는 문제
- 각 판매원의 이름을 키로 하고 판매원을 조직에 참여시킨 다른 판매원의 이름과 그 판매원을 참여시킨 상위 판매원까지의 리스트를 값으로 하는 맵 구조를 만든 다음
- 판매원의 이름을 돌면서 상위 판매원들에게 10% 주면서 조건에 맞게 분배하고 이후 결과를 반환하여 문제를 해결할 수 있습니다.
- 주의할 점은 같은 판매자가 여러번 나올 수 있기 때문에 map에서 판매원을 꺼내서 앞에 현재 판매원을 추가하는 방식으로 개발하는 경우 map에서 꺼낼 때 복사를 해서 새로운 리스트로 반복해야 합니다.
- 또한, 수수료가 0보다 작은 경우로 하면 0인 경우에 계속 반복하여 시간 초과가 날 수 있기 때문에 먼저 내가 가질 금액을 계산하여 저장하고 수수료가 1보다 작으면 종료하는 방식으로 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n * m) (n <= 10000, m <= 100000)

### level 3. 

