# 문제 풀이

### level 3. 외벽 점검
- 전체 외벽의 크기 n, 점검해야하는 위치 배열 weak, 동료가 움직일 수 있는 거리 배열 dist 가 주어졌을 때 모든 점검 위치를 다 채크하기 위해 필요한 최소 동료 수를 구하는 문제
- 동료들은 시계 방향과 반시계 방향 모두 이동할 수 있는데 이는 사실 중요하지 않습니다. 어느 방향이든 취약점부터 시작하게 되면 최대의 점검 효율을 낼 수 있기 때문입니다.
- 따라서 한 방향으로 쭉 간다고 생각하고 확장 배열을 만들어줍니다. 즉, 1, 5, 6, 10 뒤에 각 위치에 12(n)을 더한 13, 17, 18, 22를 붙여 어떤 취약점 위치에서 시작해도 전체를 다 확인할 수 있게 해줍니다.
- 이후 시작 위치를 바꾸면서 dfs 방식으로 친구들을 모두 위치시킵니다.
- 친구들을 위치시키는 모든 경우의 수를 구한 뒤, 이때 벽을 점검할 수 있는 친구의 수를 구해 최솟값을 갱신해줍니다.
- 친구를 확인하는 방법은 다음과 같습니다.
  + (첫 취약점 위치 + 친구가 이동할 수 있는 거리)를 pos 로 지정하고
  + 취약점 시작 위치부터 마지막 위치까지 반복하면서
  + pos가 점검해야하는 위치보다 작으면 추가로 더 친구가 필요하므로 친구 수를 증가 시키고
  + 증가된 친구의 수가 전체 친구의 수보다 크다면 점검이 불가한 것으로 판단해 확인을 종료하고 MAX 값을 반환합니다.
  + 그렇지 않은 경우 pos를 이동한 위치의 취약점 + 다음 친구의 위치로 이동시키고 위 과정을 반복한 뒤, 끝지점까지 확인했을 때 친구 수를 반환합니다.
- 이렇게 모든 경우를 확인한 뒤 최소 친구 수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(m^2 * n!) (m <= 15, n <= 8)

### level 3. 110 옮기기
- 1과 0으로 이루어진 문자열 배열이 주어졌을 때 각 110 단위로 움직여서 각 문자를 사전순으로 오름차순 정렬한 배열을 반환하는 문제
- 각 문자를 반복하면서 110 인 구간을 찾고 아닌 문자는 모두 붙입니다.
- 110을 제외한 문자열 중 0을 포함하고 있지 않다면 찾은 110을 모두 맨 앞에 붙이고
- 0이 존재하는 경우 마지막 0을 찾아 그 다음에 110을 붙여주면 사전순으로 오름차순 정렬이 됩니다.
- 이렇게 모든 문자를 확인한 뒤 그 결과 배열을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N * M) (N, M <= 1000000)

### level 3. 