# 문제 풀이

### level 3. 외벽 점검
- 전체 외벽의 크기 n, 점검해야하는 위치 배열 weak, 동료가 움직일 수 있는 거리 배열 dist 가 주어졌을 때 모든 점검 위치를 다 채크하기 위해 필요한 최소 동료 수를 구하는 문제
- 동료들은 시계 방향과 반시계 방향 모두 이동할 수 있는데 이는 사실 중요하지 않습니다. 어느 방향이든 취약점부터 시작하게 되면 최대의 점검 효율을 낼 수 있기 때문입니다.
- 따라서 한 방향으로 쭉 간다고 생각하고 확장 배열을 만들어줍니다. 즉, 1, 5, 6, 10 뒤에 각 위치에 12(n)을 더한 13, 17, 18, 22를 붙여 어떤 취약점 위치에서 시작해도 전체를 다 확인할 수 있게 해줍니다.
- 이후 시작 위치를 바꾸면서 dfs 방식으로 친구들을 모두 위치시킵니다.
- 친구들을 위치시키는 모든 경우의 수를 구한 뒤, 이때 벽을 점검할 수 있는 친구의 수를 구해 최솟값을 갱신해줍니다.
- 친구를 확인하는 방법은 다음과 같습니다.
  + (첫 취약점 위치 + 친구가 이동할 수 있는 거리)를 pos 로 지정하고
  + 취약점 시작 위치부터 마지막 위치까지 반복하면서
  + pos가 점검해야하는 위치보다 작으면 추가로 더 친구가 필요하므로 친구 수를 증가 시키고
  + 증가된 친구의 수가 전체 친구의 수보다 크다면 점검이 불가한 것으로 판단해 확인을 종료하고 MAX 값을 반환합니다.
  + 그렇지 않은 경우 pos를 이동한 위치의 취약점 + 다음 친구의 위치로 이동시키고 위 과정을 반복한 뒤, 끝지점까지 확인했을 때 친구 수를 반환합니다.
- 이렇게 모든 경우를 확인한 뒤 최소 친구 수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(m^2 * n!) (m <= 15, n <= 8)

### level 3. 110 옮기기
- 1과 0으로 이루어진 문자열 배열이 주어졌을 때 각 110 단위로 움직여서 각 문자를 사전순으로 오름차순 정렬한 배열을 반환하는 문제
- 각 문자를 반복하면서 110 인 구간을 찾고 아닌 문자는 모두 붙입니다.
- 110을 제외한 문자열 중 0을 포함하고 있지 않다면 찾은 110을 모두 맨 앞에 붙이고
- 0이 존재하는 경우 마지막 0을 찾아 그 다음에 110을 붙여주면 사전순으로 오름차순 정렬이 됩니다.
- 이렇게 모든 문자를 확인한 뒤 그 결과 배열을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N * M) (N, M <= 1000000)

### level 3. 표현 가능한 이진 트리
- 숫자 배열이 주어졌을 때 이진 수로 나타낸 뒤 해당 이진수를 이진트리로 만들 수 있는 경우 1, 없는 경우 0을 반환하는 문제
- 주어진 숫자를 이진수로 만들어 StringBuilder에 저장하고
- 이진수의 길이가 1이라면 변경된 숫자를 그대로 반환 값으로 저장하고 다음 숫자를 확인합니다.
- 이진 수로 만든 뒤, 완전 이진 트리를 만들기 위해 크기를 계산하여 앞에 0을 채워줍니다.
- 그런 뒤 분할 정복을 통해 반으로 크기를 나눠가면서 비교하면 되는데
- 주어진 이진수가 1을 포함하고 있지 않다면 모두 더미노드로 이루어진 경우로 이진트리를 만들 수 있다고 가정해 true를 반환하고
- 이진수의 길이가 3인 경우는 가운데 수가 0인지 확인하여 0이라면 이진 트리를 만들지 못하므로 false, 그렇지 않다면 true를 반환합니다.
- 그 외 경우에는 중간 수를 구해서 중간 수가 0이면 false를 아닌 경우 양쪽을 나눠서 양쪽 모두 이진 트리를 만들 수 있는 경우에만 true를 반환하도록 재귀 메서드를 구성합니다.
- 이후 이렇게 구한 값들을 배열로 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N * (logM)^2) (N <= 10000, M <= 10^15)

### level 3. 