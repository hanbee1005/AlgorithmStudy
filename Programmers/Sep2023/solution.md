# 문제 풀이

### Level 2. 무인도 여행 (9월 1일)
- 문자 'X'와 숫자 1~9 사이로 이루어진 문자열 배열이 주어진 경우 2차원 배열에서 숫자인 경우 상하좌우로 이동이 가능하다고 할 때 한번에 이동가능한 위치의 숫자 합의 목록을 반환하는 문제입니다.
- 이 문제는 DFS 방식으로 풀이를 하였습니다. 먼저 주어진 문자열을 2차원 배열로 생성하고 해당 위치를 지나갔는지 여부를 확인할 수 있는 visited 배열도 생성합니다.
- 이후 전체 위치를 이중 for 문을 통해 이동하면서 해당 위치로 이동이 가능하고(X가 아닌 경우) 아직 방문하지 않은 경우에 해당 위치로 이동한 뒤 stack 에 위치 정보를 저장합니다.
- 현재 위치의 값을 sum 에 더하고 더 이상 이동할 위치가 없을 때까지 현재 위치에서 상하좌우로 이동할 위치를 확인한 뒤 이동이 가능한 경우는 위치 정보를 stack 에 저장하고 visited 를 true 로 변경합니다.
- 이렇게 한번에 이동 가능한 모든 위치를 확인한 뒤 지금까지 더한 각 위치 값의 합인 sum을 정답 목록에 저장합니다.
- 최종적으로 정답 목록을 오름차순으로 정렬하여 반환하면 문제를 해결할 수 있습니다.

### Level 2. 줄 서는 방법
- n 명의 사람을 순서대로 세울 수 있는 방법 중 k 번째에 해당하는 경우 순서를 반환하는 문제입니다.
- 이 문제는 순열을 직접 만드는 방식으로는 효율성 테스트를 통과할 수 없었고 팩토리얼과 관련이 있다는 것을 알고 해결할 수 있었습니다.
- 배열 [1, 2, 3, 4] 가 주어졌을 때 나올 수 있는 경우의 수는 모두 4! = 24개 입니다. 이때 각 앞자리가 정해지는 경우는 24를 4로 나눈 6이 됩니다. 즉, 6번째마다 앞자리가 바뀌는 것입니다.
- 다른 말로 하자면 1부터 6까지는 시작이 1, 7부터 12까지는 시작이 2, 13부터 18까지는 시작이 3, 19부터 24까지는 시작이 4인 것입니다. 하지만 인덱스는 0부터 시작이고 순서의 끝 숫자를 나눴을 때 몫이 증가하기 때문에 k 를 k - 1로 변환하여 (k - 1) / 6 로 하게 되면 원하는 대로 첫 숫자에 해당하는 인덱스를 구할 수 있습니다.
- 이때 6은 사실 3! 로 다시 말하면 현재 배열의 길이보다 하나 작은 팩토리얼만큼 나누어 떨어진다는 것을 의미합니다.
- 이런 방식으로 n자리부터 1자리까지 반복하면 문제를 해결할 수 있습니다.
- [1, 2, 3, 4] 와 k = 6 이 주어졌을 때, 처음 자리수를 살펴보면 [1, 2, 3, 4] > [1, 2, 4, 3] > [1, 3, 2, 4] > [1, 3, 4, 2] > [1, 4, 2, 3] > [1, 4, 3, 2] 와 같이 되어 1이어야 합니다. 따라서 자리 수를 구할 때는 (k - 1) / factorial[n - 1]을 통해 5 / 6을 해야 합니다.
- 그리고 나서 남은 것들 중에 몇번째인지 구하기 위해 나머지 값을 다시 remain 에 대입합니다.
- 이렇게 남겨지는 숫자가 1개가 될 때까지 반복한 뒤 마지막 값을 제일 끝에 저장 후 반환하면 문제를 해결할 수 있습니다.

### Level 2. 호텔 대실
- 호텔 예약 시작과 종료 시간이 문자열 배열로 주어졌을 때 겹치지 않고 사용할 수 있는 방의 최소 개수를 구하는 문제입니다.
- 이 문제는 시간을 분으로 변환하여 숫자로 표현하였고 시작부터 종료에 해당하는 인덱스의 값을 1씩 증가시켰습니다.
- 최종적으로 가장 큰 수가 겹치는 방의 개수이기 때문에 이를 반환하여 문제를 해결하였습니다.
- 방을 이용한 경우 추가 10분이 청소시간으로 추가되는 점을 고려하여야 합니다.

### Level 2. 마법의 엘리베이터
- 현재 층이 주어지면 0층까지가는데 누른 버튼의 수가 가장 적은 경우를 반환하는 문제입니다. 버튼은 10의 제곱수로 이동이 가능합니다.
- 각 수를 확인하여 0부터 4까지의 경우 아래로 빼는 것이 효율적이고 6부터 9까지는 위로 올리는 것이 효율적입니다.
- 5인 경우에는 그 앞의 위치가 5 미만일 때는 아래로 빼는 것이 좋고 5 이상은 위로 올리는 것이 효율적입니다.
- 예를 들어 15층이 현재 위치라면 15, 14, 13, 12, 11, 10, 0 으로 6번만에 0층으로 이동할 수 있고
- 75층이 현재 위치라면 75, 76, 77, 78, 79, 80, 90, 100, 0으로 8번만에 0층으로 이동할 수 있습니다.
- 따라서 현 위치를 10으로 나눠 나눈 나머지가 5 초과인 경우 10에서 뺀 값을 추가하고 5 이하인 경우 나머지 값을 그대로 더합니다.
- 그러고 나서 원래 층을 10으로 나눈 몫을 원래 층의 값에 넣어주는데 나머지가 5 초과 또는 5인데 그 앞의 값을 10으로 나눈 값이 5 이상일 때는 위로 이동한 경우라고 생각하고 원래 층에 1을 더해 줍니다.
- 위 과정들을 반복해서 현재 층이 0이 될 때까지 더한 값을 반환하여 문제를 해결할 수 있습니다.

### Level 2. 숫자 카드 나누기
- 두 숫자 배열이 주어지는 경우 A 배열을 모두 나눌 수 있지만 B 배열은 모두 나눌 수 없는 또는 A 배열은 모두 나눌 수 없지만 B 배열은 모두 나눌 수 있는 최대 수를 구하는 문제입니다.
- 이 문제는 먼저 각 배열의 최대 공약수를 구한 다음
- A 배열을 B 배열의 최대 공약수로 나눠 모두 0 이 되지 않거나 B 배열을 A 배열의 최대 공약수로 나눠 모두 0 이 되지 않는 경우 두 공약수의 최대값을 반환하고 그 외는 0을 반환하도록 함으로써 해결할 수 있습니다.

### Level 2. 시소 짝꿍
- 몸무게가 주어지는 경우 2, 3, 4배를 하여 위치를 이동하는 경우 평행을 이루게 하는 짝의 개수는 몇 개인지 구하는 문제입니다.
- 무게를 비교하는 경우는 총 4가지가 있습니다.
	+ 자기 자신과 무게가 같은 경우 (1 : 1)
	+ 본인의 2배와 상대의 3배가 같은 경우 (2 : 3)
	+ 본인의 2배와 상대의 4배가 같은 경우 (2 : 4)
	+ 본인의 3배와 상대의 4배가 같은 경우 (3 : 4)
- 따라서 현재 무게가 n 인 경우에 나올 수 있는 무게는 n, n * 3 / 2, n * 4 / 2 (= n * 2), n * 4 / 3 입니다.
- 이렇게 나온 무게를 Map의 키로 하고 해당 무게가 몇번이나 나오는지를 value로 저장합니다.
- 주어진 각 무게를 확인하면서 해당 무게가 이미 나온 경우 이전에 나온 무게의 수만큼 경우의 수를 더 만들 수 있기 때문에 해당 값을 answer에 추가해주면 됩니다.
- 이후 위 과정들을 전체 무게를 모두 순회하면서 확인하면 문제를 해결할 수 있습니다.

### Level 2. 이모티콘 할인 행사
- 이모티콘 할인율에 따라 이모티콘을 구매할 때 멤버십 가입을 가장 많이 하는 경우를 구하는 문제입니다.
- 먼저 이모티콘별 할인율 경우의 수를 모두 구합니다. 예시로 이모티콘이 2개인 경우 총 16개의 경우가 나옵니다.
- 이후 각 이모티콘 할인율이 적용되었을 때 구매할 수 있는 경우를 확인하고 구매할 때 구매 가능 금액보다 많은 경우에는 멤버십 가입자 수를 증가시킵니다.
- 이렇게 할인율별 전체 사용자의 구매 현황을 확인하고 기존 응답값과 비교하여 멤버십 가입자수가 더 크거나 멤버십 가입자수가 같고 판매 비용이 많은 경우를 최종 응답으로 반환하면 문제를 해결할 수 있습니다.

### Level 2. 택배 배달과 수거하기
- 트럭의 크기와 배달해야할 택배 수, 수거해야할 택배 수가 집마다 주어질 때 최단 거리로 모든 택배를 배달하고 수거할 때의 거리를 구하는 문제입니다.
- 특정 집에 방문해야 하는 횟수는 (상자의 수 - 1) / cap + 1 입니다. 즉, cap 이 4일 때 상자의 수가 4개 이하일 때는 1번만 방문해도 되지만 5개라면 2번 방문해야 합니다.
- 또한 멀리 있는 집을 방문할 때 트럭에 공간이 있다면 이전 집의 택배들도 한번에 배달 및 수거할 수 있습니다.
- 따라서 먼저 배달 가능한 상자의 수와 수거 가능한 상자의 수를 변수로 선언하고
- 각 집을 뒤에서부터 방문하면서 해당 집에 배달할 택배 또는 수거할 택배가 있는 경우 다음 로직을 반복합니다.
- 배달 가능한 상자의 수와 수거 가능한 상자의 수에서 현재 위치의 상자들을 빼줍니다.
- 만약 배달 가능한 상자의 수와 수거 가능한 상자의 수가 음수가 되는 경우 해당 위치를 방문해야 합니다. (더 멀리 있는 집을 갈 때 수거할 수 있는 수를 초과했기 때문)
- 이때 배달 가능한 상자의 수와 수거 가능한 상자의 수를 기반으로 해당 위치를 몇번 방문해야 하는지 확인하고
- 방문 횟수 * 거리 * 2(왕복)를 이동 거리에 추가해줍니다.
- 이후 해당 위치를 방문하는데 가져갈 수 있는 상자의 수를 배달 가능한 상자의 수, 수거 가능한 상자의 수에 추가해주고 위 과정을 처음 집까지 반복합니다.
- 최종적으로 지금까지 합산된 이동거리를 반환하면 해결할 수 있는 문제입니다.

### Top Coder Level 1. 키위 주스
- 각 병의 용량이 주어졌을 때 키위 주스를 주어진 케이스에 따라 모두 옮긴 후 남은 각 병의 용량을 담은 배열을 반환하는 문제입니다.
- 시뮬레이션을 통해 문제를 해결할 수 있습니다.
- 모든 케이스를 확인하면서 fromId 위치의 병에 담긴 용량과 toId 위치의 병의 남은 공간 중 작은 값을 이동할 수 있는 용량이라고 하고
- fromId 위치의 병에서 이동할 수 있는 용량을 빼고 toId 위치의 병에서 이동할 수 있는 용량을 더해줍니다.
- 위 과정을 모두 반복한 뒤 결과를 반환하여 문제를 해결할 수 있습니다.

### Top Coder Level 1. 즐거운 파티
- 친구들의 첫번째, 두번째 취미가 주어졌을 때 가장 많은 친구들의 공통 취미가 있을 때 친구들의 수를 구하는 문제입니다.
- 전체 탐색을 통해 해결할 수 있으며 취미를 모두 확인하면서 해당 취미를 몇명이 좋아하는지 확인합니다.
- Map 을 만들어 취미를 키로 하고 몇명이나 좋아하는지를 value 로 한 뒤 최종적으로 value 중 최대값을 반환하여 문제를 해결할 수 있습니다.

### Top Coder Level 1. 암호
- 숫자 배열이 주어졌을 때 수를 하나 골라 1 증가 시킨 뒤 전체 수를 곱한 곱이 가장 커질 때를 곱의 최대값을 반환하는 문제입니다.
- 이 문제는 전체 수를 모두 for 문으로 돌면서 확인할 수 있지만 가장 작은 수를 찾아 1을 더해 문제를 해결할 수 있습니다.

### Top Coder Level 2. 재미있는 수학
- 몇진수인지 주어졌을 때 n의 배수의 각자리의 수의 합이 n의 배수가 되는 수를 구하는 문제입니다.
- 4자리 미만으로 제한이 있기 때문에 전체 탐색을 통해 해결해도 되지만 수학적인 식을 통해 문제를 더 빠르게 해결할 수 있습니다.
- ```a x n x n + b x n + c``` 는 ```a x (n - 1) x (n - 1) + (b - 2a) x (n - 1) + (a + b + c)``` -> ```((a x (n - 1) + b - 2a) x (n - 1)) + (a + b + c)``` 로 나타낼 수 있기 때문에
- 해당 수가 (n-1)과 그의 약수라는 것으로 문제를 해결할 수 있습니다.

### Top Coder Level 1. 회문
- 문자열이 주어질 경우 회문을 만드는 가장 짧은 길이를 반환하는 문제입니다.
- 문자열 길이를 기준으로 회문이 될 수 있는 경우를 확인하여 회문이 된다면 해당 길이를 반환하면 됩니다.
- 처음 주어진 문자열 길이부터 길이를 점차 증가시키면서 해당 길이일 때 회문이 완성되는지를 확인하면 됩니다.
- i 번째 문자와 (길이 - i - 1) 번째 문자와 같은지 계속 비교하는데 빈문자가 아닌데 다른 경우는 회문이 될 수 없기 때문에 문자열의 길이를 늘려 다시 비교합니다.
- 최종적으로 각 문자를 비교하여 모두 일치하는 경우 해당 문자열의 길이를 반환하여 문제를 해결할 수 있습니다.