# 문제 풀이

### Level 2. 무인도 여행 (9월 1일)
- 문자 'X'와 숫자 1~9 사이로 이루어진 문자열 배열이 주어진 경우 2차원 배열에서 숫자인 경우 상하좌우로 이동이 가능하다고 할 때 한번에 이동가능한 위치의 숫자 합의 목록을 반환하는 문제입니다.
- 이 문제는 DFS 방식으로 풀이를 하였습니다. 먼저 주어진 문자열을 2차원 배열로 생성하고 해당 위치를 지나갔는지 여부를 확인할 수 있는 visited 배열도 생성합니다.
- 이후 전체 위치를 이중 for 문을 통해 이동하면서 해당 위치로 이동이 가능하고(X가 아닌 경우) 아직 방문하지 않은 경우에 해당 위치로 이동한 뒤 stack 에 위치 정보를 저장합니다.
- 현재 위치의 값을 sum 에 더하고 더 이상 이동할 위치가 없을 때까지 현재 위치에서 상하좌우로 이동할 위치를 확인한 뒤 이동이 가능한 경우는 위치 정보를 stack 에 저장하고 visited 를 true 로 변경합니다.
- 이렇게 한번에 이동 가능한 모든 위치를 확인한 뒤 지금까지 더한 각 위치 값의 합인 sum을 정답 목록에 저장합니다.
- 최종적으로 정답 목록을 오름차순으로 정렬하여 반환하면 문제를 해결할 수 있습니다.

### Level 2. 줄 서는 방법
- n 명의 사람을 순서대로 세울 수 있는 방법 중 k 번째에 해당하는 경우 순서를 반환하는 문제입니다.
- 이 문제는 순열을 직접 만드는 방식으로는 효율성 테스트를 통과할 수 없었고 팩토리얼과 관련이 있다는 것을 알고 해결할 수 있었습니다.
- 배열 [1, 2, 3, 4] 가 주어졌을 때 나올 수 있는 경우의 수는 모두 4! = 24개 입니다. 이때 각 앞자리가 정해지는 경우는 24를 4로 나눈 6이 됩니다. 즉, 6번째마다 앞자리가 바뀌는 것입니다.
- 다른 말로 하자면 1부터 6까지는 시작이 1, 7부터 12까지는 시작이 2, 13부터 18까지는 시작이 3, 19부터 24까지는 시작이 4인 것입니다. 하지만 인덱스는 0부터 시작이고 순서의 끝 숫자를 나눴을 때 몫이 증가하기 때문에 k 를 k - 1로 변환하여 (k - 1) / 6 로 하게 되면 원하는 대로 첫 숫자에 해당하는 인덱스를 구할 수 있습니다.
- 이때 6은 사실 3! 로 다시 말하면 현재 배열의 길이보다 하나 작은 팩토리얼만큼 나누어 떨어진다는 것을 의미합니다.
- 이런 방식으로 n자리부터 1자리까지 반복하면 문제를 해결할 수 있습니다.
- [1, 2, 3, 4] 와 k = 6 이 주어졌을 때, 처음 자리수를 살펴보면 [1, 2, 3, 4] > [1, 2, 4, 3] > [1, 3, 2, 4] > [1, 3, 4, 2] > [1, 4, 2, 3] > [1, 4, 3, 2] 와 같이 되어 1이어야 합니다. 따라서 자리 수를 구할 때는 (k - 1) / factorial[n - 1]을 통해 5 / 6을 해야 합니다.
- 그리고 나서 남은 것들 중에 몇번째인지 구하기 위해 나머지 값을 다시 remain 에 대입합니다.
- 이렇게 남겨지는 숫자가 1개가 될 때까지 반복한 뒤 마지막 값을 제일 끝에 저장 후 반환하면 문제를 해결할 수 있습니다.

### Level 2. 호텔 대실
- 호텔 예약 시작과 종료 시간이 문자열 배열로 주어졌을 때 겹치지 않고 사용할 수 있는 방의 최소 개수를 구하는 문제입니다.
- 이 문제는 시간을 분으로 변환하여 숫자로 표현하였고 시작부터 종료에 해당하는 인덱스의 값을 1씩 증가시켰습니다.
- 최종적으로 가장 큰 수가 겹치는 방의 개수이기 때문에 이를 반환하여 문제를 해결하였습니다.
- 방을 이용한 경우 추가 10분이 청소시간으로 추가되는 점을 고려하여야 합니다.

### Level 2. 마법의 엘리베이터
- 현재 층이 주어지면 0층까지가는데 누른 버튼의 수가 가장 적은 경우를 반환하는 문제입니다. 버튼은 10의 제곱수로 이동이 가능합니다.
- 각 수를 확인하여 0부터 4까지의 경우 아래로 빼는 것이 효율적이고 6부터 9까지는 위로 올리는 것이 효율적입니다.
- 5인 경우에는 그 앞의 위치가 5 미만일 때는 아래로 빼는 것이 좋고 5 이상은 위로 올리는 것이 효율적입니다.
- 예를 들어 15층이 현재 위치라면 15, 14, 13, 12, 11, 10, 0 으로 6번만에 0층으로 이동할 수 있고
- 75층이 현재 위치라면 75, 76, 77, 78, 79, 80, 90, 100, 0으로 8번만에 0층으로 이동할 수 있습니다.
- 따라서 현 위치를 10으로 나눠 나눈 나머지가 5 초과인 경우 10에서 뺀 값을 추가하고 5 이하인 경우 나머지 값을 그대로 더합니다.
- 그러고 나서 원래 층을 10으로 나눈 몫을 원래 층의 값에 넣어주는데 나머지가 5 초과 또는 5인데 그 앞의 값을 10으로 나눈 값이 5 이상일 때는 위로 이동한 경우라고 생각하고 원래 층에 1을 더해 줍니다.
- 위 과정들을 반복해서 현재 층이 0이 될 때까지 더한 값을 반환하여 문제를 해결할 수 있습니다.

### Level 2. 숫자 카드 나누기
- 두 숫자 배열이 주어지는 경우 A 배열을 모두 나눌 수 있지만 B 배열은 모두 나눌 수 없는 또는 A 배열은 모두 나눌 수 없지만 B 배열은 모두 나눌 수 있는 최대 수를 구하는 문제입니다.
- 이 문제는 먼저 각 배열의 최대 공약수를 구한 다음
- A 배열을 B 배열의 최대 공약수로 나눠 모두 0 이 되지 않거나 B 배열을 A 배열의 최대 공약수로 나눠 모두 0 이 되지 않는 경우 두 공약수의 최대값을 반환하고 그 외는 0을 반환하도록 함으로써 해결할 수 있습니다.

### Level 2. 시소 짝꿍
- 몸무게가 주어지는 경우 2, 3, 4배를 하여 위치를 이동하는 경우 평행을 이루게 하는 짝의 개수는 몇 개인지 구하는 문제입니다.
- 무게를 비교하는 경우는 총 4가지가 있습니다.
	+ 자기 자신과 무게가 같은 경우 (1 : 1)
	+ 본인의 2배와 상대의 3배가 같은 경우 (2 : 3)
	+ 본인의 2배와 상대의 4배가 같은 경우 (2 : 4)
	+ 본인의 3배와 상대의 4배가 같은 경우 (3 : 4)
- 따라서 현재 무게가 n 인 경우에 나올 수 있는 무게는 n, n * 3 / 2, n * 4 / 2 (= n * 2), n * 4 / 3 입니다.
- 이렇게 나온 무게를 Map의 키로 하고 해당 무게가 몇번이나 나오는지를 value로 저장합니다.
- 주어진 각 무게를 확인하면서 해당 무게가 이미 나온 경우 이전에 나온 무게의 수만큼 경우의 수를 더 만들 수 있기 때문에 해당 값을 answer에 추가해주면 됩니다.
- 이후 위 과정들을 전체 무게를 모두 순회하면서 확인하면 문제를 해결할 수 있습니다.

### Level 2. 이모티콘 할인 행사
- 이모티콘 할인율에 따라 이모티콘을 구매할 때 멤버십 가입을 가장 많이 하는 경우를 구하는 문제입니다.
- 먼저 이모티콘별 할인율 경우의 수를 모두 구합니다. 예시로 이모티콘이 2개인 경우 총 16개의 경우가 나옵니다.
- 이후 각 이모티콘 할인율이 적용되었을 때 구매할 수 있는 경우를 확인하고 구매할 때 구매 가능 금액보다 많은 경우에는 멤버십 가입자 수를 증가시킵니다.
- 이렇게 할인율별 전체 사용자의 구매 현황을 확인하고 기존 응답값과 비교하여 멤버십 가입자수가 더 크거나 멤버십 가입자수가 같고 판매 비용이 많은 경우를 최종 응답으로 반환하면 문제를 해결할 수 있습니다.

### Level 2. 택배 배달과 수거하기
- 트럭의 크기와 배달해야할 택배 수, 수거해야할 택배 수가 집마다 주어질 때 최단 거리로 모든 택배를 배달하고 수거할 때의 거리를 구하는 문제입니다.
- 특정 집에 방문해야 하는 횟수는 (상자의 수 - 1) / cap + 1 입니다. 즉, cap 이 4일 때 상자의 수가 4개 이하일 때는 1번만 방문해도 되지만 5개라면 2번 방문해야 합니다.
- 또한 멀리 있는 집을 방문할 때 트럭에 공간이 있다면 이전 집의 택배들도 한번에 배달 및 수거할 수 있습니다.
- 따라서 먼저 배달 가능한 상자의 수와 수거 가능한 상자의 수를 변수로 선언하고
- 각 집을 뒤에서부터 방문하면서 해당 집에 배달할 택배 또는 수거할 택배가 있는 경우 다음 로직을 반복합니다.
- 배달 가능한 상자의 수와 수거 가능한 상자의 수에서 현재 위치의 상자들을 빼줍니다.
- 만약 배달 가능한 상자의 수와 수거 가능한 상자의 수가 음수가 되는 경우 해당 위치를 방문해야 합니다. (더 멀리 있는 집을 갈 때 수거할 수 있는 수를 초과했기 때문)
- 이때 배달 가능한 상자의 수와 수거 가능한 상자의 수를 기반으로 해당 위치를 몇번 방문해야 하는지 확인하고
- 방문 횟수 * 거리 * 2(왕복)를 이동 거리에 추가해줍니다.
- 이후 해당 위치를 방문하는데 가져갈 수 있는 상자의 수를 배달 가능한 상자의 수, 수거 가능한 상자의 수에 추가해주고 위 과정을 처음 집까지 반복합니다.
- 최종적으로 지금까지 합산된 이동거리를 반환하면 해결할 수 있는 문제입니다.

### Top Coder Level 1. 키위 주스
- 각 병의 용량이 주어졌을 때 키위 주스를 주어진 케이스에 따라 모두 옮긴 후 남은 각 병의 용량을 담은 배열을 반환하는 문제입니다.
- 시뮬레이션을 통해 문제를 해결할 수 있습니다.
- 모든 케이스를 확인하면서 fromId 위치의 병에 담긴 용량과 toId 위치의 병의 남은 공간 중 작은 값을 이동할 수 있는 용량이라고 하고
- fromId 위치의 병에서 이동할 수 있는 용량을 빼고 toId 위치의 병에서 이동할 수 있는 용량을 더해줍니다.
- 위 과정을 모두 반복한 뒤 결과를 반환하여 문제를 해결할 수 있습니다.

### Top Coder Level 1. 즐거운 파티
- 친구들의 첫번째, 두번째 취미가 주어졌을 때 가장 많은 친구들의 공통 취미가 있을 때 친구들의 수를 구하는 문제입니다.
- 전체 탐색을 통해 해결할 수 있으며 취미를 모두 확인하면서 해당 취미를 몇명이 좋아하는지 확인합니다.
- Map 을 만들어 취미를 키로 하고 몇명이나 좋아하는지를 value 로 한 뒤 최종적으로 value 중 최대값을 반환하여 문제를 해결할 수 있습니다.

### Top Coder Level 1. 암호
- 숫자 배열이 주어졌을 때 수를 하나 골라 1 증가 시킨 뒤 전체 수를 곱한 곱이 가장 커질 때를 곱의 최대값을 반환하는 문제입니다.
- 이 문제는 전체 수를 모두 for 문으로 돌면서 확인할 수 있지만 가장 작은 수를 찾아 1을 더해 문제를 해결할 수 있습니다.

### Top Coder Level 2. 재미있는 수학
- 몇진수인지 주어졌을 때 n의 배수의 각자리의 수의 합이 n의 배수가 되는 수를 구하는 문제입니다.
- 4자리 미만으로 제한이 있기 때문에 전체 탐색을 통해 해결해도 되지만 수학적인 식을 통해 문제를 더 빠르게 해결할 수 있습니다.
- ```a x n x n + b x n + c``` 는 ```a x (n - 1) x (n - 1) + (b - 2a) x (n - 1) + (a + b + c)``` -> ```((a x (n - 1) + b - 2a) x (n - 1)) + (a + b + c)``` 로 나타낼 수 있기 때문에
- 해당 수가 (n-1)과 그의 약수라는 것으로 문제를 해결할 수 있습니다.

### Top Coder Level 1. 회문
- 문자열이 주어질 경우 회문을 만드는 가장 짧은 길이를 반환하는 문제입니다.
- 문자열 길이를 기준으로 회문이 될 수 있는 경우를 확인하여 회문이 된다면 해당 길이를 반환하면 됩니다.
- 처음 주어진 문자열 길이부터 길이를 점차 증가시키면서 해당 길이일 때 회문이 완성되는지를 확인하면 됩니다.
- i 번째 문자와 (길이 - i - 1) 번째 문자와 같은지 계속 비교하는데 빈문자가 아닌데 다른 경우는 회문이 될 수 없기 때문에 문자열의 길이를 늘려 다시 비교합니다.
- 최종적으로 각 문자를 비교하여 모두 일치하는 경우 해당 문자열의 길이를 반환하여 문제를 해결할 수 있습니다.

### Top Coder Level 1. 친구 수
- Y와 N으로 구성된 문자열이 주어집니다. i번 문자열의 j번째 문자가 Y일 때 i와 j는 친구라는 의미입니다. 또한 k라는 친구가 i, j 와 모두 친구라면 i와 j도 친구입니다. 이때, 가장 많은 친구의 수를 구하는 문제입니다.
- 이 문제는 모든 사람을 확인하면서
- i가 j와 친구인 경우와 j와 k가 친구이고 k와 i가 친구인 경우를 찾아 값을 증가시키면 됩니다.
- 최종적으로 기존의 값과 위 경우를 확인한 값 중 최대값을 찾아 반환하면 문제를 해결할 수 있습니다.

### Top Coder Level 2. 고장난 로봇
- 움직일 수 있는 횟수와 각 방향으로 이동할 확률이 주어졌을 때 한번 이동한 지점을 방문하지 않고 움직일 수 있는 횟수만큼 정상적으로 이동한 모든 경우의 성공확률을 구하는 문제입니다.
- 이 문제는 dfs 를 사용하여 해결하였습니다.
- 성공할 수 있는 경우 끝까지 탐색한 뒤 최종적으로 끝까지 간 값들을 더하면 정답을 구할 수 있습니다.
- 따라서 위, 오른쪽, 아래, 왼쪽 순으로 이동하면서 이동에 성공한 확률 * 방향 확률을 계속 더해줍니다.
- 이동에 성공한 확률은 이미 방문한 위치를 방문할 때는 0, 마지막 노드에 도달한 경우는 1입니다.
- 이렇게 더해진 값을 반환하는 방식으로 문제를 해결할 수 있습니다.

### Top Coder Level 2. 미로 만드는 사람
- 미로에 대한 문자열과 시작 위치 이동할 수 있는 위치가 주어졌을 때 가장 먼 출구까지 나오는 가장 빠른 경로를 찾는 문제입니다.
- 이 문제는 bfs 를 사용하여 해결하였습니다.
- 시작 위치로부터 각 위치로 이동한다고 했을 때 해당 위치를 몇번 이동 후 방문하는지를 배열로 저장합니다.
- 이후 최종적으로 바깥쪽 출구가 될 수 있는 위치 중 한번도 방문하지 않았다면 탈출하지 못한 것으로 -1을 반환하고 그렇지 않은 경우에는 가장 오래 걸린 경우를 찾아 반환하면 문제를 해결할 수 있습니다.

### Top Coder Level 1. 마법의 숫자
- Y, N으로 구성된 대답이 제공되었을 때 16 이하의 숫자 중 처음 생각한 숫자를 반환하는 문제입니다.
- 이는 비트 연산으로 생각하여 문제를 해결할 수 있습니다.
- 각 숫자가 나오는 경우를 Y, N으로 표현한 배열을 만든 뒤 주어진 answer와 동일한 경우 해당 숫자를 반환하는 방식으로 문제를 해결할 수 있습니다.

### Top Coder Level 2. 회사 조직과 급여
- 누가 누구의 상사인지 문자열로 주어질 때 직원들의 총 급여를 구하는 문제입니다.
- 부하 직원이 없는 경우 급여는 1이고 부하 직원이 있는 경우는 부하 직원의 급여를 합한 값이 본인의 급여가 됩니다.
- 이 문제는 dp 방식으로 해결할 수 있습니다.
- 자신의 급여를 계산하였는지 담은 배열을 하나 만듭니다.
- 자신의 급여를 계산하지 않았다면(배열의 값이 0이라면) 자신과 연관된 관계를 모두 확인하며 부하 직원이 있는 경우 부하 직원의 급여를 재귀함수로 구해 더해줍니다.
- 부하 직원이 없는 경우 합의 결과가 0이므로 1을 반환하고 부하 직원이 있는 경우 구해진 급여를 자신의 급여에 저장한 뒤 반환합니다.
- 이런 방식을 통해 최종적으로 반환된 급여를 모두 합한 값을 반환하여 문제를 해결할 수 있습니다.

### Top Coder Level 2. 나쁜 이웃집 사람들
- 기부할 수 있는 금액이 주어진 경우 기부금의 최대값을 구하는 문제입니다. 이때 한 집이 기부를 하면 양옆 두 집은 기부를 하지 않습니다.
- 이 문제는 사이클이 있지만 직선으로 생각하고 문제를 풀면 쉽게 해결할 수 있습니다.
- 0번 집부터 기부를 한다고 하면 맨 마지막 집을 제외하고 확인하고 1번 집부터 기부를 한다고 하면 맨 마지막 집을 포함하여 확인하면 됩니다.
- 해당 집의 기부금을 먼저 저장하고 전전 집까지의 기부금과 지금 기부금을 합친 것과 비교하여 더 큰 값을 현재 집의 기부금에 다시 저장합니다.
- 그리고 나서 이전의 최대 기부금과 비교하여 더 큰 기부금을 최대 기부금으로 저장한 뒤 최종적으로 반환하여 문제를 해결할 수 있습니다.

### Top Coder Level 2. 킹 나이트 체스
- 시작 위치와 종료 위치가 주어졌을 때 주어지는 이동 횟수만에 이동할 수 있는 경우의 수를 구하는 문제입니다.
- 해당 위치를 이동하는데 걸린 횟수를 기준으로 저장하게 됩니다.
- 전체 횟수 동안 반복하면서 모든 위치에 대해 이동할 수 있는 위치를 확인하고 해당 위치로 이동할 수 있는 경우의 수는 이전 위치까지 이동한 경우의 수를 더해주는 방식으로 문제를 해결할 수 있습니다.

### Top Coder Level 2. 악수
- 원형으로 서있는 사람의 수가 주어졌을 때 교차하지 않고 악수할 수 있는 방법의 수를 구하는 문제입니다.
- 악수를 하기 위한 사람의 수는 짝수로 주어집니다.
- 이 문제는 패턴을 찾아 해결할 수 있습니다.
	+ c1: 사람이 2명인 경우는 1번
	+ c2: 사람이 4명인 경우는 c1 + c1 = 2번
	+ c3: 사람이 6명인 경우는 c2 + (c1 * c1) + c2 = 5번
	+ c4: 사람이 8명인 경우는 c3 + (c2 * c1) + (c1 * c2) + c3 = 14번
- 따라서 사람이 n명일 때 악수하는 경우의 수는 n/2 이므로 n/2 + 1 크기의 배열을 생성하고
- i 번째 악수하는 경우의 수는 반복을 하면서 위 수식의 값을 모두 더해 구할 수 있습니다.
- 최종적으로 배열의 n/2 번째 (마지막) 값을 반환하여 문제를 해결할 수 있습니다.

### Top Coder level 1. 다양한 색상의 상자와 공
- 빨간 상자와 공, 파란 상자와 공이 주어지는 경우 어떤 색 상자에 어떤 색 공을 넣었을 때 가장 점수가 높은지를 구하는 문제입니다.
- 이 문제는 총 적은 공과 상자의 수에 맞춰 반복하면서 하나씩 공을 바꾸는 방식으로 해결할 수 있습니다.
- i개의 공을 바꾸는 경우 ```(numRed - i) * onlyRed + (numBlue - i) * onlyBlue + (2 * i * bothColors)```와 같은 식을 세울 수 있습니다.
- 각 단계마다 구한 결과와 이전 결과를 비교하여 더 큰 값을 찾고 최종적으로 가장 큰 값을 반환하는 방식으로 문제를 해결할 수 있습니다.

### Top Coder level 3. 주식 투자 시뮬레이션
- 매월 초 각 주식의 가격이 문자열로 주어질 때 주어진 기간동안 가장 큰 수익을 낼 때 수익을 반환하는 문제입니다.
- 탐욕 알고리즘을 통해 현재 시점보다 뒤에 더 투자율이 높다면 투자를 미루는 방식으로 문제를 해결할 수 있습니다.
- 이 문제는 뒤에서부터 확인하면서 최대 투자율을 넘는 경우에 해당 월의 주식을 살지말지 저장하고 해당 월의 투자율도 저장한 뒤
- 다시 처음부터 반복하면서 해당 월에 주식을 산다고 한 경우 지금까지 모인 투자금 전체와 투자율을 곱해 이익을 계산합니다.
- 최종적으로 이익을 반환하는데 이때 소수점을 제거하고 반환하면 문제를 해결할 수 있습니다.

### Top Coder level 3. 배치 시스템
- 일을 수행하는데 걸리는 시간과 일을 수행하는 사람의 목록이 주어질 때 평균 대기 시간이 가장 짧은 경우 일의 순서를 반환하는 문제입니다.
- 이 문제는 일이 짧게 끝나는 순서대로 먼저 일을 처리하도록 하면 됩니다.
- 따라서 먼저 사람별 업무 총 시간을 Map으로 저장합니다.
- 이후 일의 개수만큼 반복하면서 현재 가장 짧은 소요시간을 가지는 사람의 이름을 찾고
- 해당 사람의 업무를 다시 찾아 인덱스를 저장합니다.
- 최종적으로 재정렬된 배열을 반환하여 문제를 해결할 수 있습니다.

### Top Coder level 2. 자동차 대출
- 초기 차량의 값과 매달 지불해야하는 금액, 지불해야하는 기간이 주어질 때 연 이자율을 구하는 문제입니다.
- 이 문제는 이분 탐색을 통해 해결할 수 있습니다.
- 연 이자율이 100% 일 때 지불 기간 내 모두 지불이 가능한지 확인하고 모두 지불하지 못한 경우 이자율을 절반으로 줄입니다.
- 반대로 총 지불 금액이 음수인 경우는 이자율을 2배로 증가시킵니다.
- 이렇게 high, low, mid 변수를 이용해 적정 이자율을 찾아 오차 범위 내에 포함된다면 mid 값을 반환하는 방식으로 문제를 해결할 수 있습니다.

### Top Coder level 2. 둥근 모양의 국가들
- 국가의 중심 좌표 x, y와 반경 r이 배열로 주어질 때 (x1, y1)에서 (x2, y2) 가는데 지나쳐야 하는 국가의 경계의 최소값을 구하는 문제입니다.
- 만약 (x1, y1)과 (x2, y2)가 같은 원 안에 있거나 둘다 같은 원 밖에 있는 경우에는 경계를 지나지 않습니다.
- 즉, (x1, y1)과 (x2, y2) 중 하나만 원 안에 있을 때 경계를 지나야 합니다.
- 따라서 모든 원을 확인하면서 두 점 중 하나만 원 안에 있는 경우 값을 증가시키고 최종적으로 이렇게 더해진 값을 반환하여 문제를 해결할 수 있습니다.

### Top Coder level 3. 해밀턴 패스
- 각 도시가 반드시 지나야 하는 길을 표시한 문자열 배열이 주어질 때 모든 도시를 지나는 방법의 수를 구하는 문제입니다. (한번 지난 도시는 다시 지날 수 없습니다.)
- 이 문제는 지날 수 있는 경우와 없는 경우를 나누어 생각하면 좋습니다.
- 먼저 지날 수 없는 경우는 한 도시에 반드시 지나야 하는 길이 3개 이상인 경우입니다. 반드시 지나야 하는 길이 3개 이상인 경우 한번 지난 도시를 다시 지나야 하기 때문에 이 경우 바로 0으로 리턴합니다.
- 위에서 각 도시별로 반드시 지나야 하는 길의 수를 확인했다면 다음으로 각 도시별로 독립된 도시인지 연결된 도시인지 확인합니다.
- 독립된 도시라면 free 수를 증가시키고 해당 도시를 방문한 것으로 처리합니다.
- 독립된 도시가 아니라면 시작점을 찾기 위해 반드시 지나야 하는 길이 1개이고 지나지 않은 도시를 찾아 연결된 도시를 모두 방문 처리 해줍니다.
- 이후 방문하지 않은 도시가 하나라도 있다면 바로 0을 리턴하고
- 각 그룹의 순서를 정하는 개수를 answer 에 추가합니다. 즉, ABC 세 그룹으로 나뉜 경우 ABC, ACB, BAC, BCA, CAB, CBA 이렇게 총 6개의 순서로 조합할 수 있습니다.
- 이후 각 그룹 내 시작점을 바꾸는 경우는 2가지이므로 이 또한 그룹의 개수만큼 추가해줍니다.
- 이렇게 계산된 값을 반환하여 문제를 해결할 수 있습니다.

### Top Coder level 3. 바이너리 플립
- 0의 개수와 1의 개수, 한번에 뒤집을 수 있는 카드의 개수가 주어졌을 때 모두 1로 만들 수 있는 최소 뒤집는 수를 구하는 문제입니다.
- 한 턴에 0의 카드를 몇장씩 뒤집는지를 최소, 최대 범위로 잡고
- 이를 사용하여 0의 개수의 최대값과 최소값을 매 번 갱신해서 0의 개수가 최소가 될 때까지 반복하면 최소 턴을 구할 수 있습니다.
- 수학적인 공식을 통해서도 문제를 해결할 수 있습니다.
  + i 번째 턴에서 모든 카드를 1로 만들 수 있다고 가정하면 카드를 뒤집는 횟수는 ```i * K```
  + 또한 원래 0이었던 것이 A장 있으므로 A장은 반드시 뒤집어야 합니다. 나머지를 뒤집는 횟수를 rest라고 하면 ```rest = i * K - A```
  + 0의 카드는 반드시 최초 한번 뒤집어야 하고 1의 카드는 처음부터 이유없이 뒤집을 수 있는데 이유 없이 뒤집는 횟수를 use라고 하면 ```use = ((i/2) * B + ((i - 1)/2) * A) * 2```
  + 지금까지 계산한 rest와 use를 이용하면 다음과 같은 조건을 얻을 수 있습니다.
    - A장 이상 뒤집을 수 있어야 합니다. (rest >= 0)
    - 뒤집는 수의 홀수 짝수가 일치해야 합니다. (rest % 2 == 0)
    - 이유 없이 뒤집을 수 있는 조작이 충분해야 합니다. (rest <= use)
  + 위 조건이 충족되는 i번쩨 턴을 찾아 반환하여 문제를 해결할 수 있습니다.

  ### Top Coder level 2. 칸토어 먼지
  - 문자열 패턴이 주어졌을 때, 프랙탈 내에 같은 패턴이 존재하는 개수를 구하는 문제입니다.
  - 먼저 프랙탈은 재귀 함수를 통해 구할 수 있습니다. 이중 배열로 만들 필요 없이 하나의 배열로 만들고 ```fractal[x] && fractal[y]``` 인 경우만 X로 되어 있다고 생각하면 됩니다.
  - 이렇게 구한 fractal을 바탕으로 시작점을 옮겨가면서 fractal 안에 해당 패턴이 몇번 반복되는지를 구하면 문제를 해결할 수 있습니다.

  ### Top Coder level 2. Not Two
  - width, height가 주어진 경우 유클리드 거리가 2 미만인 경우에 돌을 놓아 최대 몇개까지 놓을 수 있는지 구하는 문제입니다.
  - 이 문제는 앞에서부터 순서대로 당장 놓을 수 있는 위치에 돌을 추가하면 가장 많이 돌을 놓을 수 있게 됩니다.
  - 또한 2개 떨어진 칸에만 영향을 받는다는 규칙을 찾으면 ```(칸의 개수 + 1) / 2``` 수로 판에 놓을 수 있는 돌의 개수를 구할 수 있는 수식을 만들 수 있습니다.

  ### Top Coder level 3. Cut Stick
  - int 형 막대기 목록과 자르는 횟수(C)가 주어졌을 때 K 번째 막대의 최댓값을 구하는 문제입니다.
  - 이 문제를 조금 다르게 생각하면 이분 탐색으로 해결할 수 있습니다.
  - K 번째 막대의 최댓값은 길이가 A 이상인 막대가 K개 이상 있다는 말과 같고 이때의 A를 찾으면 해결되는 문제입니다.
  - 만약 ```{200, 160, 100, 80, 60, 20, 10}``` 이라는 막대가 주어졌을 때, 40 보다 큰 막대를 만드는 방법은
  - 200 / 40 = 5개, 160 / 40 = 4개, 100 / 40 = 2개, 80 / 40 = 2개, 60 / 40 = 1개 만들 수 있고
  - 자른 횟수는 (만들 수 있는 막대 수 - 1)이므로 전체 절단 횟수는 4 + 3 + 1 + 1 = 9 이고
  - 절단 가능 횟수가 8회로 제한되어 있었다면 만들 수 있는 막대의 수는 5 + 4 + 2 + 2 + 1 - (9 - 8) = 13 입니다.
  - 따라서 K 번째가 13 보다 크다면 답은 40보다 작고 13 이하인 경우는 40보다 크기 때문에 나누는 수인 40을 조절하면서 찾으면 해결할 수 있습니다.
  