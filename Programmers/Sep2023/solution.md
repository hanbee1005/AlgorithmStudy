# 문제 풀이

### Level 2. 무인도 여행 (9월 1일)
- 문자 'X'와 숫자 1~9 사이로 이루어진 문자열 배열이 주어진 경우 2차원 배열에서 숫자인 경우 상하좌우로 이동이 가능하다고 할 때 한번에 이동가능한 위치의 숫자 합의 목록을 반환하는 문제입니다.
- 이 문제는 DFS 방식으로 풀이를 하였습니다. 먼저 주어진 문자열을 2차원 배열로 생성하고 해당 위치를 지나갔는지 여부를 확인할 수 있는 visited 배열도 생성합니다.
- 이후 전체 위치를 이중 for 문을 통해 이동하면서 해당 위치로 이동이 가능하고(X가 아닌 경우) 아직 방문하지 않은 경우에 해당 위치로 이동한 뒤 stack 에 위치 정보를 저장합니다.
- 현재 위치의 값을 sum 에 더하고 더 이상 이동할 위치가 없을 때까지 현재 위치에서 상하좌우로 이동할 위치를 확인한 뒤 이동이 가능한 경우는 위치 정보를 stack 에 저장하고 visited 를 true 로 변경합니다.
- 이렇게 한번에 이동 가능한 모든 위치를 확인한 뒤 지금까지 더한 각 위치 값의 합인 sum을 정답 목록에 저장합니다.
- 최종적으로 정답 목록을 오름차순으로 정렬하여 반환하면 문제를 해결할 수 있습니다.

### Level 2. 줄 서는 방법
- n 명의 사람을 순서대로 세울 수 있는 방법 중 k 번째에 해당하는 경우 순서를 반환하는 문제입니다.
- 이 문제는 순열을 직접 만드는 방식으로는 효율성 테스트를 통과할 수 없었고 팩토리얼과 관련이 있다는 것을 알고 해결할 수 있었습니다.
- 배열 [1, 2, 3, 4] 가 주어졌을 때 나올 수 있는 경우의 수는 모두 4! = 24개 입니다. 이때 각 앞자리가 정해지는 경우는 24를 4로 나눈 6이 됩니다. 즉, 6번째마다 앞자리가 바뀌는 것입니다.
- 다른 말로 하자면 1부터 6까지는 시작이 1, 7부터 12까지는 시작이 2, 13부터 18까지는 시작이 3, 19부터 24까지는 시작이 4인 것입니다. 하지만 인덱스는 0부터 시작이고 순서의 끝 숫자를 나눴을 때 몫이 증가하기 때문에 k 를 k - 1로 변환하여 (k - 1) / 6 로 하게 되면 원하는 대로 첫 숫자에 해당하는 인덱스를 구할 수 있습니다.
- 이때 6은 사실 3! 로 다시 말하면 현재 배열의 길이보다 하나 작은 팩토리얼만큼 나누어 떨어진다는 것을 의미합니다.
- 이런 방식으로 n자리부터 1자리까지 반복하면 문제를 해결할 수 있습니다.
- [1, 2, 3, 4] 와 k = 6 이 주어졌을 때, 처음 자리수를 살펴보면 [1, 2, 3, 4] > [1, 2, 4, 3] > [1, 3, 2, 4] > [1, 3, 4, 2] > [1, 4, 2, 3] > [1, 4, 3, 2] 와 같이 되어 1이어야 합니다. 따라서 자리 수를 구할 때는 (k - 1) / factorial[n - 1]을 통해 5 / 6을 해야 합니다.
- 그리고 나서 남은 것들 중에 몇번째인지 구하기 위해 나머지 값을 다시 remain 에 대입합니다.
- 이렇게 남겨지는 숫자가 1개가 될 때까지 반복한 뒤 마지막 값을 제일 끝에 저장 후 반환하면 문제를 해결할 수 있습니다.

### Level 2. 호텔 대실
- 호텔 예약 시작과 종료 시간이 문자열 배열로 주어졌을 때 겹치지 않고 사용할 수 있는 방의 최소 개수를 구하는 문제입니다.
- 이 문제는 시간을 분으로 변환하여 숫자로 표현하였고 시작부터 종료에 해당하는 인덱스의 값을 1씩 증가시켰습니다.
- 최종적으로 가장 큰 수가 겹치는 방의 개수이기 때문에 이를 반환하여 문제를 해결하였습니다.
- 방을 이용한 경우 추가 10분이 청소시간으로 추가되는 점을 고려하여야 합니다.

### Level 2. 마법의 엘리베이터
- 현재 층이 주어지면 0층까지가는데 누른 버튼의 수가 가장 적은 경우를 반환하는 문제입니다. 버튼은 10의 제곱수로 이동이 가능합니다.
- 각 수를 확인하여 0부터 4까지의 경우 아래로 빼는 것이 효율적이고 6부터 9까지는 위로 올리는 것이 효율적입니다.
- 5인 경우에는 그 앞의 위치가 5 미만일 때는 아래로 빼는 것이 좋고 5 이상은 위로 올리는 것이 효율적입니다.
- 예를 들어 15층이 현재 위치라면 15, 14, 13, 12, 11, 10, 0 으로 6번만에 0층으로 이동할 수 있고
- 75층이 현재 위치라면 75, 76, 77, 78, 79, 80, 90, 100, 0으로 8번만에 0층으로 이동할 수 있습니다.
- 따라서 현 위치를 10으로 나눠 나눈 나머지가 5 초과인 경우 10에서 뺀 값을 추가하고 5 이하인 경우 나머지 값을 그대로 더합니다.
- 그러고 나서 원래 층을 10으로 나눈 몫을 원래 층의 값에 넣어주는데 나머지가 5 초과 또는 5인데 그 앞의 값을 10으로 나눈 값이 5 이상일 때는 위로 이동한 경우라고 생각하고 원래 층에 1을 더해 줍니다.
- 위 과정들을 반복해서 현재 층이 0이 될 때까지 더한 값을 반환하여 문제를 해결할 수 있습니다.

### Level 2. 숫자 카드 나누기
- 두 숫자 배열이 주어지는 경우 A 배열을 모두 나눌 수 있지만 B 배열은 모두 나눌 수 없는 또는 A 배열은 모두 나눌 수 없지만 B 배열은 모두 나눌 수 있는 최대 수를 구하는 문제입니다.
- 이 문제는 먼저 각 배열의 최대 공약수를 구한 다음
- A 배열을 B 배열의 최대 공약수로 나눠 모두 0 이 되지 않거나 B 배열을 A 배열의 최대 공약수로 나눠 모두 0 이 되지 않는 경우 두 공약수의 최대값을 반환하고 그 외는 0을 반환하도록 함으로써 해결할 수 있습니다.