# 문제 풀이

### Level 2. 멀리 뛰기 (8월 22일)
- 이동할 수 있는 칸 n이 주어질 때 1칸 또는 2칸씩 이동할 수 있는 방법의 수를 구하는 문제입니다.
- n 칸을 이동하는 것은 (n - 1)번째 칸을 이동한 뒤 1칸을 더 이동하는 것과 (n - 2)번째 칸을 이동한 뒤 2칸을 한번에 더 이동하는 방법이 있습니다.
- 예를 들어 설명하면 5칸을 이동하는 방법의 수는 네 칸까지 이동한 뒤 1칸을 더 이동하는 방법과 세 칸까지 이동한 뒤 2칸을 더 이동하는 방법이 있습니다.
- 따라서 n 칸을 이동하는 방법의 수는 (n - 1)번째 칸을 이동하는 방법과 (n - 2)번째 칸을 이동하는 방법의 수를 더해서 구할 수 있습니다.
- 재귀를 이용하는 방법도 있겠지만 이미 앞에서 계산된 값을 다음에도 계속 사용할 수 있기 때문에 크기가 n인 배열을 두어 각 칸을 이동할 수 있는 방법의 수를 구한 뒤 최종적으로 가장 마지막 n번째 배열에 저장된 값을 반환하는 방식으로 해결이 가능합니다.

### Level 2. 귤 고르기 (8월 23일)
- 고를 수 있는 귤의 수 k가 주어지고 크기별 귤 목록이 주어질 때 서로 다른 종류의 수의 최소값을 구하는 문제입니다.
- 이는 가장 많은 수의 크기를 가진 귤을 고르는 것과 같습니다.
- 즉, 6개의 귤을 고른다고 할 때 [1, 3, 2, 5, 4, 5, 2, 3] 귤이 주어진다면 1, 4 를 제외한 2, 3, 5 크기의 귤 2개씩을 골라 총 6개를 고르는 것이 서로 다른 종류 3가지를 구하는 방법입니다.
- 따라서 먼저 key가 크기이고 value가 해당 크기 귤의 개수인 Map을 생성하여 주어진 배열을 하나씩 확인하면서 크기별 개수를 구하고
- 해당 맵을 값을 기준으로 내림차순 정렬한 뒤, 값만 가지는 List로 변경하였습니다.
- 그리고 해당 List를 순회하면서 k개를 모두 고른 경우 반복을 끝내고 이때까지 반복된 횟수를 반환하면 해결할 수 있습니다.

### Level 2. 연속 부분 수열 합의 개수
- 연속 부분 수열 합의 개수를 구하는 문제로 예를 들어 [7, 9, 1, 1, 4] 라는 배열이 주어졌을 때 길이가 1인 수열로 보면 [7, 9, 1, 1, 4], 길이가 2인 수열로 보면 [[7, 9], [9, 1],[1, 1], [1, 4], [4, 7]], 길이가 3인 수열로 보면 [[7, 9, 1], [9, 1, 1], [1, 1, 4], [1, 4, 7], [4, 7, 9]] 라고 볼 수 있고 길이가 처음 주어진 배열의 길이와 같을 때까지 부분 수열을 구할 수 있습니다.
- 따라서 이전에 포함되었던 배열 숫자에 길이만큼 떨어진 숫자까지 추가하여 새로운 부분 수열을 구할 수 있는 것입니다.
- 또한, 최종적으로 합의 개수를 구하는 문제이기 때문에 앞 부분 수열에 포함된 숫자들의 합에 현재 길이에 해당하는 위치의 수를 더하면 해당 부분 수열의 합을 구할 수 있습니다.
- 기존에 부분 수열 합을 다음에도 다시 이용할 수 있기 때문에 배열을 사용하였습니다.
- 인덱스에 해당하는 숫자를 시작으로 하는 부분 수열의 합을 계속 추가하면서 해당 합을 Set에 넣어 최종적으로 Set의 길이를 반환하도록 하여 해결하였습니다.

### Level 2. 할인 행사
- 할인 행사를 하는 물품 목록과 사고 싶은 물품의 목록 및 개수를 담은 배열이 주어졌을 때 연속된 10일 동안 사고 싶은 물품을 모두 산다면 언제부터 사는게 좋을지를 구하는 문제입니다.
- 먼저 사고 싶은 물품의 이름을 key로 그 수를 value로 하는 맵을 생성합니다.
- 그리고 처음 10일 동안 할인 행사하는 물품을 돌면서 사고 싶은 목록에 있다면 그 개수를 빼줍니다.
- 그리고 맵의 값들이 모두 0 이하인 경우 모두 구매를 완료한 것으로 판단하여 answer를 증가시킵니다.
- 이후 다음 할인 물품도 구매를 하는데 먼저 하나 전 상품에 대해서는 다시 1을 증가시켜 구매하지 않은 것으로 만들고 새로운 물품은 1을 감소시켜 구매했다고 가정한 뒤 위와 같이 모든 맵의 값들이 0 이하인지 확인합니다.
- 이 과정을 총 할인 상품 목록 - 10까지 반복해줍니다. 전체 구매를 하려면 남은 과일이 10개 이상이어야 하기 때문입니다.

### Level 2. 롤케이크 자르기
- 정수 배열이 주어졌을 때 해당 배열을 나눠서 두 그룹에 속한 숫자 종류의 개수가 같을 때의 개수를 구하는 문제입니다.
- 왼쪽 그룹이 될 맵과 오른쪽 그룹이 될 맵 두개를 만들고 처음 전체 배열을 읽어 오른쪽 맵에 해당 숫자를 key로 해당 숫자가 나온 횟수를 value로 하여 저장합니다.
- 이후 처음 주어진 정수 배열을 모두 순회하면서 오른쪽 맵에서 해당 숫자의 개수를 하나 빼줍니다. 이때 오른쪽 맵에 해당 숫자 개수가 0보다 작은 경우는 아예 키를 제거합니다.
- 그리고 해당 숫자를 왼쪽 맵에 저장해줍니다.
- 마지막으로 두 맵의 키 개수를 확인하여 같은 경우 두 맵의 숫자 종류가 같은 것으로 answer를 하나 증가시켜줍니다.

### Level 2. 숫자 변환하기
- 정수 x, y, n 이 주어졌을 때, x + n 또는 x * 2 또는 x * 3 연산을 계속하여 최종적으로 y 를 만들 수 있는 연산의 최소값을 구하는 문제입니다. (y 를 만들 수 없다면 -1을 반환)
- 연산의 결과가 y보다 커지는 경우는 y를 만들 수 없다고 판단하여 -1을 반환하도록 하였고 계산의 결과를 인덱스로 하는 배열을 생성하였습니다.
- 그리고 초기 값은 Integer의 최대값으로 설정하고 x 인덱스는 0으로 두었습니다.
- 이후 y까지 반복하면서 연산의 결과에 해당하는 인덱스의 값을 증가시키는데 최소 연산을 구해야 하기 때문에 해당 인덱스까지 오는데 걸린 최소값을 Math.min()을 통해 저장하도록 합니다.
- 최종적으로 인덱스 y의 값이 초기값과 다르다면 연산을 통해 해당 값을 찾은 경우이므로 인덱스 y에 저장된 값을 반환하고 초기값과 같은 경우에는 -1을 반환하면 해결할 수 있습니다.

### Level 2. 2 x n 타일링
- 가로 2, 세로 1 길이의 타일이 있을 때 가로 n, 세로 2인 직사각형을 채울 수 있는 방법의 수를 구하는 문제입니다.
- 만약 길이가 4인 직사각형을 채우기 위해서는 길이가 3인 직사각형까지 채운 뒤 마지막 타일을 길게 세워 채우는 방법 + 길이가 2인 직사각형까지 채운 뒤 마지막으로 2개의 타일을 눕혀서 위아래로 쌓아 채우는 방법의 개수와 같습니다.
- 따라서 n 길이를 채우기 위해서는 (n - 1) + (n - 2) 방법의 수를 합친 것으로 배열에 담에 문제를 해결할 수 있습니다.

