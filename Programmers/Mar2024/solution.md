# 문제 풀이

### Level 1. 가장 많이 받은 선물
- 주어진 조건에서 다음 달에 가장 많은 선물을 받을 수 있는 사람이 받게 되는 선물의 최대 수를 구하는 문제
  + A가 B에게 이번에 선물을 더 많이 준 경우 다음달에 A가 B에게 선물 1개 받음
  + A와 B가 주고 받은 선물이 없거나 같은 경우, 선물 지수가 더 높은 사람이 더 낮은 사람에게 선물 1개 받음
    - 선물 지수 = 내가 준 총 선물 개수 - 내가 받은 총 선물 개수
- 먼저 주어진 friends의 이름과 인덱스를 매칭한 Map을 구성하고
- 누가 누구에게 선물을 주었는지 이차원 배열로 저장합니다.
  + A의 인덱스가 0, B의 인덱스가 1이고 A가 B에게 선물을 주었다면 ```giftStatus[0][1] += 1``` 이 됩니다.
  + 이때 선물 지수도 같이 계산하여 별도의 1차원 배열로 저장합니다. (준사람은 플러스 ```giftIndex[0]++``` 받은 사람은 마이너스 ```giftIndex[1]--```)
- 그리고 나서 이차원 배열을 순회하면서 다음 달에 받을 선물의 개수를 별도의 1차원 배열에 저장합니다.
  + i 번째와 그 다음 순서부터 비교하면서 받을 선물의 개수를 채워갑니다.
- 이후 최종 배열에서 가장 큰 수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n^2) (n <= 50)

### Level 1. 이웃한 칸
- 칸의 색이 적힌 2차원 배열과 선택한 위치 h,w가 주어졌을 때 해당 위치와 상하좌우의 색이 같은 개수를 구하는 문제
- h, w에서 상하좌우로 이동 시 배열의 범위 안에 있는 경우 해당 위치와 h,w 칸의 색을 비교해서 같으면 answer 값을 1 증가시키고
- 최종적으로 answer 값을 반환합니다.
- 시간 복잡도: O(n) (n = 4)

### Level 1. 데이터 분석
- 배열이 주어졌을 때, ext 인덱스의 값이 val_ext 보다 작은 값들을 sort_by 인덱스의 값이 작은 순서대로 정렬한 이차원 배열을 반환하는 문제
- 먼저 각 타입에 해당하는 문자열을 인덱스와 함께 Map으로 저장합니다. {"code": 0, "date": 1, "maximum": 2, "remain": 3}
- 그런 다음, Arrays.stream()을 사용하여 filter 한 뒤, sorted 하는 방식으로 구할 수 있습니다.
- 시간 복잡도: O(nlogn) (n <= 500)

### Level 1. 삼총사
- 배열이 주어졌을 때 3개를 골라 그 합이 0이 되는 경우의 수를 구하는 문제
- 순서 상관 없이 3개를 뽑는 조합을 재귀를 통해 구현해도 되지만 크기가 크지 않기 때문에 삼중 for문으로 찾으면서 문제 해결
- 시간 복잡도: O(n^3) (n <= 13)

### Level 1. 가장 가까운 같은 글자
- 문자열이 주어졌을 때 각 위치의 문자와 동일한 문자 중 앞에 등장하면서 가장 가까이에 있는 문자의 인덱스를 담은 배열을 반환하는 문제
- 문자열을 돌면서 각 문자에서 소문자 'a'를 뺀 위치에 담긴 인덱스와 비교하는 방식으로 문제 해결
  + 초기 인덱스는 -1로 -1이 들어있다면 해당 문자와 같은 문자는 앞에 나타난 적이 없으므로 -1을 결과 배열에 저장
  + 현재 인덱스를 해당 위치에 저장
- 시간 복잡도: O(n)

### Level 1. 푸드 파이트 대회
- 배열이 주어진 경우 "0" 앞뒤로 같은 개수만큼의 인덱스를 붙여서 문자열을 반환하는 문제
  + {1, 3, 4, 6} 이 주어지는 경우 0 번 인덱스는 항상 1로 중간에 두고
  + 1번 인덱스 3, 2번 인덱스 4, 3번 인덱스 6 이므로 1223330333221 을 반환
- "0"을 기준으로 양옆을 붙여 나가기 위해 food 배열을 뒤에서부터 돌면서 food[i]/2 개수만큼 i를 "0" 앞뒤에 붙이고 결과 반환
- 시간 복잡도: O(n) (n <= 9)

### Level 1. 콜라 문제
- a개를 주면 b개를 돌려주는 가게가 있을 때 n개를 가지고 있다면 몇개를 돌려받을 수 있는지 구하는 문제
- n >= a 인 동안 반복하면서 (n / a) * b 개를 받을 수 있으므로 answer에 더하고 남은 개수는 (n % a) 와 더해 다시 반복
- 수학적으로 풀면 ```(n - b) / (a - b) * b```로 해결
- 시간 복잡도: O(1)

### Level 1. 명예의 전당 (1)
- k와 배열이 주어졌을 때, 배열을 돌면서 상위 k개의 최소값을 저장한 배열을 반환하는 문제
- 우선 순위 큐를 활용하여 score를 저장하고 큐의 크기가 k 를 넘는 경우 최소값을 제거
- 그리고 나서 큐에 담긴 가장 작은 값을 결과 배열에 저장하고 이를 반복한 뒤 결과 배열을 반환
- 시간 복잡도: O(n) (n <= 1000) / 우선 순위 큐의 요소 추가 연산 시간 복잡도: O(nlogn) - 최소 힙 사용

### Level 1. 카드 뭉치
- card1, card2, 원하는 문자열 배열이 주어졌을 때 card1, card2의 순서를 지키면서 원하는 문자열을 만들 수 있는지 구하는 문제
- 원하는 문자열의 배열을 돌면서 card1의 문자열과 같은지 비교하고 같으면 card1의 index를 하나 증가
- 다르면 card2도 같은 방식으로 비교하고 둘다 일치하지 않는 경우 순서를 변경할 수 없기 때문에 문자열을 만들 수 없다고 판단하고 No 반환
- 원하는 문자열을 모두 확인한 경우 Yes 반환
- 시간 복잡도: O(n) (n <= card1.length + card2.length)

### Level 1. 과일 장수
- 최대 점수 k, 한 상자에 담을 수 있는 수 m, 점수 배열이 주어졌을 때 m 개씩 나눠담고 (한 상자의 최소 점수 * m * 상자의 수) 가 최대가 되는 값을 구하는 문제
- 상자의 최소 점수가 중요하기 때문에 점수 배열을 정렬한 다음 배열의 뒤에서부터 돌면서 (i - m) 번째 점수와 m을 곱해 최종 결과에 더해주고
- i는 m씩 줄여가면서 반복한 뒤 최종적으로 값을 반환
- 시간 복잡도: O(n/m) (sort의 시간 복잡도: O(nlogn))

### Level 1. 기사 단원의 무기
- 기사 단원 수(number), 제한 수치(limit), 제한 수치 시 무기 공격력(power)이 주어졌을 때 무기를 만들기 위해 필요한 철의 무게를 구하는 문제
  + 무기를 만들기 위한 철은 무기 공격력이 1일 때 1kg
  + 기사 단원의 무기 공격력은 본인 번호의 약수 개수
- 기사 단원 수만큼 반복문을 돌면서 현재 index를 기준으로 배수에 해당하는 경우 1씩 값을 증가시켜 둠 -> 이렇게 하면 현재 인덱스를 확인할 때 약수의 개수를 알 수 있음
- 현재 인덱스의 수가 limit을 초과하는 경우는 power를 아닌 경우 현재 인덱스의 수를 최종 결과에 저장 후 반환
- 시간 복잡도: O(n^2)와 O(n) 사이 (n <= 100,000)

### Level 1. 옹알이 (2)
- 문자열 배열이 주어졌을 때 "aya", "ye", "woo", "ma"를 조합해서 만들 수 있는 단어가 몇개인지를 구하는 문제 (단, 같은 문자는 연달아서 올 수 없습니다.)
- 주어진 문자열을 돌면서 반복되는 문자를 포함한 경우는 다음 문자로 이동
- 그렇지 않은 경우 하나씩 문자를 찾아 " "로 변환하고 최종적으로 " "를 ""로 변환한 뒤 해당 문자열이 비어 있으면 조합해서 만들 수 있는 문자로 판단하고 결과값을 1 증가
- 최종 결과값을 반환하여 문제를 해결
- 시간 복잡도: O(n) (n <= 100)

### Level 1. 문자열 나누기
- 문자열이 주어졌을 때 첫번째 문자와 아닌 문자의 수가 같은 경우 문자열을 분리하는 방식으로 총 나눌 수 있는 문자열의 수를 구하는 문제
- 문자열을 처음부터 돌면서 첫 문자를 찾고 그 다음 문자부터 같은지 다른지 비교하여 그 수를 세고
- 첫 문자의 개수와 다른 문자의 개수가 같은 경우 결과값을 1 증가시키고 첫번째 문자와 그 개수, 다른 문자의 개수를 모두 초기화
- 위 방식으로 문자열 전체를 확인한 뒤 결과값을 반환하여 문제 해결
- 시간 복잡도: O(n) (n <= 10000)

### Level 1. 대충 만든 자판
- 키에 할당된 문자에 대한 정보와 실제 작성하고자 하는 문자가 주어졌을 때 작성하고자 하는 문자를 만들기 위해 눌러야하는 키의 최솟값을 구하는 문제
- 먼저 keymap 배열을 순회하면서 해당 문자열을 찾을 수 있는 최소 횟수를 int 배열에 저장합니다.
- 이후 target 배열을 순회하면서 각 문자열의 문자를 누를 수 있는 최소 횟수를 기존 배열에서 찾아 그 합을 더해 반환하면 해결
- 시간 복잡도: O(nxm) (n <= 100, m <= 100)

### Level 1. 숫자 짝꿍
- 2개의 숫자 문자열이 주어졌을 때 같은 숫자들을 뽑아 만들 수 있는 최대 숫자를 구하는 문제
- 문자 X, Y를 돌면서 나온 숫자의 개수를 int 배열에 저장합니다. (나온 숫자가 index, 개수가 값)
- 그리고 해당 int 배열을 뒤에서부터 돌면서 X에서 나온 개수와 Y에서 나온 개수 중 더 적은 수만큼 정답 문자열에 해당 인덱스를 추가합니다.
- 이때 X에서 나온 개수와 Y에서 나온 개수 모두 0보다 클 때만 수행합니다.
- 이후 int 배열 0번 인덱스도 위와 같이 확인하는데 만약 이전 문자열이 비어있다면 0 하나만 추가하고 아니라면 위에서와 같은 비교를 통해 0을 기존 문자열 뒤에 붙입니다.
- 이후 정답 문자열이 비어있다면 -1을 그렇지 않다면 정답 문자열을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 3000000)

### Level 1. 둘만의 암호
- 문자열 s와 skip할 문자열 skip이 주어졌을 떄 s 문자에서 skip에 포함되지 않은 index만큼 떨어진 문자를 찾아 반환하는 문제
- 문자열 s를 순회하면서 해당 문자의 다음 문자가 skip에 포함되어 있지 않다면 다음을 계속 확인한 뒤 찾은 문자를 최종 문자열에 모아 반환하여 해결
- 시간 복잡도: O(n x m) (n <= 50, m <= 20)

### Level 1. 햄버거 만들기
- 햄버거 재료의 순서가 담긴 배열을 받아 만들 수 있는 햄버거의 최대 개수를 구하는 문제
- stack을 사용하려고 했으나 런타임 에러 발생
- StringBuilder로 변경하여 문자를 붙이면서 문자의 길이가 3이 넘고 뒤에서 4자리 수가 "1231" 과 동일한 경우 만든 햄버거 수를 1 증가시키고 뒤 문자 4개를 삭제
- StringBuilder를 사용해도 replace로 "1231"을 빈문자로 바꾸거나 String에 += 연산을 사용하는 경우 시간 초과 발생
- 시간 복잡도: O(n) (n <= 1000000)
- 참고
  + String += 연산 O(N+K) (N: 기존 문자열의 길이, K: 더하려고 하는 문자열의 길이)
  + String replace 연산 O(len(str) * (len(a) + len(b)/len(a))) (str: 문자열, a: 교체되는 문자열, b: 교체할 문자열) -> 교체할 문자열이 교체되는 문자열보다 긴 경우 초과된 길이만큼 공간을 만들어야해서 최악
  + https://programmer-may.tistory.com/154

### Level 1. 바탕화면 정리
- 바탕화면의 상태가 문자열 배열로 주어졌을 때 모든 파일을 선택할 수 있는 최소 범위를 드레그할 수 있는 시작점과 종료점을 구하는 문제
  + .은 파일이 없는 위치, #은 파일이 있는 위치
  + 대각선 길이가 최소가 되는 왼쪽 상단 (x,y)와 오른쪽 하단 (x,y)를 구하는 문제
- 각 줄을 순회하면서 현재 문자가 .인 경우는 패스하고
- #인 경우는 현재 위치와 기존 최솟값, 최댓값을 비교하여 배열에 저장합니다. 이때 최댓값은 x+1, y+1을 하여 비교합니다.
- 이렇게 구한 배열을 반환합니다.
- 시간 복잡도: O(n x m) (n <= 50, m <= 50)

### Level 1. 달리기 경주
- 선수들의 순서와 이름이 불린 선수들의 순서가 담긴 문자열이 주어졌을 떄 최종적으로 선수들의 순서를 구하는 문제
  + 이름이 불린 선수는 바로 앞 선수를 추월한 것으로 둘의 순서가 바뀜
- 처음 순서들의 순서를 key=이름, value=순서로 하여 map에 저장한 뒤
- 이름이 불린 선수를 map에서 찾아 해당 인덱스를 바탕으로 이전 선수를 찾은 뒤 두 선수의 인덱스를 바꿔 map 과 순서 배열을 업데이트
- 모든 선수의 이름이 불린 뒤 위에서 새로 정렬된 배열을 반환하여 문제 해결
- 시간 복잡도: O(n) (n <= 1000000)


### Level 1. 공원 산책
- 공원의 상태와 강아지의 이동 방향과 거리가 주어졌을 때 최종적으로 강아지의 위치를 구하는 문제
  + S는 시작점, O는 지날 수 있는 길, X는 지날 수 없는 길
- 먼저 공원의 상태를 이차원 배열로 변경하면서 시작점(S)의 위치를 확인하고 O이면 true, X이면 false로 상태를 저장
- 각 방향에 대해 이동할 위치를 map으로 저장 {N: {-1, 0}, S: {1, 0}, W: {0, -1}, E: {0, 1}}
- 강아지의 이동 방향을 확인하면서 해당 방향으로 이동하는 수만큼 반복하면서 갈 수 있는지 확인하고 갈 수 있는 경우 시작점의 위치를 바꿔 저장
- 최종적으로 시작점 배열에 담긴 값을 반환하여 문제 해결
- 시간 복잡도: O(9n) (n <= 50)

### Level 2. 디펜스 게임
- 병사의 수 n, 무적권 수 k, 각 라운드별 적의 수가 배열로 주어졌을 때 갈 수 있는 최대 라운드 수를 구하는 문제
- 최소 힙을 사용하여 문제를 해결
- 먼저 k보다 라운드 수가 적거나 같다면 모두 막을 수 있으므로 라운드 수를 바로 반환
- 그렇지 않은 경우 각 라운드를 돌면서 우선 순위 큐에 적의 수를 넣고 만약 우선 순위 큐의 길이가 k 보다 큰 경우 최솟값을 빼서 가진 병사의 수에서 빼기 (최소 값을 병사로 막고 나머지는 무적권으로 막는 방법)
- 그런 다음 남은 병사의 수가 음수가 아니라면 해당 라운드 통과로 해당 라운드 수를 answer에 담고 음수인 경우는 그대로 break
- 최종 answer를 반환하여 해결
- 시간 복잡도: O(n) (n <= 1000000) / 우선 순위 큐 O(logN)

### Level 2. 광물 캐기
- 곡괭이 개수 배열과 캘 수 있는 광물 배열이 주어졌을 때 광물을 캘 때 드는 피로도가 최소가 되는 값을 구하는 문제
- 곡괭이 하나를 선택하면 한번에 5개씩 광물을 캘 수 있기 때문에 한번 캘 때 피로도가 높은 라운드에 좋은 곡괭이로 광물을 캐는 방식으로 해결
- 먼저 5개씩 잘라서 각 광물의 개수대로 {diamond 개수 * 25, iron 개수 * 5, stone 개수 * 1}로 묶어서 배열에 저장
- 각 라운드를 피로도가 높은 순으로 재배치하는데 제일 안좋은 곡괭이로 캔다고 생각하고 피로도를 계산하여 정렬
  + 예를 들어 한 라운드에 {1, 2, 2} 광물을 캔다고 했을 때 1 * 25 + 2 * 5 + 2 * 1 = 37 피로도를 가짐
- 이렇게 재정렬한 배열을 순차적으로 돌면서 다이아몬드 곡괭이부터 사용하여 광물을 캐고 해당 라운드의 피로도를 최종 응답에 추가
  + 만약 {25, 10, 2} 광물을 다이아몬드 곡괭이로 캐는 경우 25 / 25 + 10 / 5 + 2 / 1 = 5
  + 같은 광물을 철 곡괭이로 캐는 경우 25 / 5 + 10 / 5 + 2 / 1 = 9
  + 같은 광물을 돌 곡괭이로 캐는 경우 25 / 1 + 10 / 1 + 2 / 1 = 37
- 이렇게 곡괭이를 다쓰거나 광물을 다 캘 때까지 반복하면서 피로도를 계산하여 반환하면 해결
- 시간 복잡도: O(n) (n <= 50)

### Level 2. 우박수열 정적분
- 초기값 k와 정적분을 구할 범위가 a, b가 담긴 배열이 주어졌을 때 해당 범위의 정적분을 구하는 문제
- 먼저 초기값을 가지고 우박수열을 구해 해당 값을 리스트로 저장
- 이후 a > = b 인 경우는 -1.0을 a < b 인 경우에는 정적분을 구해 결과 배열에 넣고 최종적으로 반환하여 문제 해결
  + 사다리꼴 넓이를 구하는 식으로 범위를 구할 수 있는데 (윗변 + 아래변) * 높이 / 2 를 하면 되고 여기서 높이는 항상 1
- 시간 복잡도: O(n) (n <= 400)

### Level 2. 혼자 놀기의 달인
- 무작위로 섞인 카드가 주어졌을 때, 임의의 상자를 2번 열어 각 판에서 얻은 카드의 수의 곱이 가장 큰 경우를 구하는 문제
  + i 번째 상자에서 카드를 찾아 나온 수에 해당하는 인덱스 상자를 열고 이를 반복
- 한번 카드를 뽑으면 그 다음에는 다른 경우에 카드가 뽑히는 일이 없기 때문에
- 한번 카드를 뽑을 때 나온 개수를 우선 순위 큐에 넣고 뽑힌 카드 자리는 0으로 변경
- 다음 번에는 0이 아닌 카드를 찾아서 다시 해당 라운드의 카드를 뽑고 뽑은 카드의 수를 우선 순위 큐에 저장
- 만약 우선 순위 큐의 수가 2보다 큰 경우 가장 작은 값을 빼버리기
- 최종적으로 남은 우선 순위 큐에 있는 값 2개를 찾아 곱해서 결과 반환
- 시간 복잡도: O(n) (n <= 100)

### Level 2. 두 원 사이의 정수 쌍
- 반지름 r1, r2가 주어졌을 때 두 원 사이의 정수 쌍의 수를 구하는 문제
- 원의 방정식은 x^2 + y^2 = r^2이고 원의 방정식에서 특정 x값에서의 y값을 구하고 싶을 경우 y = sqrt(r^2 - x^2)의 식을 통해 구할 수 있음
- 여기서 두 원 r1과 r2가 있을 경우 두 원에서 특정 x값에서의 y값을 각각 구한 후 큰 값에서 작은 값을 빼는 과정을 x가 r2와 같을 때까지 반복해서 더하면 두 원 사이에 존재하는 점의 개수를 모두 구할 수 있음
- 특정 x 값의 y값을 구할 때 작은 원의 경우 현재 위치보다 큰 값이 개수에 포함되기 때문에 구한 값을 올림 처리하고 큰 원의 경우 현재 위치보다 작은 값이 개수에 포함되기 때문에 구한 값을 내림 처리
- 4개의 사분면에 동일하게 정수 쌍이 존재하기 때문에 각 축에 대한 정보도 하나씩 나눠 확인한다 생각하고 x는 1부터 r2까지 확인
- 이후 구한 점의 개수에 4를 곱해 사분면 모두의 개수를 반환하여 문제 해결
- 시간 복잡도: O(n - 1) (n <= 1000000)

### Level 2. 
