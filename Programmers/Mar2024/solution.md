# 문제 풀이

### Level 1. 가장 많이 받은 선물
- 주어진 조건에서 다음 달에 가장 많은 선물을 받을 수 있는 사람이 받게 되는 선물의 최대 수를 구하는 문제
  + A가 B에게 이번에 선물을 더 많이 준 경우 다음달에 A가 B에게 선물 1개 받음
  + A와 B가 주고 받은 선물이 없거나 같은 경우, 선물 지수가 더 높은 사람이 더 낮은 사람에게 선물 1개 받음
    - 선물 지수 = 내가 준 총 선물 개수 - 내가 받은 총 선물 개수
- 먼저 주어진 friends의 이름과 인덱스를 매칭한 Map을 구성하고
- 누가 누구에게 선물을 주었는지 이차원 배열로 저장합니다.
  + A의 인덱스가 0, B의 인덱스가 1이고 A가 B에게 선물을 주었다면 ```giftStatus[0][1] += 1``` 이 됩니다.
  + 이때 선물 지수도 같이 계산하여 별도의 1차원 배열로 저장합니다. (준사람은 플러스 ```giftIndex[0]++``` 받은 사람은 마이너스 ```giftIndex[1]--```)
- 그리고 나서 이차원 배열을 순회하면서 다음 달에 받을 선물의 개수를 별도의 1차원 배열에 저장합니다.
  + i 번째와 그 다음 순서부터 비교하면서 받을 선물의 개수를 채워갑니다.
- 이후 최종 배열에서 가장 큰 수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n^2) (n <= 50)

### Level 1. 이웃한 칸
- 칸의 색이 적힌 2차원 배열과 선택한 위치 h,w가 주어졌을 때 해당 위치와 상하좌우의 색이 같은 개수를 구하는 문제
- h, w에서 상하좌우로 이동 시 배열의 범위 안에 있는 경우 해당 위치와 h,w 칸의 색을 비교해서 같으면 answer 값을 1 증가시키고
- 최종적으로 answer 값을 반환합니다.
- 시간 복잡도: O(n) (n = 4)

### Level 1. 데이터 분석
- 배열이 주어졌을 때, ext 인덱스의 값이 val_ext 보다 작은 값들을 sort_by 인덱스의 값이 작은 순서대로 정렬한 이차원 배열을 반환하는 문제
- 먼저 각 타입에 해당하는 문자열을 인덱스와 함께 Map으로 저장합니다. {"code": 0, "date": 1, "maximum": 2, "remain": 3}
- 그런 다음, Arrays.stream()을 사용하여 filter 한 뒤, sorted 하는 방식으로 구할 수 있습니다.
- 시간 복잡도: O(nlogn) (n <= 500)

### Level 1. 삼총사
- 배열이 주어졌을 때 3개를 골라 그 합이 0이 되는 경우의 수를 구하는 문제
- 순서 상관 없이 3개를 뽑는 조합을 재귀를 통해 구현해도 되지만 크기가 크지 않기 때문에 삼중 for문으로 찾으면서 문제 해결
- 시간 복잡도: O(n^3) (n <= 13)

### Level 1. 가장 가까운 같은 글자
- 문자열이 주어졌을 때 각 위치의 문자와 동일한 문자 중 앞에 등장하면서 가장 가까이에 있는 문자의 인덱스를 담은 배열을 반환하는 문제
- 문자열을 돌면서 각 문자에서 소문자 'a'를 뺀 위치에 담긴 인덱스와 비교하는 방식으로 문제 해결
  + 초기 인덱스는 -1로 -1이 들어있다면 해당 문자와 같은 문자는 앞에 나타난 적이 없으므로 -1을 결과 배열에 저장
  + 현재 인덱스를 해당 위치에 저장
- 시간 복잡도: O(n)

### Level 1. 푸드 파이트 대회
- 배열이 주어진 경우 "0" 앞뒤로 같은 개수만큼의 인덱스를 붙여서 문자열을 반환하는 문제
  + {1, 3, 4, 6} 이 주어지는 경우 0 번 인덱스는 항상 1로 중간에 두고
  + 1번 인덱스 3, 2번 인덱스 4, 3번 인덱스 6 이므로 1223330333221 을 반환
- "0"을 기준으로 양옆을 붙여 나가기 위해 food 배열을 뒤에서부터 돌면서 food[i]/2 개수만큼 i를 "0" 앞뒤에 붙이고 결과 반환
- 시간 복잡도: O(n) (n <= 9)

### Level 1. 콜라 문제
- a개를 주면 b개를 돌려주는 가게가 있을 때 n개를 가지고 있다면 몇개를 돌려받을 수 있는지 구하는 문제
- n >= a 인 동안 반복하면서 (n / a) * b 개를 받을 수 있으므로 answer에 더하고 남은 개수는 (n % a) 와 더해 다시 반복
- 수학적으로 풀면 ```(n - b) / (a - b) * b```로 해결
- 시간 복잡도: O(1)

### Level 1. 명예의 전당 (1)
- k와 배열이 주어졌을 때, 배열을 돌면서 상위 k개의 최소값을 저장한 배열을 반환하는 문제
- 우선 순위 큐를 활용하여 score를 저장하고 큐의 크기가 k 를 넘는 경우 최소값을 제거
- 그리고 나서 큐에 담긴 가장 작은 값을 결과 배열에 저장하고 이를 반복한 뒤 결과 배열을 반환
- 시간 복잡도: O(n) (n <= 1000) / 우선 순위 큐의 요소 추가 연산 시간 복잡도: O(nlogn) - 최소 힙 사용

### Level 1. 카드 뭉치
- card1, card2, 원하는 문자열 배열이 주어졌을 때 card1, card2의 순서를 지키면서 원하는 문자열을 만들 수 있는지 구하는 문제
- 원하는 문자열의 배열을 돌면서 card1의 문자열과 같은지 비교하고 같으면 card1의 index를 하나 증가
- 다르면 card2도 같은 방식으로 비교하고 둘다 일치하지 않는 경우 순서를 변경할 수 없기 때문에 문자열을 만들 수 없다고 판단하고 No 반환
- 원하는 문자열을 모두 확인한 경우 Yes 반환
- 시간 복잡도: O(n) (n <= card1.length + card2.length)

### Level 1. 과일 장수
- 최대 점수 k, 한 상자에 담을 수 있는 수 m, 점수 배열이 주어졌을 때 m 개씩 나눠담고 (한 상자의 최소 점수 * m * 상자의 수) 가 최대가 되는 값을 구하는 문제
- 상자의 최소 점수가 중요하기 때문에 점수 배열을 정렬한 다음 배열의 뒤에서부터 돌면서 (i - m) 번째 점수와 m을 곱해 최종 결과에 더해주고
- i는 m씩 줄여가면서 반복한 뒤 최종적으로 값을 반환
- 시간 복잡도: O(n/m) (sort의 시간 복잡도: O(nlogn))

### Level 1. 기사 단원의 무기
- 기사 단원 수(number), 제한 수치(limit), 제한 수치 시 무기 공격력(power)이 주어졌을 때 무기를 만들기 위해 필요한 철의 무게를 구하는 문제
  + 무기를 만들기 위한 철은 무기 공격력이 1일 때 1kg
  + 기사 단원의 무기 공격력은 본인 번호의 약수 개수
- 기사 단원 수만큼 반복문을 돌면서 현재 index를 기준으로 배수에 해당하는 경우 1씩 값을 증가시켜 둠 -> 이렇게 하면 현재 인덱스를 확인할 때 약수의 개수를 알 수 있음
- 현재 인덱스의 수가 limit을 초과하는 경우는 power를 아닌 경우 현재 인덱스의 수를 최종 결과에 저장 후 반환
- 시간 복잡도: O(n^2)와 O(n) 사이 (n <= 100,000)

### Level 1. 옹알이 (2)
- 문자열 배열이 주어졌을 때 "aya", "ye", "woo", "ma"를 조합해서 만들 수 있는 단어가 몇개인지를 구하는 문제 (단, 같은 문자는 연달아서 올 수 없습니다.)
- 주어진 문자열을 돌면서 반복되는 문자를 포함한 경우는 다음 문자로 이동
- 그렇지 않은 경우 하나씩 문자를 찾아 " "로 변환하고 최종적으로 " "를 ""로 변환한 뒤 해당 문자열이 비어 있으면 조합해서 만들 수 있는 문자로 판단하고 결과값을 1 증가
- 최종 결과값을 반환하여 문제를 해결
- 시간 복잡도: O(n) (n <= 100)

### Level 1. 문자열 나누기
- 문자열이 주어졌을 때 첫번째 문자와 아닌 문자의 수가 같은 경우 문자열을 분리하는 방식으로 총 나눌 수 있는 문자열의 수를 구하는 문제
- 문자열을 처음부터 돌면서 첫 문자를 찾고 그 다음 문자부터 같은지 다른지 비교하여 그 수를 세고
- 첫 문자의 개수와 다른 문자의 개수가 같은 경우 결과값을 1 증가시키고 첫번째 문자와 그 개수, 다른 문자의 개수를 모두 초기화
- 위 방식으로 문자열 전체를 확인한 뒤 결과값을 반환하여 문제 해결
- 시간 복잡도: O(n) (n <= 10000)

### Level 1. 대충 만든 자판
- 키에 할당된 문자에 대한 정보와 실제 작성하고자 하는 문자가 주어졌을 때 작성하고자 하는 문자를 만들기 위해 눌러야하는 키의 최솟값을 구하는 문제
- 먼저 keymap 배열을 순회하면서 해당 문자열을 찾을 수 있는 최소 횟수를 int 배열에 저장합니다.
- 이후 target 배열을 순회하면서 각 문자열의 문자를 누를 수 있는 최소 횟수를 기존 배열에서 찾아 그 합을 더해 반환하면 해결
- 시간 복잡도: O(nxm) (n <= 100, m <= 100)

### Level 1. 숫자 짝꿍
- 2개의 숫자 문자열이 주어졌을 때 같은 숫자들을 뽑아 만들 수 있는 최대 숫자를 구하는 문제
- 문자 X, Y를 돌면서 나온 숫자의 개수를 int 배열에 저장합니다. (나온 숫자가 index, 개수가 값)
- 그리고 해당 int 배열을 뒤에서부터 돌면서 X에서 나온 개수와 Y에서 나온 개수 중 더 적은 수만큼 정답 문자열에 해당 인덱스를 추가합니다.
- 이때 X에서 나온 개수와 Y에서 나온 개수 모두 0보다 클 때만 수행합니다.
- 이후 int 배열 0번 인덱스도 위와 같이 확인하는데 만약 이전 문자열이 비어있다면 0 하나만 추가하고 아니라면 위에서와 같은 비교를 통해 0을 기존 문자열 뒤에 붙입니다.
- 이후 정답 문자열이 비어있다면 -1을 그렇지 않다면 정답 문자열을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 3000000)

### Level 1. 둘만의 암호
- 문자열 s와 skip할 문자열 skip이 주어졌을 떄 s 문자에서 skip에 포함되지 않은 index만큼 떨어진 문자를 찾아 반환하는 문제
- 문자열 s를 순회하면서 해당 문자의 다음 문자가 skip에 포함되어 있지 않다면 다음을 계속 확인한 뒤 찾은 문자를 최종 문자열에 모아 반환하여 해결
- 시간 복잡도: O(n x m) (n <= 50, m <= 20)

### Level 1. 햄버거 만들기
- 햄버거 재료의 순서가 담긴 배열을 받아 만들 수 있는 햄버거의 최대 개수를 구하는 문제
- stack을 사용하려고 했으나 런타임 에러 발생
- StringBuilder로 변경하여 문자를 붙이면서 문자의 길이가 3이 넘고 뒤에서 4자리 수가 "1231" 과 동일한 경우 만든 햄버거 수를 1 증가시키고 뒤 문자 4개를 삭제
- StringBuilder를 사용해도 replace로 "1231"을 빈문자로 바꾸거나 String에 += 연산을 사용하는 경우 시간 초과 발생
- 시간 복잡도: O(n) (n <= 1000000)
- 참고
  + String += 연산 O(N+K) (N: 기존 문자열의 길이, K: 더하려고 하는 문자열의 길이)
  + String replace 연산 O(len(str) * (len(a) + len(b)/len(a))) (str: 문자열, a: 교체되는 문자열, b: 교체할 문자열) -> 교체할 문자열이 교체되는 문자열보다 긴 경우 초과된 길이만큼 공간을 만들어야해서 최악
  + https://programmer-may.tistory.com/154

  ### Level 1. 바탕화면 정리
  - 바탕화면의 상태가 문자열 배열로 주어졌을 때 모든 파일을 선택할 수 있는 최소 범위를 드레그할 수 있는 시작점과 종료점을 구하는 문제
    + .은 파일이 없는 위치, #은 파일이 있는 위치
    + 대각선 길이가 최소가 되는 왼쪽 상단 (x,y)와 오른쪽 하단 (x,y)를 구하는 문제
  - 각 줄을 순회하면서 현재 문자가 .인 경우는 패스하고
  - #인 경우는 현재 위치와 기존 최솟값, 최댓값을 비교하여 배열에 저장합니다. 이때 최댓값은 x+1, y+1을 하여 비교합니다.
  - 이렇게 구한 배열을 반환합니다.
  - 시간 복잡도: O(n x m) (n <= 50, m <= 50)

  ### Level 1. 달리기 경주
  - 선수들의 순서와 이름이 불린 선수들의 순서가 담긴 문자열이 주어졌을 떄 최종적으로 선수들의 순서를 구하는 문제
    + 이름이 불린 선수는 바로 앞 선수를 추월한 것으로 둘의 순서가 바뀜
  - 처음 순서들의 순서를 key=이름, value=순서로 하여 map에 저장한 뒤
  - 이름이 불린 선수를 map에서 찾아 해당 인덱스를 바탕으로 이전 선수를 찾은 뒤 두 선수의 인덱스를 바꿔 map 과 순서 배열을 업데이트
  - 모든 선수의 이름이 불린 뒤 위에서 새로 정렬된 배열을 반환하여 문제 해결
  - 시간 복잡도: O(n) (n <= 1000000)


  ### Level 1. 

