# 문제 풀이

### Level 1. 가장 많이 받은 선물
- 주어진 조건에서 다음 달에 가장 많은 선물을 받을 수 있는 사람이 받게 되는 선물의 최대 수를 구하는 문제
  + A가 B에게 이번에 선물을 더 많이 준 경우 다음달에 A가 B에게 선물 1개 받음
  + A와 B가 주고 받은 선물이 없거나 같은 경우, 선물 지수가 더 높은 사람이 더 낮은 사람에게 선물 1개 받음
    - 선물 지수 = 내가 준 총 선물 개수 - 내가 받은 총 선물 개수
- 먼저 주어진 friends의 이름과 인덱스를 매칭한 Map을 구성하고
- 누가 누구에게 선물을 주었는지 이차원 배열로 저장합니다.
  + A의 인덱스가 0, B의 인덱스가 1이고 A가 B에게 선물을 주었다면 ```giftStatus[0][1] += 1``` 이 됩니다.
  + 이때 선물 지수도 같이 계산하여 별도의 1차원 배열로 저장합니다. (준사람은 플러스 ```giftIndex[0]++``` 받은 사람은 마이너스 ```giftIndex[1]--```)
- 그리고 나서 이차원 배열을 순회하면서 다음 달에 받을 선물의 개수를 별도의 1차원 배열에 저장합니다.
  + i 번째와 그 다음 순서부터 비교하면서 받을 선물의 개수를 채워갑니다.
- 이후 최종 배열에서 가장 큰 수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n^2) (n <= 50)

### Level 1. 이웃한 칸
- 칸의 색이 적힌 2차원 배열과 선택한 위치 h,w가 주어졌을 때 해당 위치와 상하좌우의 색이 같은 개수를 구하는 문제
- h, w에서 상하좌우로 이동 시 배열의 범위 안에 있는 경우 해당 위치와 h,w 칸의 색을 비교해서 같으면 answer 값을 1 증가시키고
- 최종적으로 answer 값을 반환합니다.
- 시간 복잡도: O(n) (n = 4)

### Level 1. 데이터 분석
- 배열이 주어졌을 때, ext 인덱스의 값이 val_ext 보다 작은 값들을 sort_by 인덱스의 값이 작은 순서대로 정렬한 이차원 배열을 반환하는 문제
- 먼저 각 타입에 해당하는 문자열을 인덱스와 함께 Map으로 저장합니다. {"code": 0, "date": 1, "maximum": 2, "remain": 3}
- 그런 다음, Arrays.stream()을 사용하여 filter 한 뒤, sorted 하는 방식으로 구할 수 있습니다.
- 시간 복잡도: O(nlogn) (n <= 500)