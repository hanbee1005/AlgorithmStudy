# 문제 풀이

### Level 1. 가장 많이 받은 선물
- 주어진 조건에서 다음 달에 가장 많은 선물을 받을 수 있는 사람이 받게 되는 선물의 최대 수를 구하는 문제
  + A가 B에게 이번에 선물을 더 많이 준 경우 다음달에 A가 B에게 선물 1개 받음
  + A와 B가 주고 받은 선물이 없거나 같은 경우, 선물 지수가 더 높은 사람이 더 낮은 사람에게 선물 1개 받음
    - 선물 지수 = 내가 준 총 선물 개수 - 내가 받은 총 선물 개수
- 먼저 주어진 friends의 이름과 인덱스를 매칭한 Map을 구성하고
- 누가 누구에게 선물을 주었는지 이차원 배열로 저장합니다.
  + A의 인덱스가 0, B의 인덱스가 1이고 A가 B에게 선물을 주었다면 ```giftStatus[0][1] += 1``` 이 됩니다.
  + 이때 선물 지수도 같이 계산하여 별도의 1차원 배열로 저장합니다. (준사람은 플러스 ```giftIndex[0]++``` 받은 사람은 마이너스 ```giftIndex[1]--```)
- 그리고 나서 이차원 배열을 순회하면서 다음 달에 받을 선물의 개수를 별도의 1차원 배열에 저장합니다.
  + i 번째와 그 다음 순서부터 비교하면서 받을 선물의 개수를 채워갑니다.
- 이후 최종 배열에서 가장 큰 수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n^2) (n <= 50)

### Level 1. 이웃한 칸
- 칸의 색이 적힌 2차원 배열과 선택한 위치 h,w가 주어졌을 때 해당 위치와 상하좌우의 색이 같은 개수를 구하는 문제
- h, w에서 상하좌우로 이동 시 배열의 범위 안에 있는 경우 해당 위치와 h,w 칸의 색을 비교해서 같으면 answer 값을 1 증가시키고
- 최종적으로 answer 값을 반환합니다.
- 시간 복잡도: O(n) (n = 4)

### Level 1. 데이터 분석
- 배열이 주어졌을 때, ext 인덱스의 값이 val_ext 보다 작은 값들을 sort_by 인덱스의 값이 작은 순서대로 정렬한 이차원 배열을 반환하는 문제
- 먼저 각 타입에 해당하는 문자열을 인덱스와 함께 Map으로 저장합니다. {"code": 0, "date": 1, "maximum": 2, "remain": 3}
- 그런 다음, Arrays.stream()을 사용하여 filter 한 뒤, sorted 하는 방식으로 구할 수 있습니다.
- 시간 복잡도: O(nlogn) (n <= 500)

### Level 1. 삼총사
- 배열이 주어졌을 때 3개를 골라 그 합이 0이 되는 경우의 수를 구하는 문제
- 순서 상관 없이 3개를 뽑는 조합을 재귀를 통해 구현해도 되지만 크기가 크지 않기 때문에 삼중 for문으로 찾으면서 문제 해결
- 시간 복잡도: O(n^3) (n <= 13)

### Level 1. 가장 가까운 같은 글자
- 문자열이 주어졌을 때 각 위치의 문자와 동일한 문자 중 앞에 등장하면서 가장 가까이에 있는 문자의 인덱스를 담은 배열을 반환하는 문제
- 문자열을 돌면서 각 문자에서 소문자 'a'를 뺀 위치에 담긴 인덱스와 비교하는 방식으로 문제 해결
  + 초기 인덱스는 -1로 -1이 들어있다면 해당 문자와 같은 문자는 앞에 나타난 적이 없으므로 -1을 결과 배열에 저장
  + 현재 인덱스를 해당 위치에 저장
- 시간 복잡도: O(n)

### Level 1. 푸드 파이트 대회
- 배열이 주어진 경우 "0" 앞뒤로 같은 개수만큼의 인덱스를 붙여서 문자열을 반환하는 문제
  + {1, 3, 4, 6} 이 주어지는 경우 0 번 인덱스는 항상 1로 중간에 두고
  + 1번 인덱스 3, 2번 인덱스 4, 3번 인덱스 6 이므로 1223330333221 을 반환
- "0"을 기준으로 양옆을 붙여 나가기 위해 food 배열을 뒤에서부터 돌면서 food[i]/2 개수만큼 i를 "0" 앞뒤에 붙이고 결과 반환
- 시간 복잡도: O(n) (n <= 9)

### Level 1. 콜라 문제
- a개를 주면 b개를 돌려주는 가게가 있을 때 n개를 가지고 있다면 몇개를 돌려받을 수 있는지 구하는 문제
- n >= a 인 동안 반복하면서 (n / a) * b 개를 받을 수 있으므로 answer에 더하고 남은 개수는 (n % a) 와 더해 다시 반복
- 수학적으로 풀면 ```(n - b) / (a - b) * b```로 해결
- 시간 복잡도: O(1)

