# 문제 풀이

### 3105. Longest Strictly Increasing or Strictly Decreasing Subarray ```EASY```
- 정수 배열이 주어졌을 때 연속하여 오름차순이거나 연속하여 내림차순인 수들 중 가장 긴 길이를 구하는 문제
- 먼저 오름차순의 개수, 내림차순의 개수, 최대 개수를 각각 1로 초기화합니다.
- 이후 배열을 반복하면서 현재 위치의 값이 다음 위치의 값보다 작다면 오름차순이므로 오름차순의 개수를 증가시키고 내림차순의 개수는 1로 초기화합니다.
- 반대로 현재 위치의 값이 다음 위치의 값보다 크다면 내림차순이므로 내림차순의 개수를 증가시키고 오름차순의 개수를 1로 초기화합니다.
- 마지막으로 같은 경우 오름차순의 개수와 내림차순의 개수 모두 1로 초기화한 뒤 현재의 오름차순의 개수, 내림차순의 개수, 최대 개수 중 가장 큰 값으로 최대 개수를 업데이트 합니다.
- 이렇게 구한 최대 개수를 최종적으로 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 50)

### 1800. Maximum Ascending Subarray Sum ```EASY```
- 정수 배열이 주어졌을 때 연속하는 오름차순의 합이 가장 큰 경우를 구하는 문제
- 먼저 오름차순의 합을 저장할 변수와 최대 합을 저장할 변수를 생성한 뒤 주어진 정수 배열의 첫번쩨 값으로 초기화합니다.
- 그리고 배열을 돌면서 현재 위치의 값이 다음 위치의 값보다 작은 경우 오름차순에 해당하므로 오름차순의 합에 다음 위치 값을 추가합니다.
- 그렇지 않은 경우는 오름차순의 값을 다음 위치의 값으로 변경합니다.
- 그리고 최대 합과 오름차순의 합 중 최대값을 최대 합의 값으로 저장한 뒤 다음 값들을 확인합니다.
- 최종적으로 이렇게 구한 최대 합을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### 1790. Check if One String Swap Can Make Strings Equal ```EASY```
- 두 문자열이 주어졌을 때, 1번만 어떤 위치의 문자 2개를 바꿔서 같은 문자열이 되는지를 구하는 문제
- 먼저 두 문자열이 처음부터 같다면 바로 true를 반환합니다.
- 처음 다른 문자를 저장할 c1, c2 변수를 만들고 다른 위치의 개수를 담을 cnt 변수를 선언합니다.
- 그리고 문자열을 순회하면서 s1의 해당 위치 문자와 s2의 해당 위치 문자가 다른 경우 cnt 변수를 증가시키고
- cnt가 1인 경우 처음으로 다른 문자이므로 c1, c2에 각각 문자를 저장합니다.
- 그렇지 않고 cnt가 2이면서 c1과 s2의 해당 위치 문자가 같고 c2와 s1의 해당 위치 문자가 같은 경우 두 문자를 바꿔 같은 문자열을 만들 수 있기 때문에 최종 응답을 true로 변경합니다.
- 그 이후에 또 다른 위치의 문자가 나와 cnt가 2를 초과하는 경우 다시 최종 응답을 false로 변경합니다.
- 이렇게 끝까지 확인하고 최종 응답을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### 1726. Tuple with Same Product ```MEDIUM```
- 주어진 정수 배열 nums에서, 서로 다른 두 쌍의 숫자 곱이 같은 경우의 개수를 찾는 문제
- 모든 가능한 곱을 확인하기 위해, 두 개의 숫자를 선택하여 곱을 계산하고, ```HashMap<Integer, Integer>```에 저장합니다.
- map의 키는 product (곱), 값은 해당 곱이 나타난 횟수를 나타냅니다.
- 그리고 중복되는 값이 있으면 8을 곱하여 count를 증가시킵니다.
  + 어떤 product가 이미 map에 존재하면, 이전에 동일한 곱을 가진 쌍이 있었다는 뜻.
  + map.getOrDefault(product, 0)을 통해 지금까지 나온 동일한 product의 개수를 가져옴.
  + (이전 등장 횟수 × 8)을 count에 추가 (모든 순열을 고려해야 하므로 8을 곱함).
  + map.merge(product, 1, Integer::sum)을 사용하여 product의 개수를 증가.
- 최종적으로 count를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n^2) (n <= 10000)

### 3174. Clear Digits ```EASY```
- 소문자와 숫자로 이루어진 문자열이 주어졌을 때, 숫자와 숫자의 왼쪽 문자를 삭제하고 남은 문자열을 반환하는 문제
- 먼저 정답을 담을 StringBuilder를 생성하고 해당 문자는 아직 아무것도 없으므로 i = -1로 초기화합니다.
- 이후 주어진 문자열을 순회하면서 문자가 영문 소문자인 경우 i를 증가시키고 정답을 추가합니다.
- 그리고 숫자인 경우는 i가 0 이상일 때, 즉 이전에 나온 문자가 있는 경우 가장 마지막 문자인 i 위치의 문자를 제거하고 i 를 감소시킵니다.
- 이렇게 반복한 뒤 나온 문자열을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### ```EASY```

