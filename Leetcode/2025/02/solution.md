# 문제 풀이

### 3105. Longest Strictly Increasing or Strictly Decreasing Subarray ```EASY```
- 정수 배열이 주어졌을 때 연속하여 오름차순이거나 연속하여 내림차순인 수들 중 가장 긴 길이를 구하는 문제
- 먼저 오름차순의 개수, 내림차순의 개수, 최대 개수를 각각 1로 초기화합니다.
- 이후 배열을 반복하면서 현재 위치의 값이 다음 위치의 값보다 작다면 오름차순이므로 오름차순의 개수를 증가시키고 내림차순의 개수는 1로 초기화합니다.
- 반대로 현재 위치의 값이 다음 위치의 값보다 크다면 내림차순이므로 내림차순의 개수를 증가시키고 오름차순의 개수를 1로 초기화합니다.
- 마지막으로 같은 경우 오름차순의 개수와 내림차순의 개수 모두 1로 초기화한 뒤 현재의 오름차순의 개수, 내림차순의 개수, 최대 개수 중 가장 큰 값으로 최대 개수를 업데이트 합니다.
- 이렇게 구한 최대 개수를 최종적으로 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 50)

### 1800. Maximum Ascending Subarray Sum ```EASY```
- 정수 배열이 주어졌을 때 연속하는 오름차순의 합이 가장 큰 경우를 구하는 문제
- 먼저 오름차순의 합을 저장할 변수와 최대 합을 저장할 변수를 생성한 뒤 주어진 정수 배열의 첫번쩨 값으로 초기화합니다.
- 그리고 배열을 돌면서 현재 위치의 값이 다음 위치의 값보다 작은 경우 오름차순에 해당하므로 오름차순의 합에 다음 위치 값을 추가합니다.
- 그렇지 않은 경우는 오름차순의 값을 다음 위치의 값으로 변경합니다.
- 그리고 최대 합과 오름차순의 합 중 최대값을 최대 합의 값으로 저장한 뒤 다음 값들을 확인합니다.
- 최종적으로 이렇게 구한 최대 합을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### 1790. Check if One String Swap Can Make Strings Equal ```EASY```
- 두 문자열이 주어졌을 때, 1번만 어떤 위치의 문자 2개를 바꿔서 같은 문자열이 되는지를 구하는 문제
- 먼저 두 문자열이 처음부터 같다면 바로 true를 반환합니다.
- 처음 다른 문자를 저장할 c1, c2 변수를 만들고 다른 위치의 개수를 담을 cnt 변수를 선언합니다.
- 그리고 문자열을 순회하면서 s1의 해당 위치 문자와 s2의 해당 위치 문자가 다른 경우 cnt 변수를 증가시키고
- cnt가 1인 경우 처음으로 다른 문자이므로 c1, c2에 각각 문자를 저장합니다.
- 그렇지 않고 cnt가 2이면서 c1과 s2의 해당 위치 문자가 같고 c2와 s1의 해당 위치 문자가 같은 경우 두 문자를 바꿔 같은 문자열을 만들 수 있기 때문에 최종 응답을 true로 변경합니다.
- 그 이후에 또 다른 위치의 문자가 나와 cnt가 2를 초과하는 경우 다시 최종 응답을 false로 변경합니다.
- 이렇게 끝까지 확인하고 최종 응답을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### ```EASY```


