# 문제 풀이

### 2460. Apply Operations to an Array ```EASY```
- 배열이 주어졌을 때, nums[i] == nums[i+1]과 같을 때 nums[i] 값은 2를 곱하고 nums[i+1]은 0으로 변경한 뒤 최종적으로 0을 제일 뒤로 몬 배열을 반환하는 문제
- 먼저 배열을 돌면서 nums[i] == nums[i+1]과 같을 때 nums[i] 값은 2를 곱하고 nums[i+1]은 0으로 변경합니다.
- 그리고 정답 배열을 생성한 뒤, idx = 0을 지정하고 이전 배열을 돌면서 0이 아닌 경우 idx 위치에 넣은 뒤 idx를 증가시킵니다.
- 이후 정답 배열을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 2000)

### 2873. Maximum Value of an Ordered Triplet I ```EASY```
- 정수 배열이 주어졌을 때, `(nums[i] - nums[j]) * nums[k]` (i < j < k) 의 최대값을 구하는 문제 (만약 모두 음수이면 0을 반환)
- imax: 지금까지 만난 수 중 가장 큰 수를 기억합니다. → a 후보
- dmax: 지금까지 가능한 (a - b) 값 중 최댓값을 저장합니다. → (a - b) 후보
- answer: 최종적으로 찾고자 하는 (a - b) * c 의 최댓값을 계속 갱신합니다.
- 배열을 순회하면서
  + answer = max(answer, dmax * num) → 지금까지 구한 (a - b) 최대값과 현재 값 c = num을 곱해서 (a - b) * c 값을 계산해보고, answer를 갱신합니다.
  + dmax = max(dmax, imax - num) → 현재 수를 b라고 생각하고, 이전까지 봤던 가장 큰 수 imax를 a라고 보면, (a - b) 값이 나옵니다. → 이걸 이용해서 dmax를 갱신합니다.
  + imax = max(imax, num) → 현재 값을 기준으로, 지금까지 본 수 중 가장 큰 값을 계속 갱신합니다.
- 이렇게 구한 answer를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (3 <= n <= 100)

### 416. Partition Equal Subset Sum ```MEDIUM```
- 배열이 주어졌을 때 2개의 서브 배열의 합이 같은 경우 true, 아닌 경우 false를 반환하는 문제
- 배열의 전체 합을 계산합니다.
- 두 부분으로 나누려면 총합이 짝수여야 가능하므로, 합이 홀수면 바로 false를 반환합니다.
- dp 배열을 생성하고 초기화 합니다.
  + dp[i]는 합이 i인 부분 집합이 존재하는가를 의미합니다.
  + dp[0] = true는 "합이 0인 부분집합(공집합)은 항상 존재한다"는 의미입니다.
  + dp의 크기를 10001로 잡은 이유는, 문제에서 주어질 수 있는 최대 합을 고려한 것 같습니다.
- 그리고 부분 집합을 탐색합니다.
  + 각 숫자 num에 대해, 가능한 모든 j에 대해 dp[j]를 업데이트합니다.
  + dp[j - num] == true면, dp[j]도 true가 될 수 있습니다. 즉, j라는 합은 num을 더해서 만들 수 있다는 뜻입니다.
  + j를 거꾸로 순회하는 이유는 한 num으로 여러 번 같은 수를 더하는 것을 방지하기 위해서입니다 (1번만 써야 함).
- 최종적으로 전체 합의 절반(sum / 2)을 만들 수 있는 부분집합이 존재하면, 두 부분으로 나눌 수 있으므로 true를 반환합니다.
- 시간 복잡도: O(N) (N <= 200)

### 1534. Count Good Triplets ```EASY```
- 정수로 이루어진 배열과 a, b, c 세 정수가 주어졌을 때, i < j < k 이면서 |arr[i] - arr[j]| <= a && |arr[j] - arr[k]| <= b && |arr[i] - arr[k]| <= c 를 만족하는 쌍의 개수를 구하는 문제
- 이중 for 문을 돌면서 먼저 |arr[i] - arr[j]| <= a 인지 확인하고
- 맞다면 for 문을 하나 더 돌면서 |arr[j] - arr[k]| <= b && |arr[i] - arr[k]| <= c 이 조건까지 맞는지 확인해 맞는 경우의 숫자를 세서
- 최종적으로 구한 수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n^3) (n <= 100)

### 1863. Sum of All Subset XOR Totals ```EASY```
- 배열의 모든 부분집합의 XOR 합들의 총합을 구하는 문제
- Step 1: 전체 OR 수행
  + 모든 원소를 bitwise OR 연산으로 합쳐서 total에 저장합니다.
  + 예를 들어 nums = {1, 2, 3}일 경우:
    - 1 | 2 = 3
    - 3 | 3 = 3
    - 최종적으로 total = 3
- Step 2: 곱하기 2^(n−1)
  + 모든 원소가 포함되는 부분집합의 수는 2^(n−1) 번입니다.
    - 각 비트는 절반의 부분집합에 포함되고 절반에는 포함되지 않기 때문입니다.
  + 각 비트는 XOR 연산에서 홀수 번 등장할 경우에만 결과에 영향을 미칩니다.
- 시간 복잡도: O(n) (n <= 12)

### 1399. Count Largest Group ```EASY```
- 정수가 주어졌을 때, 1부터 n까지 각 자리의 수를 더해서 같은 값이 나오는 수를 그룹핑해서 최대 개수를 가진 그룹의 수를 구하는 문제
- 개수를 인덱스로 가지는 배열을 생성하고 1부터 n까지 반복하면서 먼저 해당 자리의 수를 모두 더합니다.
- 그리고 해당 개수의 인덱스 값을 증가시킵니다.
- 그런 다음 해당 개수가 max보다 크다면 max의 값을 해당 개수로 변경하고 정답을 1로 변경합니다.
- 그렇지 않고 max와 현재 개수가 같다면 정답만 1 증가시킵니다.
- 이렇게 n까지 반복한 뒤 정답을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 10^4)

### 2799. Count Complete Subarrays in an Array ```MEDIUM```
- 주어진 정수 배열 nums에서 모든 고유한 값들을 전부 포함하는 "완전한 부분 배열(complete subarray)"의 개수를 세는 문제
- 먼저 set 을 만들어 고유 원소 개수를 파악합니다. 
  + 배열 전체에서 고유한 정수의 개수를 세어 k로 저장합니다.
- 슬라이딩 윈도우 초기화
  + (i, j)는 슬라이딩 윈도우의 좌우 포인터입니다.
  + map은 현재 윈도우 내 원소의 개수를 저장합니다.
- 메인 루프 (j 증가)
  + 오른쪽 포인터 j를 한 칸씩 이동하면서 현재 윈도우에 포함된 값들을 map에 추가합니다.
- 윈도우가 "완전한" 경우 처리
  + 현재 map.size() == k면, 이 윈도우는 전체 고유값을 포함합니다.
  + 이 상태에서 (i, j) 사이의 서브배열에서 시작점 i를 고정하고 끝점을 j ~ nums.length-1까지 이동시켜도 항상 고유값이 포함되므로
    - 가능한 완전 부분 배열 수는 nums.length - j
  + 이후 왼쪽 포인터 i를 한 칸씩 줄여가며 조건을 깨뜨릴 때까지 반복합니다.
- 시간 복잡도: O(n) (n <= 1000)

### 3392. Count Subarrays of Length Three With a Condition ```EASY```
- 배열이 주어졌을 때, 3개의 연속된 수를 뽑아 처음과 마지막 수의 합이 중간 수의 절반과 정확하게 일치하는 서브 배열의 개수를 구하는 문제
- 배열을 돌면서 중간 수가 짝수이면서 처음과 마지막 수를 더해 중간 수의 절반과 동일하면 값을 증가시키고 최종적으로 이렇게 구한 수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### 2962. Count Subarrays Where Max Element Appears at Least K Times ```MEDIUM```
- 정수 배열과 k가 주어졌을 때, 배열의 최대값을 k개 포함하는 서브 배열의 개수를 구하는 문제
- 먼저 배열에서 최댓값과 그 개수를 구하고 개수가 k보다 작은 경우는 바로 0을 반환합니다.
- 배열을 하나씩 확인하면서 해당 위치가 최댓값과 같은 경우 최댓값 개수를 증가시킵니다.
- 그리고 최댓값 개수가 k보다 크거나 같은 경우 반복적으로 배열의 왼쪽 값을 확인해 최댓값과 같은 경우 최댓값 개수를 감소시키고 왼쪽 값을 하나씩 증가시켜 반복적으로 확인합니다.
- 그런 다음 최댓값 개수가 k보다 작아졌을 때 이때 왼쪽 인덱스를 최종 결과에 더합니다.
  + left는 항상 현재 right에 대해 조건을 만족하는 최소 left 인덱스입니다.
  + 즉, right가 고정되었을 때:
    - [0, right], [1, right], ..., [left-1, right]까지가 조건을 만족하지 않는 모든 구간들입니다.
    - 이 구간의 개수는 정확히 left개입니다.
- 시간 복잡도: O(n) (n <= 100000)

### ```EASY```

