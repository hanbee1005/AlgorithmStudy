# 문제 풀이

### 2460. Apply Operations to an Array ```EASY```
- 배열이 주어졌을 때, nums[i] == nums[i+1]과 같을 때 nums[i] 값은 2를 곱하고 nums[i+1]은 0으로 변경한 뒤 최종적으로 0을 제일 뒤로 몬 배열을 반환하는 문제
- 먼저 배열을 돌면서 nums[i] == nums[i+1]과 같을 때 nums[i] 값은 2를 곱하고 nums[i+1]은 0으로 변경합니다.
- 그리고 정답 배열을 생성한 뒤, idx = 0을 지정하고 이전 배열을 돌면서 0이 아닌 경우 idx 위치에 넣은 뒤 idx를 증가시킵니다.
- 이후 정답 배열을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 2000)

### 2873. Maximum Value of an Ordered Triplet I ```EASY```
- 정수 배열이 주어졌을 때, `(nums[i] - nums[j]) * nums[k]` (i < j < k) 의 최대값을 구하는 문제 (만약 모두 음수이면 0을 반환)
- imax: 지금까지 만난 수 중 가장 큰 수를 기억합니다. → a 후보
- dmax: 지금까지 가능한 (a - b) 값 중 최댓값을 저장합니다. → (a - b) 후보
- answer: 최종적으로 찾고자 하는 (a - b) * c 의 최댓값을 계속 갱신합니다.
- 배열을 순회하면서
  + answer = max(answer, dmax * num) → 지금까지 구한 (a - b) 최대값과 현재 값 c = num을 곱해서 (a - b) * c 값을 계산해보고, answer를 갱신합니다.
  + dmax = max(dmax, imax - num) → 현재 수를 b라고 생각하고, 이전까지 봤던 가장 큰 수 imax를 a라고 보면, (a - b) 값이 나옵니다. → 이걸 이용해서 dmax를 갱신합니다.
  + imax = max(imax, num) → 현재 값을 기준으로, 지금까지 본 수 중 가장 큰 값을 계속 갱신합니다.
- 이렇게 구한 answer를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (3 <= n <= 100)

### 416. Partition Equal Subset Sum ```MEDIUM```
- 배열이 주어졌을 때 2개의 서브 배열의 합이 같은 경우 true, 아닌 경우 false를 반환하는 문제
- 배열의 전체 합을 계산합니다.
- 두 부분으로 나누려면 총합이 짝수여야 가능하므로, 합이 홀수면 바로 false를 반환합니다.
- dp 배열을 생성하고 초기화 합니다.
  + dp[i]는 합이 i인 부분 집합이 존재하는가를 의미합니다.
  + dp[0] = true는 "합이 0인 부분집합(공집합)은 항상 존재한다"는 의미입니다.
  + dp의 크기를 10001로 잡은 이유는, 문제에서 주어질 수 있는 최대 합을 고려한 것 같습니다.
- 그리고 부분 집합을 탐색합니다.
  + 각 숫자 num에 대해, 가능한 모든 j에 대해 dp[j]를 업데이트합니다.
  + dp[j - num] == true면, dp[j]도 true가 될 수 있습니다. 즉, j라는 합은 num을 더해서 만들 수 있다는 뜻입니다.
  + j를 거꾸로 순회하는 이유는 한 num으로 여러 번 같은 수를 더하는 것을 방지하기 위해서입니다 (1번만 써야 함).
- 최종적으로 전체 합의 절반(sum / 2)을 만들 수 있는 부분집합이 존재하면, 두 부분으로 나눌 수 있으므로 true를 반환합니다.
- 시간 복잡도: O(N) (N <= 200)

### ```EASY```

