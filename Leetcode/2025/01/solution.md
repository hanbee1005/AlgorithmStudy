# 문제 풀이

### 1422. Maximum Score After Splitting a String ```EASY```
- 0과 1로 이루어진 문자열이 주어졌을 때 문자열을 2개로 나눠 왼쪽에서는 0, 오른쪽에서는 1의 개수를 합해 최대를 구하는 문제
- 왼쪽에서의 0의 개수, 오른쪽에서의 1의 개수를 담을 수 있는 변수를 선언합니다.
- 빈 문자열을 허용하지 않기 때문에 첫글자가 0인 경우 왼쪽 0의 개수를 1 증가시키고 문자열의 1번 문자부터 확인하면서 1인 경우 오른쪽 1의 개수를 증가시킵니다.
- 이후 초기 maxScore를 확인합니다. (이전에 구한 왼쪽 0의 개수 + 오른쪽 1의 개수)
- 문자열을 1번부터 마지막 문자 전까지 확인하면서 0인 경우 왼쪽 0의 개수를 증가시키고 1인 경우 오른쪽 1의 개수를 감소시킨 뒤, 그 합을 이전 maxScore와 비교하여 더 큰 수를 저장할 수 있도록 합니다.
- 최종적으로 maxScore를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 500)

### 2559. Count Vowel Strings in Ranges ```MEDIUM```
- 문자열 배열과 인덱스 범위가 주어졌을 때 인덱스 범위 내 문자 중 시작과 끝이 모음으로 이루어진 문자의 개수를 담은 배열을 반환하는 문제
- 미리 각 인덱스까지의 개수를 구하는 배열을 선언하고 처음 문자부터 끝 문자까지 확인하면서 개수를 저장합니다.
- 이후 인덱스 범위를 확인하면서 (뒷 인덱스 + 1 의 문자 개수) - (시작 인덱스의 문자 개수)를 결과 배역에 저장한 뒤 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100000)

### 2270. Number of Ways to Split Array ```MEDIUM```
- 배열 nums를 두 개의 연속된 부분 배열로 나누는 방법 중에서 왼쪽 부분 배열의 합이 오른쪽 부분 배열의 합보다 크거나 같은 경우의 개수를 반환하는 문제
- 전체 합 계산 (rightSum)
  + rightSum을 구하기 위해 nums 배열의 모든 원소를 더합니다.
- 왼쪽 부분 배열 (leftSum)과 오른쪽 부분 배열 (rightSum)을 업데이트하면서 조건 체크
  + leftSum을 0부터 시작하고, 한 요소씩 추가해 나갑니다.
  + rightSum은 해당 요소를 제거하면서 감소시킵니다.
  + leftSum >= rightSum 조건을 만족하면 validSplits를 증가시킵니다.
  + 마지막 인덱스에서는 나눌 수 없으므로 i < nums.length - 1까지만 탐색합니다.
- 시간 복잡도: O(n) (n <= 100000)

### ```EASY```



