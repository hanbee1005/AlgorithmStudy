# 문제 풀이

### 1422. Maximum Score After Splitting a String ```EASY```
- 0과 1로 이루어진 문자열이 주어졌을 때 문자열을 2개로 나눠 왼쪽에서는 0, 오른쪽에서는 1의 개수를 합해 최대를 구하는 문제
- 왼쪽에서의 0의 개수, 오른쪽에서의 1의 개수를 담을 수 있는 변수를 선언합니다.
- 빈 문자열을 허용하지 않기 때문에 첫글자가 0인 경우 왼쪽 0의 개수를 1 증가시키고 문자열의 1번 문자부터 확인하면서 1인 경우 오른쪽 1의 개수를 증가시킵니다.
- 이후 초기 maxScore를 확인합니다. (이전에 구한 왼쪽 0의 개수 + 오른쪽 1의 개수)
- 문자열을 1번부터 마지막 문자 전까지 확인하면서 0인 경우 왼쪽 0의 개수를 증가시키고 1인 경우 오른쪽 1의 개수를 감소시킨 뒤, 그 합을 이전 maxScore와 비교하여 더 큰 수를 저장할 수 있도록 합니다.
- 최종적으로 maxScore를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 500)

### 2559. Count Vowel Strings in Ranges ```MEDIUM```
- 문자열 배열과 인덱스 범위가 주어졌을 때 인덱스 범위 내 문자 중 시작과 끝이 모음으로 이루어진 문자의 개수를 담은 배열을 반환하는 문제
- 미리 각 인덱스까지의 개수를 구하는 배열을 선언하고 처음 문자부터 끝 문자까지 확인하면서 개수를 저장합니다.
- 이후 인덱스 범위를 확인하면서 (뒷 인덱스 + 1 의 문자 개수) - (시작 인덱스의 문자 개수)를 결과 배역에 저장한 뒤 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100000)

### 2270. Number of Ways to Split Array ```MEDIUM```
- 배열 nums를 두 개의 연속된 부분 배열로 나누는 방법 중에서 왼쪽 부분 배열의 합이 오른쪽 부분 배열의 합보다 크거나 같은 경우의 개수를 반환하는 문제
- 전체 합 계산 (rightSum)
  + rightSum을 구하기 위해 nums 배열의 모든 원소를 더합니다.
- 왼쪽 부분 배열 (leftSum)과 오른쪽 부분 배열 (rightSum)을 업데이트하면서 조건 체크
  + leftSum을 0부터 시작하고, 한 요소씩 추가해 나갑니다.
  + rightSum은 해당 요소를 제거하면서 감소시킵니다.
  + leftSum >= rightSum 조건을 만족하면 validSplits를 증가시킵니다.
  + 마지막 인덱스에서는 나눌 수 없으므로 i < nums.length - 1까지만 탐색합니다.
- 시간 복잡도: O(n) (n <= 100000)

### 1930. Unique Length-3 Palindromic Subsequences ```MEDIUM```
- 문자열 s에서 길이가 3인 팰린드롬 부분 수열의 개수를 구하는 문제
- 각 알파벳 문자('a' ~ 'z')에 대해 루프 실행
  + 문자열에서 각 알파벳 문자가 포함된 위치를 찾기 위해 루프 실행 (26번 반복).
- 현재 문자의 첫 번째(first)와 마지막(last) 등장 위치 찾기
  + first: 해당 문자가 문자열에서 처음 등장하는 위치.
  + last: 해당 문자가 문자열에서 마지막으로 등장하는 위치.
- 문자가 존재하고(first != -1), first < last일 때만 진행
  + 같은 문자가 최소 2번 이상 등장해야 (c, x, c) 형태의 팰린드롬을 만들 수 있음.
- 첫 번째 등장과 마지막 등장 사이의 문자들을 HashSet에 저장
  + first + 1부터 last - 1까지 중복 없이 문자들을 set에 저장하여 유일한 x의 개수를 셈.
- 각 문자별로 가능한 팰린드롬 개수를 결과값에 추가
  + set.size()는 (c, x, c) 형태로 만들 수 있는 서로 다른 팰린드롬 개수를 의미.
- 시간 복잡도: O(n) (n <= 100000)

### 1769. Minimum Number of Operations to Move All Balls to Each Box ```MEDIUM```
- boxes라는 문자열을 입력으로 받아, 각 위치마다 공을 이동하는 데 필요한 최소 연산 수를 계산하는 문제
- 입력 처리 및 변수 초기화
  + ch : boxes 문자열을 문자 배열로 변환.
  + n : 문자열의 길이.
  + right : 오른쪽(i > 0)에 있는 공('1')의 개수.
  + left : 왼쪽(i < 0)에 있는 공('1')의 개수.
  + all : 현재 위치(i = 0)에서 공을 이동하는 총 비용.
- 첫 번째 for문 (공의 초기 이동 비용 계산)
  + all: 모든 '1' 공을 i = 0 위치로 이동하는 데 필요한 총 이동 횟수를 저장.
  + right: 오른쪽(i ≥ 0)에 있는 '1'의 개수를 저장.
- 첫 번째 위치(i = 0)의 결과값 저장
  + 첫 번째 위치에서 모든 공을 0번 인덱스로 이동하는 비용(all)을 answer[0]에 저장.
  + ch[0] == '1'이면, left를 증가시키고 right를 감소시켜 다음 단계에서의 균형을 유지.
- 두 번째 for문 (각 위치별 최소 이동 연산 계산)
  + 이 루프는 all 값을 업데이트하면서 최소 연산 수를 계산하는 핵심 부분입니다.
    - all = all - right: 모든 공이 i번째 위치로 이동할 때, 오른쪽에 있는 공들은 1칸 덜 움직이면 되므로 총 이동 비용이 감소.
    - all = all + left: 반대로, 왼쪽에 있는 공들은 1칸 더 움직여야 하므로 총 이동 비용이 증가.
    - ch[i] == '1'이면 left++ 및 right-- 업데이트.
- 이렇게 구한 answer 배열을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 2000)

### 1408. String Matching in an Array ```EASY```
- 문자열 배열이 주어졌을 때, 다른 문자열에 포함된 문자열 목록을 반환하는 문제
- 먼저 주어진 문자열 배열을 길이가 짧은 순서대로 정렬합니다.
- 이후 처음 문자부터 하나씩 다음 인덱스와 비교하면서 해당 문자열이 포함되어 있는지 확인합니다.
- 포함되어 있는 경우 해당 문자열을 정답 리스트에 추가한 뒤, 바로 다음 문자를 이어서 확인합니다.
- 이렇게 확인한 정답 리스트를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n^2) (n <= 100)

### 3042. Count Prefix and Suffix Pairs I ```EASY```
- 문자열 배열이 주어졌을 때, 앞에 있는 문자가 뒷 문자의 시작과 끝에 해당하는 경우의 수를 구하는 문제
- 이차원 배열을 순회하면서 앞문자열과 뒷문자열을 비교하는데 앞 문자열의 길이가 뒷 문자열의 길이보다 더 큰 경우는 패스합니다.
- 그렇지 않은 경우 뒷 문자열이 앞 문자열로 시작하고 끝나는지 확인하여 개수를 증가시킵니다.
- 최종적으로 구한 개수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n^2) (n <= 50)

### 2185. Counting Words With a Given Prefix ```EASY```
- 문자열 배열과 prefix가 주어졌을 때 prefix로 시작하는 문자열의 개수를 구하는 문제
- 문자열 배열을 하나씩 돌면서 해당 문자가 prefix로 시작하는지 ```startsWith()``` 확인하고 true인 경우 카운트를 하나씩 증가시킨 뒤
- 최종적으로 구한 카운트를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### 3223. Minimum Length of String After Operations ```MEDIUM```
- 문자열이 주어졌을 때 왼쪽과 오른쪽에 같은 문자를 가지는 i를 찾아 가장 가까운 왼쪽, 오른쪽 문자를 지우는 작업을 반복하고 반복할 수 없을 때의 문자열 길이를 구하는 문제
- 어떤 문자열이 남는지가 아니라 문자열의 길이를 구하는 것이기 때문에 
- 먼저 알파벳을 담을 수 있는 길이가 26인 배열을 만들고
- 문자열을 돌면서 특정 문자의 개수를 세 위에서 만든 배열에 추가합니다.
- 이후 해당 문자가 2번 이하로 나온 경우는 없앨 수 없으므로 모두 최종 길이에 추가하고
- 2 초과 짝수인 경우는 2개씩 빼고 결국 2개가 남을 것이므로 2를 더하고
- 2 초과 홀수인 경우는 2개씩 빼고 결국 1개가 남을 것이므로 1을 더합니다.
- 이렇게 구한 길이를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 200000)

### 2657. Find The Prefix Common Array of Two Arrays ```MEDIUM```
- 두 정수 배열이 주어졌을 때, 각 인덱스 별 이전에 중복된 숫자가 나온 개수를 구해 배열로 반환하는 문제
- 주어진 배열의 길이만큼 정답 배열을 만들고 길이보다 작거나 같은 숫자가 나올 것이므로 해당 숫자를 인덱스로 가지는 수를 저장할 수 있는 cnt 배열을 생성합니다.
- 이후 배열을 반복하면서 A[i]가 나온 개수가 2와 같은 경우 지금까지 나온 중복된 수를 증가시키고 B[i]가 나온 개수가 2와 같은 경우도 지금까지 나온 중복된 수를 증가시킨 다음
- 지금까지 나온 중복된 수를 정답 배열의 현재 인덱스에 저장합니다.
- 이렇게 구한 정답 배열을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 50)

### 2429. Minimize XOR ```MEDIUM```
- 두 정수 num1과 num2를 기반으로 최소 XOR 값을 가지는 숫자를 구하는 문제
- bitCount 사용
  + `Integer.bitCount(x)`: `x`의 이진 표현에서 1의 개수를 반환합니다.
  + `a`는 `num1`의 1의 개수, `b`는 `num2`의 1의 개수를 의미합니다.
- num1을 기반으로 최소 XOR 값을 가지는 값 찾기
  + `answer`를 `num1`로 초기화합니다.
- 32비트 반복문을 통해 조정
  + `num1`은 최대 32비트 정수이므로, 모든 비트를 확인하기 위해 0부터 31까지 반복합니다.
  + `num1`의 1의 개수가 `num2`보다 많다면 줄이기
    - `num1`의 1 개수(a)가 `num2`보다 많다면, `num1`에서 1을 제거해야 합니다.
    - `(1 << i) & num1`을 이용해 현재 i번째 비트가 1인지 확인하고, 1이면 XOR 연산(`^=`)을 사용하여 해당 비트를 0으로 만듭니다.
    - 1을 제거했으므로 `a--`.
  + `num1`의 1의 개수가 `num2`보다 적다면 추가하기
    - `num1`의 1 개수(a)가 `num2`보다 적다면, 1을 추가해야 합니다.
    - `(1 << i) & num1 == 0`을 이용해 현재 i번째 비트가 0인지 확인하고, 0이면 XOR 연산(`^=`)을 사용하여 해당 비트를 1로 만듭니다.
    - 1을 추가했으므로 `a++`.
- 변환된 `answer` 값을 반환합니다.
- 시간 복잡도: O(1)

### 2425. Bitwise XOR of All Pairings ```MEDIUM```
- 두 개의 정수 배열이 주어졌을 때, 각 배열의 각각의 수를 모두 pair 하여 xor 연산을 한 뒤 결과를 모두 xor한 값을 구하는 문제
- 풀어서 생각해보면 num1의 각 숫자를 num2의 개수만큼 xor 하고 num2의 각 숫자를 num1의 개수만큼 xor 하는 것입니다.
- 따라서 반대편 정수 배열의 길이가 짝수인 경우에는 xor 연산을 해도 결국 0이 됩니다.
- 그러므로 반대편 정수 배열의 길이가 홀수일 때 해당 배열의 모든 수를 xor 연산하고 반대쪽도 확인하여 xor 연산한 뒤 반환하면 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100000)

### 2661. First Completely Painted Row or Column ```MEDIUM```
- arr 배열과 mat 이차원 배열이 주어졌을 때, arr 배열의 숫자를 mat 배열에서 찾아 색칠할 때 row, col 상관없이 한줄이 모두 칠해지는 가장 작은 arr 수의 인덱스를 구하는 문제
- 이차원 배열 mat 에 해당하는 숫자의 row, col 인덱스를 각각 저장할 배열 2개를 만들어서 숫자에 해당하는 위치에 row, col 인덱스를 각각 저장합니다.
- arr 배열을 순회하면서 해당 숫자의 위치에서 row, col 인덱스를 찾고 해당 인덱스의 위치를 또 각각의 배열에 저장합니다.
- 해당 인덱스가 나온 값이 한 줄의 값과 같은 경우 이때의 arr 배열 인덱스를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100000)

### ```EASY```



