# 문제 풀이

### 1422. Maximum Score After Splitting a String ```EASY```
- 0과 1로 이루어진 문자열이 주어졌을 때 문자열을 2개로 나눠 왼쪽에서는 0, 오른쪽에서는 1의 개수를 합해 최대를 구하는 문제
- 왼쪽에서의 0의 개수, 오른쪽에서의 1의 개수를 담을 수 있는 변수를 선언합니다.
- 빈 문자열을 허용하지 않기 때문에 첫글자가 0인 경우 왼쪽 0의 개수를 1 증가시키고 문자열의 1번 문자부터 확인하면서 1인 경우 오른쪽 1의 개수를 증가시킵니다.
- 이후 초기 maxScore를 확인합니다. (이전에 구한 왼쪽 0의 개수 + 오른쪽 1의 개수)
- 문자열을 1번부터 마지막 문자 전까지 확인하면서 0인 경우 왼쪽 0의 개수를 증가시키고 1인 경우 오른쪽 1의 개수를 감소시킨 뒤, 그 합을 이전 maxScore와 비교하여 더 큰 수를 저장할 수 있도록 합니다.
- 최종적으로 maxScore를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 500)

### 2559. Count Vowel Strings in Ranges ```MEDIUM```
- 문자열 배열과 인덱스 범위가 주어졌을 때 인덱스 범위 내 문자 중 시작과 끝이 모음으로 이루어진 문자의 개수를 담은 배열을 반환하는 문제
- 미리 각 인덱스까지의 개수를 구하는 배열을 선언하고 처음 문자부터 끝 문자까지 확인하면서 개수를 저장합니다.
- 이후 인덱스 범위를 확인하면서 (뒷 인덱스 + 1 의 문자 개수) - (시작 인덱스의 문자 개수)를 결과 배역에 저장한 뒤 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100000)

### 2270. Number of Ways to Split Array ```MEDIUM```
- 배열 nums를 두 개의 연속된 부분 배열로 나누는 방법 중에서 왼쪽 부분 배열의 합이 오른쪽 부분 배열의 합보다 크거나 같은 경우의 개수를 반환하는 문제
- 전체 합 계산 (rightSum)
  + rightSum을 구하기 위해 nums 배열의 모든 원소를 더합니다.
- 왼쪽 부분 배열 (leftSum)과 오른쪽 부분 배열 (rightSum)을 업데이트하면서 조건 체크
  + leftSum을 0부터 시작하고, 한 요소씩 추가해 나갑니다.
  + rightSum은 해당 요소를 제거하면서 감소시킵니다.
  + leftSum >= rightSum 조건을 만족하면 validSplits를 증가시킵니다.
  + 마지막 인덱스에서는 나눌 수 없으므로 i < nums.length - 1까지만 탐색합니다.
- 시간 복잡도: O(n) (n <= 100000)

### 1930. Unique Length-3 Palindromic Subsequences ```MEDIUM```
- 문자열 s에서 길이가 3인 팰린드롬 부분 수열의 개수를 구하는 문제
- 각 알파벳 문자('a' ~ 'z')에 대해 루프 실행
  + 문자열에서 각 알파벳 문자가 포함된 위치를 찾기 위해 루프 실행 (26번 반복).
- 현재 문자의 첫 번째(first)와 마지막(last) 등장 위치 찾기
  + first: 해당 문자가 문자열에서 처음 등장하는 위치.
  + last: 해당 문자가 문자열에서 마지막으로 등장하는 위치.
- 문자가 존재하고(first != -1), first < last일 때만 진행
  + 같은 문자가 최소 2번 이상 등장해야 (c, x, c) 형태의 팰린드롬을 만들 수 있음.
- 첫 번째 등장과 마지막 등장 사이의 문자들을 HashSet에 저장
  + first + 1부터 last - 1까지 중복 없이 문자들을 set에 저장하여 유일한 x의 개수를 셈.
- 각 문자별로 가능한 팰린드롬 개수를 결과값에 추가
  + set.size()는 (c, x, c) 형태로 만들 수 있는 서로 다른 팰린드롬 개수를 의미.
- 시간 복잡도: O(n) (n <= 100000)

### 1769. Minimum Number of Operations to Move All Balls to Each Box ```MEDIUM```
- boxes라는 문자열을 입력으로 받아, 각 위치마다 공을 이동하는 데 필요한 최소 연산 수를 계산하는 문제
- 입력 처리 및 변수 초기화
  + ch : boxes 문자열을 문자 배열로 변환.
  + n : 문자열의 길이.
  + right : 오른쪽(i > 0)에 있는 공('1')의 개수.
  + left : 왼쪽(i < 0)에 있는 공('1')의 개수.
  + all : 현재 위치(i = 0)에서 공을 이동하는 총 비용.
- 첫 번째 for문 (공의 초기 이동 비용 계산)
  + all: 모든 '1' 공을 i = 0 위치로 이동하는 데 필요한 총 이동 횟수를 저장.
  + right: 오른쪽(i ≥ 0)에 있는 '1'의 개수를 저장.
- 첫 번째 위치(i = 0)의 결과값 저장
  + 첫 번째 위치에서 모든 공을 0번 인덱스로 이동하는 비용(all)을 answer[0]에 저장.
  + ch[0] == '1'이면, left를 증가시키고 right를 감소시켜 다음 단계에서의 균형을 유지.
- 두 번째 for문 (각 위치별 최소 이동 연산 계산)
  + 이 루프는 all 값을 업데이트하면서 최소 연산 수를 계산하는 핵심 부분입니다.
    - all = all - right: 모든 공이 i번째 위치로 이동할 때, 오른쪽에 있는 공들은 1칸 덜 움직이면 되므로 총 이동 비용이 감소.
    - all = all + left: 반대로, 왼쪽에 있는 공들은 1칸 더 움직여야 하므로 총 이동 비용이 증가.
    - ch[i] == '1'이면 left++ 및 right-- 업데이트.
- 이렇게 구한 answer 배열을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 2000)

### 1408. String Matching in an Array ```EASY```
- 문자열 배열이 주어졌을 때, 다른 문자열에 포함된 문자열 목록을 반환하는 문제
- 먼저 주어진 문자열 배열을 길이가 짧은 순서대로 정렬합니다.
- 이후 처음 문자부터 하나씩 다음 인덱스와 비교하면서 해당 문자열이 포함되어 있는지 확인합니다.
- 포함되어 있는 경우 해당 문자열을 정답 리스트에 추가한 뒤, 바로 다음 문자를 이어서 확인합니다.
- 이렇게 확인한 정답 리스트를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n^2) (n <= 100)

### 3042. Count Prefix and Suffix Pairs I ```EASY```
- 문자열 배열이 주어졌을 때, 앞에 있는 문자가 뒷 문자의 시작과 끝에 해당하는 경우의 수를 구하는 문제
- 이차원 배열을 순회하면서 앞문자열과 뒷문자열을 비교하는데 앞 문자열의 길이가 뒷 문자열의 길이보다 더 큰 경우는 패스합니다.
- 그렇지 않은 경우 뒷 문자열이 앞 문자열로 시작하고 끝나는지 확인하여 개수를 증가시킵니다.
- 최종적으로 구한 개수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n^2) (n <= 50)

### 2185. Counting Words With a Given Prefix ```EASY```
- 문자열 배열과 prefix가 주어졌을 때 prefix로 시작하는 문자열의 개수를 구하는 문제
- 문자열 배열을 하나씩 돌면서 해당 문자가 prefix로 시작하는지 ```startsWith()``` 확인하고 true인 경우 카운트를 하나씩 증가시킨 뒤
- 최종적으로 구한 카운트를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### ```EASY```



