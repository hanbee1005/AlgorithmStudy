# 문제 풀이

### 3342. Find Minimum Time to Reach Last Room II ```MEDIUM```
- n x m 배열이 주어졌을 때, (n-1, m-1) 까지 도달하는데 걸리는 최소 시간을 구하는 문제
- 상하좌우 4방향을 나타내는 DIRS 변수를 생성합니다.
- 우선 순위 큐를 다음과 같은 형태로 생성 후 초기화 합니다.
  + heap: 우선순위 큐 (min-heap), (flattened index, time, parity) 형태.
  + 초기에는 (0,0)에서 시간 0, 홀수 타이밍(1)으로 시작합니다.
- `moveTime[rr][cc] = -1;`
  + 방문 체크를 위해 -1로 마킹합니다. 방문한 셀은 다시 처리하지 않습니다 (visited set 대용).
- `int newTime = Math.max(time, moveTime[rr][cc]) + odd;`
  + 현재 시간 또는 목적지 셀의 제한 시간 중 큰 값을 고려하고, 홀짝 조정 시간(odd)을 더합니다.
  + odd 값은 1과 2를 번갈아가며 적용됩니다. 이동 시 한 번은 1, 다음은 2를 번갈아 쓰는 구조입니다.
- 전체적인 흐름을 보면 다음과 같습니다.
  + 시작점(0,0)을 큐에 삽입
  + 큐에서 가장 이른 도달 가능한 노드를 꺼냄
  + 인접한 방향을 순회
  + 아직 방문하지 않은 노드라면:
    - 도달 가능 시간(newTime)을 계산
    - 목적지라면 newTime 반환
    - 아니라면 큐에 삽입하고 해당 노드를 -1로 마킹
- 시간 복잡도: O(mn * log(mn)) (n,m <= 750)

### 2094. Finding 3-Digit Even Numbers ```EASY```
- 주어진 digits 배열에서 3개의 수를 뽑아 중복되지 않는 3자리 짝수를 만들어 오름차순으로 정렬해 반환하는 문제
- 먼저 주어진 digits에서 각 숫자별로 몇개가 나왔는지를 계산해 count 배열에 저장해둡니다.
- 그리고 3중 for 문을 돌면서 처음 for 문은 1부터 9까지 돌면서 해당 숫자의 count 가 0이 아닌 경우 하나를 감소시키고 다음 for 문을 확인합니다. 
- 2번째 for 문은 0부터 9까지 돌면서 동일하게 해당 숫자의 count가 0이 아닌 경우 하나를 감소기키고 마지막 for 문을 확인합니다.
- 마지막 for 문에서는 0부터 9까지 2씩 증가시키면서 해당 숫자의 count가 0이 아닌 경우 `i * 100 + j * 10 + k`로 숫자를 구해 저장한 뒤, for 문을 빠져나오면서 앞서 감소시킨 숫자들의 count를 다시 원복시킵니다.
- 최종적으로 구한 숫자 배열을 값이 있는 경우만 잘라서 반환하면 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n^3) (n <= 10)

### 2900. Longest Unequal Adjacent Groups Subsequence I ```EASY```
- 문자 배열과 0,1 로 이루어진 정수 배열이 주어졌을 때, 정수 배열에서 앞뒤로 겹치지 않는 최대 길이의 배열에 해당 인덱스에 해당하는 문자 배열을 반환하는 문제
- 먼저 문자의 제일 처음 값을 정답 리스트에 추가합니다.
- 이후 index 1부터 정수배열을 돌면서 해당 인덱스와 이전 인덱스를 비교해서 다르면 해당 인덱스의 문자를 정답 배열에 추가합니다.
  + 0과 1로만 이루어져 있기 때문에 이전 값과 비교해서 같다면 이전 값도 정답에 포함되지 않았다고 확신할 수 있고 정답에 포함된 마지막 인덱스는 현재 인덱스의 값이랑도 같음이 보장됩니다.
  + 또한 이전 값이 현재랑 다르다면 이전 값이 정답에 포함되었든 아니든 정답에 포함된 마지막 수는 현재랑 다를 것이기 때문에 현재값을 바로 정답 배열에 추가해도 됩니다.
- 이후 정답 배열을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O()

### 3024. Type of Triangle ```EASY```
- 3개의 정수가 주어졌을 때 3변이 모두 같으면 "equilateral", 2변이 같고 삼각형을 만들 수 있으면 "isosceles", 3변이 모두 다른 삼각형을 만들 수 있으면 "scalene", 삼각형을 만들 수 없으면 "none"을 반환하는 문제
- 3변이 같은 경우 바로 "equilateral"를 반환합니다.
- 2변이 같고 같은 두 변의 길이의 합이 남은 한 변의 길이보다 긴 경우 "isosceles"를 반환합니다.
- 마지막으로 아무 2변의 길이의 합이 남은 한 변의 길이보다 긴 경우 "scalene"를 반환하고 위 경우에 해당하지 않는다면 "none"을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(1)

### ```EASY```
