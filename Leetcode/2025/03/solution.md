# 문제 풀이

### 1780. Check if Number is a Sum of Powers of Three ```EASY```
- 정수 n이 여러 개의 서로 다른 3의 거듭제곱(예: 3^0, 3^1, 3^2, …)의 합으로 표현될 수 있는지 확인하는 문제
- n을 3으로 계속 나눈 나머지를 검사하면서, 나머지가 2인 경우가 한 번이라도 있으면 거짓(false)을, 한 번도 없으면 참(true)을 반환하여 문제를 해결할 수 있습니다.
- 3진법(ternary) 표기 관점
  + 어떤 수가 서로 다른 3의 거듭제곱들의 합으로 표현 가능하다는 것은, 3진수로 변환했을 때 각 자리의 숫자가 0 또는 1만 존재함을 의미합니다. (예: 1×3^2 + 1×3^0 → 3진수 101)
  + 만약 3진수 변환 시 자릿수 중 하나라도 2가 나오면, 3^k 항을 2개 사용했다는 뜻이 되므로 “서로 다른 3의 거듭제곱 합”이 될 수 없습니다.
- 따라서
  + while (n > 0):
    - n % 3 값이 2인지 확인. → 2라면 즉시 false 반환
    -  그렇지 않다면 n /= 3로 3을 나눈 몫으로 갱신
  + 모든 자리(나머지 검사)가 끝날 때까지 2가 나오지 않으면 true 반환.
- 시간 복잡도: O(log₃ n) (n <= 10^7)

### 2579. Count Total Number of Colored Cells ```MEDIUM```
- 1분마다 변을 맞댄 주변 사각형이 물든다고 했을 때, n분 뒤 물든 사각형의 개수를 구하는 문제
- 시간이 지날수록 1, 5, 13, 25, ... 이렇게 변화하는데 이것은 1, 1 + 2 * 2 * 1, 1 + 2 * 3 * 2, 1 + 2 * 4 * 3 입니다.
- 위 내용을 식으로 작성하면 ```1 + (long) 2 * n * (n - 1)``` 이렇게 됩니다.
- 시간 복잡도: O(1)

### 2965. Find Missing and Repeated Values ```EASY```
- 이차원 배열이 주어졌을 때, 2번 나온 수와 한번도 안나온 수를 찾아 배열로 반환하는 문제
- 해당 수를 인덱스로 하는 배열을 생성한 뒤, 주어진 2차원 배열을 순회하면서 해당하는 숫자 인덱스의 카운트를 증가시킵니다.
- 그리고 해당 배열을 순회하면서 2번 나온 수를 [0]번 값으로 저장하고 0번 나온 수를 [1]번 값으로 저장하여 반환하면 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n * n) (n <= 50)

### 2523. Closest Prime Numbers in Range ```MEDIUM```
- left와 right 사이의 차이가 가장 적은 소수 2개를 배열로 반환하는 문제
- left와 right 사이의 수를 하나씩 확인하면서 소수인지 확인합니다.
  + 2로 나눈 나머지가 0이고 2보다 크다면 2의 배수이므로 바로 다음 수를 확인합니다.
  + 그렇지 않다면 해당 수를 2부터 해당 수의 절반인 수까지 증가시키며 나누어 떨어지는지 확인하고 나누어 떨어지는 경우 소수가 아니고 나누어 떨어지지 않으면 소수임을 확인합니다.
- 소수인 경우, 만약 이전에 찾은 소수의 마지막 수와 현재 소수와의 차가 2 이하라면 바로 해당 두 소수를 반환하여 문제를 해결할 수 있습니다.
- 그렇지 않다면 소수 리스트에 추가하고 다음 수를 확인합니다.
- 이렇게 left, right 사이의 모든 소수를 확인한 다음 소수의 개수가 2 미만이라면 바로 {-1, -1}을 반환합니다.
- 그렇지 않다면 소수 리스트를 순회하면서 앞뒤 수의 차이를 확인하고 최소 차이가 난다면 해당 두 소수를 배열로 만들어 반환해 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000000)

### ```EASY```

