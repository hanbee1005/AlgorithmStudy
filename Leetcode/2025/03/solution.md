# 문제 풀이

### 1780. Check if Number is a Sum of Powers of Three ```EASY```
- 정수 n이 여러 개의 서로 다른 3의 거듭제곱(예: 3^0, 3^1, 3^2, …)의 합으로 표현될 수 있는지 확인하는 문제
- n을 3으로 계속 나눈 나머지를 검사하면서, 나머지가 2인 경우가 한 번이라도 있으면 거짓(false)을, 한 번도 없으면 참(true)을 반환하여 문제를 해결할 수 있습니다.
- 3진법(ternary) 표기 관점
  + 어떤 수가 서로 다른 3의 거듭제곱들의 합으로 표현 가능하다는 것은, 3진수로 변환했을 때 각 자리의 숫자가 0 또는 1만 존재함을 의미합니다. (예: 1×3^2 + 1×3^0 → 3진수 101)
  + 만약 3진수 변환 시 자릿수 중 하나라도 2가 나오면, 3^k 항을 2개 사용했다는 뜻이 되므로 “서로 다른 3의 거듭제곱 합”이 될 수 없습니다.
- 따라서
  + while (n > 0):
    - n % 3 값이 2인지 확인. → 2라면 즉시 false 반환
    -  그렇지 않다면 n /= 3로 3을 나눈 몫으로 갱신
  + 모든 자리(나머지 검사)가 끝날 때까지 2가 나오지 않으면 true 반환.
- 시간 복잡도: O(log₃ n) (n <= 10^7)

### 2579. Count Total Number of Colored Cells ```MEDIUM```
- 1분마다 변을 맞댄 주변 사각형이 물든다고 했을 때, n분 뒤 물든 사각형의 개수를 구하는 문제
- 시간이 지날수록 1, 5, 13, 25, ... 이렇게 변화하는데 이것은 1, 1 + 2 * 2 * 1, 1 + 2 * 3 * 2, 1 + 2 * 4 * 3 입니다.
- 위 내용을 식으로 작성하면 ```1 + (long) 2 * n * (n - 1)``` 이렇게 됩니다.
- 시간 복잡도: O(1)

### 2965. Find Missing and Repeated Values ```EASY```
- 이차원 배열이 주어졌을 때, 2번 나온 수와 한번도 안나온 수를 찾아 배열로 반환하는 문제
- 해당 수를 인덱스로 하는 배열을 생성한 뒤, 주어진 2차원 배열을 순회하면서 해당하는 숫자 인덱스의 카운트를 증가시킵니다.
- 그리고 해당 배열을 순회하면서 2번 나온 수를 [0]번 값으로 저장하고 0번 나온 수를 [1]번 값으로 저장하여 반환하면 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n * n) (n <= 50)

### 2523. Closest Prime Numbers in Range ```MEDIUM```
- left와 right 사이의 차이가 가장 적은 소수 2개를 배열로 반환하는 문제
- left와 right 사이의 수를 하나씩 확인하면서 소수인지 확인합니다.
  + 2로 나눈 나머지가 0이고 2보다 크다면 2의 배수이므로 바로 다음 수를 확인합니다.
  + 그렇지 않다면 해당 수를 2부터 해당 수의 절반인 수까지 증가시키며 나누어 떨어지는지 확인하고 나누어 떨어지는 경우 소수가 아니고 나누어 떨어지지 않으면 소수임을 확인합니다.
- 소수인 경우, 만약 이전에 찾은 소수의 마지막 수와 현재 소수와의 차가 2 이하라면 바로 해당 두 소수를 반환하여 문제를 해결할 수 있습니다.
- 그렇지 않다면 소수 리스트에 추가하고 다음 수를 확인합니다.
- 이렇게 left, right 사이의 모든 소수를 확인한 다음 소수의 개수가 2 미만이라면 바로 {-1, -1}을 반환합니다.
- 그렇지 않다면 소수 리스트를 순회하면서 앞뒤 수의 차이를 확인하고 최소 차이가 난다면 해당 두 소수를 배열로 만들어 반환해 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000000)

### 2379. Minimum Recolors to Get K Consecutive Black Blocks ```EASY```
- 'W'와 'B'로 이루어진 문자열이 주어졌을 때, k 개의 연속된 'B'를 만들기 위해 변경해야 하는 최소 'W'의 개수를 구하는 문제
- 먼저 0부터 k 까지 문자 중 'W'의 개수를 모두 구합니다.
- 그리고 k 길이의 문자열에서 첫 문자와 끝 문자가 다르고 첫 문자가 'W'라면 전체 'W'의 개수에서 하나를 빼고 아닌 경우 전체 'W'의 개수를 증가시킵니다.
- 그리고 최종 연산의 수가 현재 연산의 수보다 크다면 현재 연산의 수를 최종 연산의 수로 지정하고 최종 연산의 수가 0이라면 바로 반환합니다.
- 아니라면 다음 문자로 하나씩 미뤄서 위 과정을 거치고 최종적으로 최종 연산의 수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### 3306. Count of Substrings Containing Every Vowel and K Consonants II ```MEDIUM```
- word에서 모든 모음이 최소 한개 이상 포함되고 k개의 자음을 포함한 substring의 개수를 구하는 문제
- 변수 초기화
  + frequencies[0] 배열: 각 문자가 모음인지(1) 아닌지(0)를 저장.
  + frequencies[1] 배열: 현재 창(window) 내에서 등장한 모음의 개수를 저장.
- 투 포인터를 사용한 윈도우 슬라이딩
  + currentK: 현재 부분 문자열에서 포함된 자음의 개수.
  + vowels: 현재 부분 문자열에서 포함된 모음의 개수.
  + extraLeft: 중복된 모음이 존재할 때 왼쪽 포인터(left)를 추가로 이동할 때 사용.
- 오른쪽 포인터(right) 이동하며 윈도우 확장
  + right 포인터를 증가시키면서 새로운 문자를 창에 추가.
  + 현재 문자가 모음이면 frequencies[1]을 업데이트하고, 처음 등장하는 경우 vowels++ 증가.
  + 모음이 아닌 경우(자음) currentK++ 증가.
- 왼쪽 포인터(left) 이동하여 윈도우 조정
  + 현재 currentK > k이면 자음 개수를 k로 맞추기 위해 left를 증가시킴.
  + left 문자가 모음이면, frequencies[1]을 감소시키고, 해당 모음이 사라지면 vowels--.
  + left 문자가 자음이면, currentK--.
- 추가적인 left 이동으로 중복 모음 정리
  + 모든 모음이 포함(vowels == 5)되고 currentK == k이면 유효한 부분 문자열을 찾음.
  + 추가적으로 left를 이동해 중복된 모음을 정리하고 extraLeft 증가.
- 정답 업데이트
  + 현재 조건을 만족하는 경우 (1 + extraLeft)를 answer에 추가.
- 시간 복잡도: O(N) (N <= 2 * 10^5)

### ```EASY```

