# 문제 풀이

### 1780. Check if Number is a Sum of Powers of Three ```EASY```
- 정수 n이 여러 개의 서로 다른 3의 거듭제곱(예: 3^0, 3^1, 3^2, …)의 합으로 표현될 수 있는지 확인하는 문제
- n을 3으로 계속 나눈 나머지를 검사하면서, 나머지가 2인 경우가 한 번이라도 있으면 거짓(false)을, 한 번도 없으면 참(true)을 반환하여 문제를 해결할 수 있습니다.
- 3진법(ternary) 표기 관점
  + 어떤 수가 서로 다른 3의 거듭제곱들의 합으로 표현 가능하다는 것은, 3진수로 변환했을 때 각 자리의 숫자가 0 또는 1만 존재함을 의미합니다. (예: 1×3^2 + 1×3^0 → 3진수 101)
  + 만약 3진수 변환 시 자릿수 중 하나라도 2가 나오면, 3^k 항을 2개 사용했다는 뜻이 되므로 “서로 다른 3의 거듭제곱 합”이 될 수 없습니다.
- 따라서
  + while (n > 0):
    - n % 3 값이 2인지 확인. → 2라면 즉시 false 반환
    -  그렇지 않다면 n /= 3로 3을 나눈 몫으로 갱신
  + 모든 자리(나머지 검사)가 끝날 때까지 2가 나오지 않으면 true 반환.
- 시간 복잡도: O(log₃ n) (n <= 10^7)

### 2579. Count Total Number of Colored Cells ```MEDIUM```
- 1분마다 변을 맞댄 주변 사각형이 물든다고 했을 때, n분 뒤 물든 사각형의 개수를 구하는 문제
- 시간이 지날수록 1, 5, 13, 25, ... 이렇게 변화하는데 이것은 1, 1 + 2 * 2 * 1, 1 + 2 * 3 * 2, 1 + 2 * 4 * 3 입니다.
- 위 내용을 식으로 작성하면 ```1 + (long) 2 * n * (n - 1)``` 이렇게 됩니다.
- 시간 복잡도: O(1)

### 2965. Find Missing and Repeated Values ```EASY```
- 이차원 배열이 주어졌을 때, 2번 나온 수와 한번도 안나온 수를 찾아 배열로 반환하는 문제
- 해당 수를 인덱스로 하는 배열을 생성한 뒤, 주어진 2차원 배열을 순회하면서 해당하는 숫자 인덱스의 카운트를 증가시킵니다.
- 그리고 해당 배열을 순회하면서 2번 나온 수를 [0]번 값으로 저장하고 0번 나온 수를 [1]번 값으로 저장하여 반환하면 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n * n) (n <= 50)

### 2523. Closest Prime Numbers in Range ```MEDIUM```
- left와 right 사이의 차이가 가장 적은 소수 2개를 배열로 반환하는 문제
- left와 right 사이의 수를 하나씩 확인하면서 소수인지 확인합니다.
  + 2로 나눈 나머지가 0이고 2보다 크다면 2의 배수이므로 바로 다음 수를 확인합니다.
  + 그렇지 않다면 해당 수를 2부터 해당 수의 절반인 수까지 증가시키며 나누어 떨어지는지 확인하고 나누어 떨어지는 경우 소수가 아니고 나누어 떨어지지 않으면 소수임을 확인합니다.
- 소수인 경우, 만약 이전에 찾은 소수의 마지막 수와 현재 소수와의 차가 2 이하라면 바로 해당 두 소수를 반환하여 문제를 해결할 수 있습니다.
- 그렇지 않다면 소수 리스트에 추가하고 다음 수를 확인합니다.
- 이렇게 left, right 사이의 모든 소수를 확인한 다음 소수의 개수가 2 미만이라면 바로 {-1, -1}을 반환합니다.
- 그렇지 않다면 소수 리스트를 순회하면서 앞뒤 수의 차이를 확인하고 최소 차이가 난다면 해당 두 소수를 배열로 만들어 반환해 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000000)

### 2379. Minimum Recolors to Get K Consecutive Black Blocks ```EASY```
- 'W'와 'B'로 이루어진 문자열이 주어졌을 때, k 개의 연속된 'B'를 만들기 위해 변경해야 하는 최소 'W'의 개수를 구하는 문제
- 먼저 0부터 k 까지 문자 중 'W'의 개수를 모두 구합니다.
- 그리고 k 길이의 문자열에서 첫 문자와 끝 문자가 다르고 첫 문자가 'W'라면 전체 'W'의 개수에서 하나를 빼고 아닌 경우 전체 'W'의 개수를 증가시킵니다.
- 그리고 최종 연산의 수가 현재 연산의 수보다 크다면 현재 연산의 수를 최종 연산의 수로 지정하고 최종 연산의 수가 0이라면 바로 반환합니다.
- 아니라면 다음 문자로 하나씩 미뤄서 위 과정을 거치고 최종적으로 최종 연산의 수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### 3306. Count of Substrings Containing Every Vowel and K Consonants II ```MEDIUM```
- word에서 모든 모음이 최소 한개 이상 포함되고 k개의 자음을 포함한 substring의 개수를 구하는 문제
- 변수 초기화
  + frequencies[0] 배열: 각 문자가 모음인지(1) 아닌지(0)를 저장.
  + frequencies[1] 배열: 현재 창(window) 내에서 등장한 모음의 개수를 저장.
- 투 포인터를 사용한 윈도우 슬라이딩
  + currentK: 현재 부분 문자열에서 포함된 자음의 개수.
  + vowels: 현재 부분 문자열에서 포함된 모음의 개수.
  + extraLeft: 중복된 모음이 존재할 때 왼쪽 포인터(left)를 추가로 이동할 때 사용.
- 오른쪽 포인터(right) 이동하며 윈도우 확장
  + right 포인터를 증가시키면서 새로운 문자를 창에 추가.
  + 현재 문자가 모음이면 frequencies[1]을 업데이트하고, 처음 등장하는 경우 vowels++ 증가.
  + 모음이 아닌 경우(자음) currentK++ 증가.
- 왼쪽 포인터(left) 이동하여 윈도우 조정
  + 현재 currentK > k이면 자음 개수를 k로 맞추기 위해 left를 증가시킴.
  + left 문자가 모음이면, frequencies[1]을 감소시키고, 해당 모음이 사라지면 vowels--.
  + left 문자가 자음이면, currentK--.
- 추가적인 left 이동으로 중복 모음 정리
  + 모든 모음이 포함(vowels == 5)되고 currentK == k이면 유효한 부분 문자열을 찾음.
  + 추가적으로 left를 이동해 중복된 모음을 정리하고 extraLeft 증가.
- 정답 업데이트
  + 현재 조건을 만족하는 경우 (1 + extraLeft)를 answer에 추가.
- 시간 복잡도: O(N) (N <= 2 * 10^5)

### 1358. Number of Substrings Containing All Three Characters ```MEDIUM```
- abc로 이루어진 문자열이 주어졌을 때, 하나 이상의 a,b,c를 모두 포함하는 문자열의 수를 구하는 문제
- a, b, c 각각이 몇개나 나왔는지를 저장할 배열을 생성합니다.
- 그리고 left = 0, right = 0 부터 하여 right가 문자열의 끝이 될 때까지 반복하면서 문자열을 확인합니다.
- 가장 오른쪽에 나온 문자의 개수를 하나 증가 시킨 뒤, 해당 문자가 1개 나온 경우 abc의 수를 증가시킵니다.
- 이렇게 abc의 수가 3이 되고 left가 right 보다 작으면서 현재 문자의 수가 1개를 초과하는 추가적인 left 이동으로 모을 수 있는 문자의 수를 증가시키고 현재 문자의 개수를 하나 감소시킨 뒤, left를 하나 증가시킵니다.
- 그리고 나서 abc가 3인 경우 정답에 (1 + left 이동으로 모을 수 있는 문자의 수)를 더합니다.
- 이렇게 문자열의 끝까지 반복하여 확인한 뒤 그 수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N) (N <= 5 * 10^4)

### 2529. Maximum Count of Positive Integer And Negative Integer ```EASY```
- 정수 배열이 주어졌을 때, 음수의 개수와 양수의 개수 중 더 큰 값을 반환하는 문제
- 배열을 순회하면서 음수인 경우 음수의 수를 증가시키고 양수인 경우 양수의 수를 증가시킨 뒤 최종적으로 음수의 수와 양수의 수 중 더 큰 값을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N) (N <= 2000)

### 3356. Zero Array Transformation II ```MEDIUM```
- 주어진 배열 nums[]의 각 인덱스 i에 대해 l, r 사이의 값을 val 만큼 빼는 연산(음수가 되면 0으로)을  최소한으로 사용하여 모든 원소가 0이 되는 최소의 쿼리 수를 찾는 문제
- 차분 배열(diffArray[]) 사용
  + 차분 배열을 활용하여 특정 범위 [left, right]에 value를 더하는 연산을 빠르게 수행.
  + 업데이트된 값은 sum += diffArray[i]를 통해 누적.
- 변수 초기화
  + n = nums.length; → nums[] 배열의 크기
  + sum → 현재까지 적용된 변화량의 합
  + queryCount → 사용한 쿼리 수 (최소 개수 찾기)
  + diffArray[n + 1] → 차분 배열 사용
- nums[i]를 만족하는 최소한의 쿼리를 찾기 위해 nums를 모두 순회하면서
- 현재 값이 nums[i]보다 작다면, 추가적인 쿼리를 실행합니다.
- 사용한 쿼리 수를 1 증가 시키고, 사용한 쿼리의 수가 queries.length를 초과하면 -1을 바로 반환하여 종료합니다.
- 그렇지 않은 경우 queries[]에서 (left, right, value)를 가져와 해당 구간을 업데이트합니다.
- 이때 차분 배열(diff array) 적용합니다.
  + diffArray[left] += value → left부터 증가
  + diffArray[right + 1] -= value → right + 1부터 감소 (누적 합으로 적용)
- diffArray[i]를 sum에 누적하여 현재 위치까지의 누적 변화량을 반영합니다.
- 이후 최종적으로 사용한 쿼리의 수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N * M) (N, M <= 100000)

### 2594. Minimum Time to Repair Cars ```MEDIUM```
- 여러 정비사가 자동차를 수리하는 데 걸리는 최소 시간을 구하는 문제
  + ranks[i]는 특정 정비사가 한 대의 차를 수리하는데 걸리는 기본 시간입니다.
  + 각 정비사는 여러 대의 차를 수리할 수 있으며, 한 명의 정비사가 여러 대의 차를 수리하는 경우, 걸리는 시간은 (수리한 차의 수)^2 × 정비사의 rank 입니다.
  + cars는 전체 수리해야 하는 자동차의 수를 나타냅니다.
- 입력 처리 및 정비사 수집
  + ranks 배열을 기반으로 각 정비사들의 rank 개수를 freq 배열에 저장합니다.
  + ranks[i] 값의 최대 범위가 100이므로, freq 배열 크기를 101로 설정합니다.
- 최소 rank 찾기
  + freq 배열을 순회하며 존재하는 가장 작은 rank 값을 찾습니다.
- 이분 탐색을 이용한 최소 시간 탐색
  + 최소 시간을 l = 0, 최대 시간을 r = minF * cars^2로 설정
  + 이분 탐색 (Binary Search) 사용 → O(log(minF * cars^2))
  + minF는 rank 중 최소값으로, 실제로는 작을 가능성이 높음
- check 함수 분석
  + 각 rank에 대해 해당 시간 내에 수리할 수 있는 최대 차의 수를 계산
  + t = sqrt(mid / i) 는 mid 시간 내에 rank i의 정비사가 수리할 수 있는 자동차 수를 나타냄
- 시간 복잡도: O(M * logN) (M <= 10^5, N <= 10^6)

### 2206. Divide Array Into Equal Pairs ```EASY```
- 배열이 주어졌을 때, (배열의 길이 / 2)개의 동일한 숫자의 쌍이 존재하면 true 아니면 false를 반환하는 문제
- 먼저 배열을 돌면서 배열의 수를 인덱스로 하는 배열의 값을 증가시켜 해당 수가 얼마나 나왔는지 개수를 저장합니다.
- 그리고 다시 처음부터 개수 배열을 순회하면서 해당 위치의 수가 2로 나누어 떨어지지 않는 경우 쌍을 만들 수 없는 것으로 판단하여 false를 반환하고
- 이렇게 모든 수의 개수를 확인한 뒤 최종적으로 true를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N) (N <= 500)

### 2401. Longest Nice Subarray ```MEDIUM```
- 양의 정수로 구성된 배열이 주어졌을 때, 서로 다른 수를 AND 연산하여 0이 나오는 가장 긴 서브배열의 길이를 구하는 문제
- 윈도우(슬라이딩 윈도우) 개념 사용
  + left와 right 두 개의 포인터를 유지하며 연속된 부분 배열을 검사합니다.
  + right를 증가시키면서 새로운 숫자를 추가합니다.
  + 현재 배열 내 모든 수들의 비트 정보를 usedBits에 저장하여 관리합니다.
- 비트 연산을 활용한 중복 체크 (& 연산자 사용)
  + (usedBits & nums[right]) != 0 → 현재 nums[right]를 추가하면 중복된 비트가 발생하는지 확인
  + 만약 중복된 비트가 있으면 left를 오른쪽으로 이동하여 비트 충돌이 없도록 조정합니다.
- 비트 제거 (^= 연산자 사용)
  + (usedBits ^= nums[left]) → nums[left]의 비트를 usedBits에서 제거하여 윈도우를 축소
  + 이후 left++를 수행하여 윈도우를 오른쪽으로 이동
- 비트 추가 (|= 연산자 사용)
  + usedBits |= nums[right] → 새로운 nums[right]를 추가하여 현재 윈도우의 비트 정보를 업데이트
- 최대 길이 갱신
  + maxLength = Math.max(maxLength, right - left + 1); → 윈도우 크기가 최대인 경우 갱신
- 시간 복잡도: O(N) (N <= 10^5)

### 3191. Minimum Operations to Make Binary Array Elements Equal to One I ```MEDIUM```
- 0과 1로 이루어지 bit 배열이 주어졌을 때, 한번에 연속된 3개의 값을 1은 0으로 0은 1로 바꾸는 연산을 하여 배열의 모든 수를 1로 바꾸는 최소 연산의 수를 구하는 문제
- nums.length - 2 전까지 확인하면서 현재 위치가 1이면 바꿀 필요가 없기 때문에 다음으로 넘어가고
- 0인 경우 비트 연산으로 0을 1로, 1은 0으로 바꿔 저장한 뒤 연산의 수를 증가시킵니다.
- nums.length - 2 전까지 모두 확인한 뒤 마지막 2개의 수 중 하나라도 0인 경우 이는 모든 수를 1로 만들 수 없으므로 -1을 반환하고
- 그렇지 않은 경우는 지금까지의 연산의 수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N) (N <= 10000)

### ```EASY```

