# 문제 풀이

### 3403. Find the Lexicographically Largest String From the Box I ```MEDIUM```
- 문자열 word를 numFriends개의 연속된 부분 문자열로 나누고 모든 라운드에서 쪼개진 문자열들을 모두 상자에 모은 뒤, 그 중 사전순으로 가장 큰 문자열을 반환하는 문제
- 먼저, numFriends == 1이면 전체 단어가 하나의 조각 → 바로 word 반환.
- 그 외에는:
  + 가장 뒤에 오는 접미사를 먼저 찾고 → last
  + 그 접미사에서 앞에서 n - numFriends + 1 길이 만큼 잘라서 반환.
  + 왜 이렇게 잘라야 할까?
    - 어떤 split 조합이든 각 조각은 최소 1글자는 가져야 하므로,
    - 가장 뒤의 접미사 중에서도 길이가 최대인 조각은 n - numFriends + 1 길이까지만 유효.
- lastSubstring(String s): 이 함수는 s의 접미사 중에서 사전순으로 가장 뒤에 있는 접미사를 찾아냅니다.
- 이 알고리즘은 두 개의 포인터 i, j를 사용하여 다음을 비교합니다:
  + i: 현재까지 발견된 최고 사전순 접미사의 시작 인덱스
  + j: 비교 대상이 되는 새로운 접미사의 시작 인덱스
  + k: 현재 접미사끼리 비교할 때, 얼마나 같은 문자가 이어졌는지를 측정
- 알고리즘 동작 순서
  + i는 현재 최적의 접미사 시작 인덱스.
  + j는 비교할 다른 후보 인덱스.
  + k는 두 접미사의 문자가 같은지 얼마나 이어지는지를 본다.
  + 만약 s[i + k] < s[j + k] 이면 j가 더 사전순으로 크다는 뜻 → i = j 로 갱신.
  + j는 다음 비교할 위치로 이동.
- 시간 복잡도: O(n) (n <= 5000)

### 3442. Maximum Difference Between Even and Odd Frequency I ```EASY```
- 문자열이 주어졌을 때 각 문자별로 수를 세고 홀수 개수 중 최대값과 짝수 개수 중 최소값을 구해 두 수의 차를 구하는 문제
- 먼저 크기가 26인 배열을 만들고 각 문자별로 몇개가 나오는지 그 수를 저장합니다.
- 그리고 배열을 돌면서 해당 수가 홀수인 경우 최대값을 구하고 0이 아닌 짝수인 경우 최소값을 구합니다.
- 그리고 최댓값에서 최소값을 뺀 수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### 2176. Count Equal and Divisible Pairs in an Array ```EASY```
- 배열과 k가 주어졌을 때, 0 <= i < j < nums.length 가 있고 nums[i] == nums[j] 이고 i * j % k가 짝수인 개수를 구하는 문제
- 이중 for 문을 반복하면서 nums[i] == nums[j] 이고 i * j % k가 짝수이면 answer를 증가시키고 최종적으로 이 값을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n^2) (n <= 100)

### 3423. Maximum Difference Between Adjacent Elements in a Circular Array ```EASY```
- 배열이 주어졌을 때 인접한 두 수의 차이의 가장 큰 절대값을 구하는 문제
- 먼저 맨 마지막 값에서 처음 값을 뺀 절대값을 answer 에 담아두고
- 배열을 돌면서 현재 인덱스의 값과 다음 인덱스의 값 차이와 answer 중 최대값을 answer 에 저장한 뒤
- 최종적으로 answer을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### 2016. Maximum Difference Between Increasing Elements ```EASY```
- 배열이 주어졌을 때, i < j 이고 nums[i] < num[j] 인 값의 차가 최대인 경우를 구하는 문제
- 먼저, 현재까지 발견한 최솟값의 인덱스를 i에 저장하고 현재까지의 최대 차이값을 max에 저장합니다.
- j는 1부터 시작하며 배열의 두 번째 값부터 순회합니다. j는 비교 대상이 되는 현재 값의 인덱스입니다.
- nums[j]가 nums[i]보다 큰 경우에만 차이를 계산하고 차이 tempMax가 기존 최대값 max보다 크면, max를 업데이트합니다.
- 만약 nums[j] <= nums[i]인 경우라면, 현재 값이 최소값보다 작거나 같음을 의미합니다. 그러므로 최소값 인덱스를 현재 인덱스 j로 갱신합니다.
- 조건을 만족하는 쌍이 없었다면, 즉 증가하는 부분이 없었다면 -1 반환합니다.
- 시간 복잡도: O(n) (n <= 1000)

### 2966. Divide Array Into Arrays With Max Difference ```EASY```
- 배열이 주어졌을 때, 3개씩 묶었을 때 각각의 값들의 차가 주어진 k 이하인 수로 묶인 2차원 배열을 반환하는 문제
- 먼저 배열을 정렬하고 3개씩 묶어서 가장 마지막 수에서 첫 수를 뺀 값이 k 초과이면 해당하지 않기 때문에 바로 빈 배열을 반환하고
- 그렇지 않은 경우 정답 배열에 추가한 뒤, 인덱스 + 3을 증가시켜 다음을 계속 확인한 뒤 결과적으로 모인 2차원 배열을 반환하여 문제를 해결할 수 있습니다.
- 정렬 후 3개씩 묶은 것만으로 확인할 수 있는 이유는 이미 가장 마지막 수에서 첫 수를 뺀 값이 k 초과이면 다음 수를 확인했을 때 차이가 더 벌어질 것이기 때문입니다.
- 시간 복잡도: O(n/3) (n <= 100000)

### 2294. Partition Array Such That Maximum Difference Is K ```EASY```
- 배열과 k 정수가 주어졌을 때, 배열을 서브 배열로 쪼개서 최대값과 최소값의 차이가 k 이하인 배열의 최소 수를 구하는 문제
- 먼저 배열을 정렬한 뒤, 변수 l, r을 정의하여 각각 인덱스를 나타내게 합니다.
- nums[r] - nums[l]이 k보다 작거나 같은 경우에는 r을 증가시키면서 계속 확인하고 
- k보다 커지는 경우는 서브 배열을 분리해야할 시기이므로 answer을 증가시키고 l에 r을 대입한 뒤, r을 하나 증가시킵니다.
- 이렇게 r이 배열의 끝에 도달할 때까지 확인한 뒤, 맨 마지막인 경우 answer을 하나 더 증가시키고 그 값을 반환하여 문제를 해결핦 수 있습니다.
- 시간 복잡도: O(n) (n < 100000)

### 2200. Find All K-Distant Indices in an Array ```EASY```
- 0부터 시작하는 정수 배열 nums와 두 정수 key, k가 주어졌을 때, 모든 k-근접 인덱스를 오름차순으로 정렬한 리스트를 반환하는 문제
  + 인덱스 i가 k-근접 인덱스가 되려면, 배열 내에 어떤 인덱스 j가 있어 |i - j| ≤ k 이고 동시에 nums[j] == key를 만족해야 합니다.
- 포인터 r
  + 이미 결과에 추가한 인덱스의 다음 위치를 가리킵니다.
  + 이를 통해 중복 추가를 방지하고, 이미 처리한 구간은 건너뛸 수 있습니다.
- 키 위치마다 구간 확장
  + nums[j] == key일 때, 이 키를 중심으로 [j–k, j+k] 범위의 모든 인덱스가 k-근접 인덱스가 됩니다.
  + 하지만 이 범위가 배열을 벗어나지 않게 Math.max(0, j–k), Math.min(n–1, j+k)로 경계를 조정합니다.
- 구간 병합 효과
  + 여러 키 위치에서 생성되는 구간들이 겹칠 수 있는데, l = Math.max(r, j - k)로 이미 추가된 부분을 제외한 새 구간만 처리합니다.
  + 예를 들어, 이전 키에서 [2, 6]을 추가했고, 다음 키에서 [4, 8]을 추가해야 한다면 실제로는 [6, 9) 범위인 [6, 8]만 추가합니다.
- 시간 복잡도: O(n) (n <= 1000)

### ```EASY```


