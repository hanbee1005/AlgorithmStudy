# 문제 풀이

### 3403. Find the Lexicographically Largest String From the Box I ```MEDIUM```
- 문자열 word를 numFriends개의 연속된 부분 문자열로 나누고 모든 라운드에서 쪼개진 문자열들을 모두 상자에 모은 뒤, 그 중 사전순으로 가장 큰 문자열을 반환하는 문제
- 먼저, numFriends == 1이면 전체 단어가 하나의 조각 → 바로 word 반환.
- 그 외에는:
  + 가장 뒤에 오는 접미사를 먼저 찾고 → last
  + 그 접미사에서 앞에서 n - numFriends + 1 길이 만큼 잘라서 반환.
  + 왜 이렇게 잘라야 할까?
    - 어떤 split 조합이든 각 조각은 최소 1글자는 가져야 하므로,
    - 가장 뒤의 접미사 중에서도 길이가 최대인 조각은 n - numFriends + 1 길이까지만 유효.
- lastSubstring(String s): 이 함수는 s의 접미사 중에서 사전순으로 가장 뒤에 있는 접미사를 찾아냅니다.
- 이 알고리즘은 두 개의 포인터 i, j를 사용하여 다음을 비교합니다:
  + i: 현재까지 발견된 최고 사전순 접미사의 시작 인덱스
  + j: 비교 대상이 되는 새로운 접미사의 시작 인덱스
  + k: 현재 접미사끼리 비교할 때, 얼마나 같은 문자가 이어졌는지를 측정
- 알고리즘 동작 순서
  + i는 현재 최적의 접미사 시작 인덱스.
  + j는 비교할 다른 후보 인덱스.
  + k는 두 접미사의 문자가 같은지 얼마나 이어지는지를 본다.
  + 만약 s[i + k] < s[j + k] 이면 j가 더 사전순으로 크다는 뜻 → i = j 로 갱신.
  + j는 다음 비교할 위치로 이동.
- 시간 복잡도: O(n) (n <= 5000)

### 3442. Maximum Difference Between Even and Odd Frequency I ```EASY```
- 문자열이 주어졌을 때 각 문자별로 수를 세고 홀수 개수 중 최대값과 짝수 개수 중 최소값을 구해 두 수의 차를 구하는 문제
- 먼저 크기가 26인 배열을 만들고 각 문자별로 몇개가 나오는지 그 수를 저장합니다.
- 그리고 배열을 돌면서 해당 수가 홀수인 경우 최대값을 구하고 0이 아닌 짝수인 경우 최소값을 구합니다.
- 그리고 최댓값에서 최소값을 뺀 수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### 2176. Count Equal and Divisible Pairs in an Array ```EASY```
- 배열과 k가 주어졌을 때, 0 <= i < j < nums.length 가 있고 nums[i] == nums[j] 이고 i * j % k가 짝수인 개수를 구하는 문제
- 이중 for 문을 반복하면서 nums[i] == nums[j] 이고 i * j % k가 짝수이면 answer를 증가시키고 최종적으로 이 값을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n^2) (n <= 100)

### 3423. Maximum Difference Between Adjacent Elements in a Circular Array ```EASY```
- 배열이 주어졌을 때 인접한 두 수의 차이의 가장 큰 절대값을 구하는 문제
- 먼저 맨 마지막 값에서 처음 값을 뺀 절대값을 answer 에 담아두고
- 배열을 돌면서 현재 인덱스의 값과 다음 인덱스의 값 차이와 answer 중 최대값을 answer 에 저장한 뒤
- 최종적으로 answer을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### ```EASY```
