# 문제 풀이

### 1353. Maximum Number of Events That Can Be Attended ```MEDIUM```
- events[i] = [start_i, end_i] 형태의 2차원 배열이 주어졌을 때, 최대한 많은 행사를 참석할 때 그 개수를 출력하는 문제
- 모든 행사를 시작일 기준 오름차순 정렬해 “오늘부터 시작할 수 있는 행사”를 순차적으로 빠르게 찾도록 준비합니다.
- 우선순위 큐(PriorityQueue): 자료구조는 끝나는 날짜가 가장 이른 행사가 맨 위에 오도록 하는 최소 힙.
  + 이유: 매일 하루만 참석할 수 있으므로, 빨리 사라지는(=마감 임박) 행사를 우선 선택해야 전체 참석 수를 극대화할 수 있습니다(탐욕적 전략).
- 매일 시뮬레이션 (day = 1 … maxDay)
  + 삽입: 오늘 시작 가능한 모든 행사의 end 값을 힙에 넣습니다.
  + 정리: 이미 종료된 행사는 힙에서 제거해 후보군을 정비합니다.
  + 선택: 힙이 비어 있지 않다면, 가장 빨리 끝나는 행사 하나에 참석(poll)하고 횟수를 증가시킵니다.
- 누적한 ans가 최종적으로 참석할 수 있는 행사 수의 최댓값입니다.
- 시간 복잡도: O(max(maxDay, n log n)) (maxDay, n <= 10^5)

### 1394. Find Lucky Integer in an Array ```EASY```
- 정수 배열이 주어졌을 때, 해당 값과 동일한 개수만큼 나온 수 중 가장 큰 값을 반환하는 문제
- 먼저 500까지 인덱스를 가진 배열을 생성하고 주어진 배열을 돌면서 해당 수의 인덱스 값을 증가시켜 개수를 저장합니다.
- 이후 개수를 저장한 배열을 돌면서 해당 인덱스와 인덱스에 저장된 값이 같은 경우 기존 정답과 비교하여 더 큰 값으로 정답을 업데이트 합니다.
- 최종적으로 정답을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 500)

### 1695. Maximum Erasure Value ```MEDIUM```
- 양의 정수 배열이 주어졌을 때, 유니크한 값을 가지는 서브 배열들 중 숫자를 모두 더했을 때 그 합의 최대를 구하는 문제
- 어떤 숫자가 이전에 나왔는지를 확인할 boolean 배열 seen 을 정의합니다.
- 주어진 배열을 돌면서 해당 숫자가 이전에 나온 경우 현재 합에서 해당 숫자를 빼고 다시 해당 숫자를 보지 않은 것으로 false 처리한 뒤, left 변수를 증가시킵니다. 이 과정을 현재 숫자가 나오지 않은 것으로 처리될 때까지 반복한다.
- 그리고 현재 숫자가 나오지 않았다면 현재 숫자를 현재 합에 더하고 현재 숫자가 나온 것으로 true 처리한다.
- 마지막으로 현재까지의 합과 최대 합을 비교해 최대 합을 갱신하고 전체 배열을 모두 확인한 뒤 최종 합을 반환하여 문제를 해결할 수 있다.
- 시간 복잡도: O(n) (n <= 10000)

### 2419. Longest Subarray With Maximum Bitwise AND ```MEDIUM```
- 크기가 n인 정수 배열 nums가 주어졌을 때, nums에서 가능한 한 비트 AND 값이 최대가 되는 비어 있지 않은 부분 배열의 최대 길이를 구하는 문제
- 부분 배열은 길이 1도 허용되므로, 가능한 비트 AND의 최댓값 k는 사실상 nums의 최댓값입니다. 따라서 답은 배열에서 최댓값이 연속해서 나타나는 가장 긴 구간의 길이가 됩니다.
- 먼저 배열을 돌면서 최대값을 구합니다.
- 그리고 다시 배열을 돌면서 최대값과 같다면 현재 길이를 증가시키고 최대 길이와 비교해 더 큰 값을 최대 길이로 업데이트 합니다.
- 만약 최대값과 값이 다르다면 중간에 다른 값이 낀 것이므로 현재 길이를 0으로 합니다.
- 최종적으로 최대 길이를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100000)

### ```EASY```


