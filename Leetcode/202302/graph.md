# Graph, BFS, DFS

### 200. Number of Islands
배열이 주어졌을 때 땅(1), 물(0)을 구분하여 섬(사방이 0으로 둘러쌓인 1의 집합)의 개수를 구하는 문제입니다.
[문제풀이코드](https://github.com/hanbee1005/AlgorithmStudy/blob/master/Leetcode/202302/NumberOfIslands_200.java)
- DFS 를 사용하여 문제를 풀었습니다.
- 우선 주어진 배열을 모두 돌면서 탐색을 시작해야 하는 즉, **현재 값이 1이면서 아직 방문하지 않은 경우**를 찾습니다.
- 이후 이 위치를 방문한 것으로 처리(```visited[x][y] = true```)하고 주변 상,하,좌,우 4개의 지점(```{{-1, 0}, {0, -1}, {1, 0}, {0, 1}}```)을 확인하여
- **이동할 수 있으면서 해당 위치의 값이 1이고 아직 방문하지 않은 경우** 다시 재귀함수를 호출합니다.
- 이 과정을 마치면 연관된 1 집합을 한번 다 찾은 것으로 섬 하나를 발견한 것이므로 count를 증가시킵니다.
- 이후 모든 지점에 대해 확인을 하고 난 뒤 count를 반환하는 방식으로 구현하였습니다.

### 695. Max Area of Island
배열이 주어졌을 때 땅(1), 물(0)을 구분하여 가장 큰 섬(사방이 0으로 둘러쌓인 1의 집합)의 면적을 구하는 문제입니다.
[문제풀이코드](https://github.com/hanbee1005/AlgorithmStudy/blob/master/Leetcode/202302/MaxAreaOfIsland_695.java)
- BFS 를 사용하여 문제를 풀었습니다.
- 우선 주어진 배열을 모두 돌면서 탐색을 시작해야 하는 즉, **현재 값이 1이면서 아직 방문하지 않은 경우**를 찾습니다.
- 이후 이 위치를 Queue에 저장합니다. 이후 Queue가 빌 때까지
- 현재 위치를 하나 꺼내서 사방을 확인하며 **이동이 가능하고 1이면서 아직 방문하지 않은 경우** 해당 위치를 방문한 것으로 하고 면적 값을 1 증가시킵니다.
- 그리고 해당 위치를 Queue에 저장합니다.
- Queue가 빌 때까지 반복하다가 결과로 면적을 반환합니다.
- 이 반환된 면적과 기존 면적 중 큰 값을 최종적으로 반환하는 방식으로 구현하였습니다. 

### 127. Word Lodder
가장 적은 단어 수를 사용하여 시작 단어부터 끝 단어로 변할 수 있는 단어의 수를 구하는 문제입니다. 
[문제풀이코드](https://github.com/hanbee1005/AlgorithmStudy/blob/master/Leetcode/202302/WordLadder_127.java)
