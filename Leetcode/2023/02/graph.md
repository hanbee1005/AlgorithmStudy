# Graph, BFS, DFS

### 200. Number of Islands
배열이 주어졌을 때 땅(1), 물(0)을 구분하여 섬(사방이 0으로 둘러쌓인 1의 집합)의 개수를 구하는 문제입니다.
[문제풀이코드](https://github.com/hanbee1005/AlgorithmStudy/blob/master/Leetcode/202302/NumberOfIslands_200.java)
- DFS 를 사용하여 문제를 풀었습니다.
- 우선 주어진 배열을 모두 돌면서 탐색을 시작해야 하는 즉, **현재 값이 1이면서 아직 방문하지 않은 경우**를 찾습니다.
- 이후 이 위치를 방문한 것으로 처리(```visited[x][y] = true```)하고 주변 상,하,좌,우 4개의 지점(```{{-1, 0}, {0, -1}, {1, 0}, {0, 1}}```)을 확인하여
- **이동할 수 있으면서 해당 위치의 값이 1이고 아직 방문하지 않은 경우** 다시 재귀함수를 호출합니다.
- 이 과정을 마치면 연관된 1 집합을 한번 다 찾은 것으로 섬 하나를 발견한 것이므로 count를 증가시킵니다.
- 이후 모든 지점에 대해 확인을 하고 난 뒤 count를 반환하는 방식으로 구현하였습니다.

### 695. Max Area of Island
배열이 주어졌을 때 땅(1), 물(0)을 구분하여 가장 큰 섬(사방이 0으로 둘러쌓인 1의 집합)의 면적을 구하는 문제입니다.
[문제풀이코드](https://github.com/hanbee1005/AlgorithmStudy/blob/master/Leetcode/202302/MaxAreaOfIsland_695.java)
- BFS 를 사용하여 문제를 풀었습니다.
- 우선 주어진 배열을 모두 돌면서 탐색을 시작해야 하는 즉, **현재 값이 1이면서 아직 방문하지 않은 경우**를 찾습니다.
- 이후 이 위치를 Queue에 저장합니다. 이후 Queue가 빌 때까지
- 현재 위치를 하나 꺼내서 사방을 확인하며 **이동이 가능하고 1이면서 아직 방문하지 않은 경우** 해당 위치를 방문한 것으로 하고 면적 값을 1 증가시킵니다.
- 그리고 해당 위치를 Queue에 저장합니다.
- Queue가 빌 때까지 반복하다가 결과로 면적을 반환합니다.
- 이 반환된 면적과 기존 면적 중 큰 값을 최종적으로 반환하는 방식으로 구현하였습니다. 

### 127. Word Lodder
가장 적은 단어 수를 사용하여 시작 단어부터 끝 단어로 변할 수 있는 단어의 수를 구하는 문제입니다. 
[문제풀이코드](https://github.com/hanbee1005/AlgorithmStudy/blob/master/Leetcode/202302/WordLadder_127.java)
- 가장 빠르게 endWord에 도달할 수 있는 방법을 찾는 것이기 때문에 **최단거리문제**로 볼 수 있고 그래서 BFS를 사용하여 해결하였습니다.
- 먼저 해당 위치를 방문한 이력이 있는지 저장할 visited 배열을 만들고 BFS 순으로 실행할 Queue를 생성합니다.
- 이 Queue가 빌 때까지 반복하게 되는데 그 안에서 현재 depth에 있는 노드들을 다 확인하고 나서 다음 depth로 넘어가야 하기 때문에 현재 depth에 있는 노드의 수와 같은 Queue의 사이즈만큼 반복합니다.
- 이때 Queue에서 단어를 하나 뽑아서 이 단어가 endWord와 같다면 지금까지 count를 반환하고 종료합니다.
- 같지 않다면 wordList 처음부터 끝까지 반복하면서 다음 이동할 수 있는 단어를 찾은 뒤, 방문한 적이 없고 현재 단어와 한글자 차이가 난다면 방문한 것으로 하고 Queue에 데이터를 저장합니다.
- 이후 다시 Queue에 값이 존재하는지 확인하기 전에 count를 증가시켜 다음 depth로 이동했음을 나타냅니다.
- Queue를 모두 확인할 때까지 endWord와 일치하는 단어를 찾지 못한 경우 0을 반환합니다.
- [참고](https://neo82.tistory.com/48)
