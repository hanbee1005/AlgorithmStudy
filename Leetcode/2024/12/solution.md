# 문제 풀이

### 1455. Check if a Word Occurs as a Prefix of Any Word in a Sentence ```EASY```
- 문자열이 주어졌을 때 빈문자로 나눈 각 단어 중 searchWord로 시작하는 단어가 몇번째 단어인지 구하는 문제 (여러 개인 경우 더 앞에 나온 문자 위치를, 없는 경우 -1 반환)
- 주어진 문자열을 빈문자로 분리하고 앞에서부터 startsWith으로 확인하면서 seatchWord로 시작하는 경우 해당 문자 인덱스 + 1을 반환하고
- 모든 문자를 확인해도 없는 경우 -1을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n)(n <= 50)

### 2109. Adding Spaces to a String ```MEDIUM```
- 문자열 s와 원래 빈 문자열의 위치를 나타내는 정수 배열이 주어졌을 때 빈 문자열이 포함된 변형된 문자열을 반환하는 문제
- 문자열을 char 배열로 변환하고 최종 문자열을 만들 char 배열도 생성합니다.
- 빈 문자열 위치를 나타내는 배열을 순회하면서 먼저 해당 위치 전까지의 문자를 최종 문자열 배열에 채워 넣습니다.
- 해당 인덱스를 만나면 해당 위치에 빈 문자열을 추가하고 다시 반복합니다.
- 최종적으로 남아있는 문자들을 모두 최종 문자열을 만들기 위한 배열에 추가한 뒤 해당 배열을 문자열로 변환하여 반환해 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 3 * 10^5)

### 2825. Make String a Subsequence Using Cyclic Increments ```MEDIUM```
- 소스 문자열과 타겟 문자열이 주어졌을 때 소스 문자열의 문자 하나하나를 한단계 다음 문자로 바꿔 타겟 문자열이 서브 문자열이 될 수 있는지를 반환하는 문제
- 각 문자열의 인덱스를 비교하여 다음과 같은 조건일 때 두 문자열의 다음 인덱스를 확인하고 그렇지 않은 경우는 소스 문자열의 인덱스만 증가시키면서 문자를 모두 확인합니다.
  + 소스 문자와 타겟 문자가 같은 경우
  + 또는, 소스 문자가 z이고 타겟 문자가 a인 경우
  + 또는, 소스 문자의 다음 문자가 타겟 문자인 경우
- 최종적으로 타겟 문자열의 인덱스와 타겟 문자열의 길이가 같은 경우는 타겟 문자열을 만들 수 있는 것으로 판단하여 true를 그렇지 않은 경우 false를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 10^5)

### 3152. Special Array II ```MEDIUM```
- 주어진 배열 nums와 다수의 쿼리 queries에 대해, 각 쿼리의 범위 [left, right]에서 "특별한 쌍(special pairs)"이 있는지 판단하는 문제
  + 특별한 쌍의 정의: 배열의 두 인접 원소 (nums[i-1], nums[i])가 다음 조건 중 하나를 만족하면 특별한 쌍이라고 정의합니다.
    - 두 원소가 모두 짝수이다.
    - 두 원소가 모두 홀수이다.
- 특별한 쌍의 누적 개수를 저장하는 prefix 배열을 생성합니다.
  + prefix[i]는 배열의 처음부터 인덱스 i까지의 특별한 쌍의 개수를 나타냅니다.
  + 이는 범위 [left, right]에서 특별한 쌍의 개수를 효율적으로 계산할 수 있도록 합니다.
- 각 쿼리를 처리하며 prefix 배열을 활용해 범위 내 특별한 쌍의 개수를 계산하고, 조건에 따라 결과를 저장합니다.
- Step 1: Build the prefix array
  + prefix[i]를 0부터 i까지의 특별한 쌍의 누적 개수로 계산.
  + 특별한 쌍은 조건에 따라 확인하고, 발견 시 prefix[i]를 증가.
- Step 2: Process each query
  + 각 쿼리에서 범위 [left, right]의 특별한 쌍의 개수를 계산:
    - specialCount=prefix[right]−prefix[left-1] (left > 0일 경우).
    - specialCount=prefix[right] (left = 0일 경우).
  + 특별한 쌍이 하나도 없으면 결과는 true, 그렇지 않으면 false.
- 시간 복잡도: O(n+q) (n <= 10^5, q <= 10^5)

### 3264. Final Array State After K Multiplication Operations I ```EASY```
- 정수 배열에서 k 번 반복하여 가장 작은 수를 찾아 multiplier를 곱했을 때 배열을 구하는 문제
- k 번 반복하면서 0번부터 정수 배열 끝까지 하나씩 확인하면서 가장 작은 인덱스를 찾고
- 해당 인덱스의 값에 multiplier를 곱해 다시 넣는 방식으로 연산을 수행합니다.
- 이후 해당 배열을 그대로 반환하여 문제를 해결할 수 있습니다.
- 반복문을 실행하는 범위가 크지 않기 때문에 큐 등을 사용하여 여러번 정렬하는 것보다 처음부터 모두 비교하며 작은 값을 찾는 것이 더 빠를 수 있습니다.
- 시간 복잡도: O(n * k) (n <= 100, k <= 10)

### 1475. Final Prices with a Special Discount in a Shop ```EASY```
- 배열이 주어졌을 때 해당 인덱스보다 큰 인덱스 중 값이 작은 것을 뺀 결과 배열을 반환하는 문제
- 이중 for 문을 반복하면서 다음 인덱스의 값들 중 작거나 같은 값이 나온 경우 현재 위치의 값에서 해당 값을 뺀 값을 저장하고 다음 인덱스를 확인하는 방식으로 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n^2) (n <= 500)

### 2471. Minimum Number of Operations to Sort a Binary Tree by Level  ```MEDIUM```
- 트리노드가 주어졌을 때 각 레벨을 오름차순으로 정렬하기 위해 필요한 최소 swap 횟수를 구하는 문제
- BFS를 사용해 트리를 레벨 단위로 탐색
  + `Queue<TreeNode>`를 사용해 트리를 레벨 순서대로 순회합니다.
  + 각 레벨에서 모든 노드 값을 levelValues 배열에 저장합니다.
- 각 레벨의 정렬에 필요한 최소 스왑 계산
  + 각 레벨의 값을 정렬하여 `target` 배열을 생성합니다.
  + 원래 배열(`original`)과 정렬된 배열(`target`)을 비교하면서, 정렬을 완료하는 데 필요한 최소 스왑 횟수를 계산합니다.
  + 이를 위해 값의 현재 위치를 추적하는 맵(`pos`)을 사용합니다.
- 스왑 횟수 누적
  + 각 레벨의 최소 스왑 횟수를 `totalSwaps`에 누적합니다.
- 결과 반환
  + 모든 레벨을 처리한 후, 최소 스왑 횟수 총합을 반환합니다.
- 시간 복잡도: O(NlogM) (N <= 10^5, M = 각 레벨의 최대 노드 수)

### 494. Target Sum ```MEDIUM```
- 배열 nums와 target이 주어졌을 때, 배열의 숫자에 + 또는 -를 부여하여 합계가 target이 되는 경우의 수를 구하는 문제
- 숫자 배열에서 일부 숫자를 더하고 다른 숫자를 뺀 결과가 target이 되는 경우를 구하는 문제입니다.
- 이를 부분집합 문제로 변환하여 해결합니다:
  + 배열을 두 부분집합 S1과 S2로 나누고, 다음 관계를 이용합니다:
    - S1 − S2 = target, S1 + S2 = sum(nums)
    - 위 식을 정리하면: S1 = target + sum(nums) / 2
    - 즉, 문제는 **합이 S1**인 부분집합의 개수를 찾는 문제로 변환됩니다.
- target+sum(nums)가 음수이거나 홀수이면, S1이 정수로 나올 수 없으므로 답은 0입니다.
- dp[i]는 **합이 i**인 부분집합의 개수를 저장합니다.
- 기본적으로 dp[0]=1, 이는 합이 0인 부분집합(공집합)이 항상 1개 존재하기 때문입니다.
- 각 숫자 nums[index]를 순차적으로 처리하며, 역순으로 dp[j]를 업데이트합니다.
- dp[j]는 dp[j−nums[index]]의 값을 더하여 업데이트되며, 이는 숫자 nums[index]를 포함하는 경우를 추가하는 과정입니다.
- dp[targetSum] 값을 반환하면, 문제의 답을 구할 수 있습니다.
- 시간 복잡도: O(n * targetSum) (n <= 20)

### 1014. Best Sightseeing Pair ```MEDIUM```
- 배열 values에서 두 인덱스 i와 j를 선택하여 `values[i] + values[j] + i - j`의 최대값을 찾는 문제
- 먼저 주어진 식을 `(values[i] + i) + (values[j] - j)`와 같은 형태로 변형하여 i번째 요소와 인덱스를 더한 값과 j번째 요소와 인덱스를 뺀 값을 더한 최대값을 구하는 문제로 변형합니다.
- 그리고 먼저 i번째 요소와 인덱스 i를 더한 최댓값을 저장할 m이라는 변수를 선언하고 values의 첫번째 값 + 인덱스 0으로 초기화 합니다.
- values 배열을 순회하면서 j에 대한 최대 점수를 구합니다. 이때 최대 점수를 구하면 ans을 갱신합니다.
- 그리고 m 값을 j 요소와 인덱스 j의 합과 비교하여 최대값을 갱신합니다.
- 최종적으로 최대 점수 ans를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 50000)

### 2466. Count Way to Build Good Strings ```MEDIUM```
- 길이가 low보다 크거나 같고 high보다 작거나 같은 0과 1로 이루어진 좋은 문자열의 개수를 구하는 문제 (0의 최소 연속 개수, 1의 최소 연속 개수 제공)
- DP 정의: 
  + dp[i]: 길이가 i인 문자열의 경우의 수.
  + 초기값: dp[0]=1 (길이가 0인 문자열은 공집합으로 유효).
- 점화식:
  + 길이 i를 만들기 위해: 
    - one만큼 1을 추가할 경우: 이전 길이 i−one의 경우의 수를 더함.
    - zero만큼 0을 추가할 경우: 이전 길이 i−zero의 경우의 수를 더함.
  + dp[i] = dp[i - one] + dp[i - zero] (조건에 따라).
- 결과 누적: 
  + low ≤ i ≤ high 범위의 dp[i] 값을 ans에 누적.
- 모듈러 연산:
  + 계산 도중 숫자가 매우 커질 수 있으므로, 10 ^ 9  + 7로 나머지 연산을 수행하여 값의 크기를 제한.
- 시간 복잡도: O(n) (n <= 100000)

### ```EASY```



