# 문제 풀이

### 2108. Find First Palindromic String in the Array ```EASY```
- 문자열 배열이 주어졌을 때 앞으로 읽었을 때와 뒤에서 읽었을 때 똑같은 문자열을 반환하는 문제
- 전체 문자열을 돌면서 하나의 문자열의 첫 문자와 마지막 문자를 확인하고 둘이 같지 않으면 false로 다음 문자열을 확인하고 같으면 시작 위치를 +1, 끝 위치를 -1 하여 계속 비교한 뒤
- 모든 비교가 정상적으로 종료되면 해당 문자열을 반환하여 해결할 수 있는 문제입니다.
- 시간 복잡도: O(N * M) (N,M <= 100)

### 1550. Three Consecutive Odds ```EASY```
- 배열이 주어졌을 때 연속하는 3개의 홀수가 존재하면 true, 아니면 false 를 반환하는 문제
- 배열을 순회하면서 홀수인 경우 cnt를 증가시키고 아닌 경우 cnt를 0으로 초기화 합니다.
- cnt가 3인 경우 바로 true를 리턴하고 배열을 모두 순회한 뒤 그 전에 반환되지 못하면 false를 리턴하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000)

### 350. Intersection of Two Array II ```EASY```
- 두 배열이 주어졌을 때, 중복으로 나온 수의 목록을 구하는 문제
- 첫번째 배열을 돌면서 배열에 포한된 숫자 인덱스를 증가시킵니다.
- 두번째 배열을 돌면서 숫자 인덱스를 감소시키고 해당 값이 0보다 큰 경우 중복된 값으로 판단해 결과 배열에 저장합니다.
- 최종적으로 결과 배열의 값이 있는 부분만 잘라서 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000)

### 1509. Minimum Difference Between Largest and Smallest Value in the Moves ```MEDIUM```
- 배열이 주어졌을 때 최대 3번의 숫자 변경을 한 뒤, 최대값과 최솟값의 차이가 가장 적은 경우를 구하는 문제
- 배열의 크기가 4이하인 경우 바로 0을 반환합니다,
- 배열을 정렬한 뒤, 시작 위치와 전체 크기에서 4를 뺀 끝 위치를 지정하고 두 위치의 값의 차가 답보다 작은 경우 해당 차를 답으로 저장하고 시작 위치와 끝 위치를 하나씩 이동하며 끝까지 비교한 뒤 답을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N) (N <= 100000)

### 2181. Merge Nodes in Between Zeros ```MEDIUM```
- ListNode 가 주어졌을 때 0과 0 사이의 값들을 합친 ListNode를 구하는 문제
- 먼저 head 노드의 다음 위치를 가리키는 포인터가 되는 modify 를 만들고 그 modify를 가리키는 nextNode를 지정합니다.
- 그리고 nextNode가 null 이 아닌 동안 반복하면서 sum을 구해주는데 
- nextNode의 값이 0이 아닌 동안 값을 더하고 nextNode가 다음 위치를 가르킬 수 있게 변경합니다.
- 이후 nextNode의 값이 0이 되면 nextNode의 다음 위치를 nextNode가 가르키게 한 뒤, 합친 값을 modify의 값으로 지정하고 modify의 다음 위치를 nextNode로 지정합니다.
- 그리고 다시 modify는 modify의 다음 위치를 가리킬 수 있게 합니다.
- 이렇게 마지막 위치까지 확인한 뒤, head의 다음 위치를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N) (3 <= N <= 2 * 10^5)

### 1823. Find the Winner of the Circular Game ```MEDIUM```
- 이 문제는 재귀를 통해 해결할 수 있는데 n명이 사람 중 한명을 제거하고 다시 n-1 명의 사람을 대상으로 k번째 사람을 제거하는 것을 반복하는 것입니다.
- 만약 한사람이 남았다면 해당 위치의 값을 0 반환하고
- n명이 남아 있는 상황에서 k번째 사람을 제거하면, (n-1)명이 남게 됩니다. 이 상황에서 재귀적으로 다음 사람을 찾습니다.
- josephusHelper(n - 1, k)는 n-1명이 남았을 때의 안전한 위치를 반환하고, 여기에 k를 더하여 현재 n명이 있을 때의 위치를 조정합니다. 모듈로 연산 % n은 원형 구조에서 위치를 순환시키기 위해 사용됩니다.
- 시간 복잡도: O(N) (N <= 500)

### 1701. Average Waiting Time ```MEDIUM```
- 손님의 도착 시간과 음식 조리 시간이 주어졌을 때 평균 대기 시간을 구하는 문제
- 손님은 시간 순으로 도착하기 때문에 별도의 정렬은 필요없고 전체 손님 목록을 순회하면서
- 현재 시간이 손님 도착 시간보다 작다면 현재 시간을 손님의 도착 시간으로 변경하고
- 현재 시간에 대기 시간을 더한 뒤, 최종 대기 시간에 현재 시간에서 도착 시간을 뺀 값을 합해줍니다.
- 최종 대기 시간을 손님의 수로 나누어 반환하면 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N) (N <= 10^5)

### ```EASY```



