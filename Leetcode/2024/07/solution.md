# 문제 풀이

### 2108. Find First Palindromic String in the Array ```EASY```
- 문자열 배열이 주어졌을 때 앞으로 읽었을 때와 뒤에서 읽었을 때 똑같은 문자열을 반환하는 문제
- 전체 문자열을 돌면서 하나의 문자열의 첫 문자와 마지막 문자를 확인하고 둘이 같지 않으면 false로 다음 문자열을 확인하고 같으면 시작 위치를 +1, 끝 위치를 -1 하여 계속 비교한 뒤
- 모든 비교가 정상적으로 종료되면 해당 문자열을 반환하여 해결할 수 있는 문제입니다.
- 시간 복잡도: O(N * M) (N,M <= 100)

### 1550. Three Consecutive Odds ```EASY```
- 배열이 주어졌을 때 연속하는 3개의 홀수가 존재하면 true, 아니면 false 를 반환하는 문제
- 배열을 순회하면서 홀수인 경우 cnt를 증가시키고 아닌 경우 cnt를 0으로 초기화 합니다.
- cnt가 3인 경우 바로 true를 리턴하고 배열을 모두 순회한 뒤 그 전에 반환되지 못하면 false를 리턴하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000)

### 350. Intersection of Two Array II ```EASY```
- 두 배열이 주어졌을 때, 중복으로 나온 수의 목록을 구하는 문제
- 첫번째 배열을 돌면서 배열에 포한된 숫자 인덱스를 증가시킵니다.
- 두번째 배열을 돌면서 숫자 인덱스를 감소시키고 해당 값이 0보다 큰 경우 중복된 값으로 판단해 결과 배열에 저장합니다.
- 최종적으로 결과 배열의 값이 있는 부분만 잘라서 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000)

### 1509. Minimum Difference Between Largest and Smallest Value in the Moves ```MEDIUM```
- 배열이 주어졌을 때 최대 3번의 숫자 변경을 한 뒤, 최대값과 최솟값의 차이가 가장 적은 경우를 구하는 문제
- 배열의 크기가 4이하인 경우 바로 0을 반환합니다,
- 배열을 정렬한 뒤, 시작 위치와 전체 크기에서 4를 뺀 끝 위치를 지정하고 두 위치의 값의 차가 답보다 작은 경우 해당 차를 답으로 저장하고 시작 위치와 끝 위치를 하나씩 이동하며 끝까지 비교한 뒤 답을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N) (N <= 100000)

### 2181. Merge Nodes in Between Zeros ```MEDIUM```
- ListNode 가 주어졌을 때 0과 0 사이의 값들을 합친 ListNode를 구하는 문제
- 먼저 head 노드의 다음 위치를 가리키는 포인터가 되는 modify 를 만들고 그 modify를 가리키는 nextNode를 지정합니다.
- 그리고 nextNode가 null 이 아닌 동안 반복하면서 sum을 구해주는데 
- nextNode의 값이 0이 아닌 동안 값을 더하고 nextNode가 다음 위치를 가르킬 수 있게 변경합니다.
- 이후 nextNode의 값이 0이 되면 nextNode의 다음 위치를 nextNode가 가르키게 한 뒤, 합친 값을 modify의 값으로 지정하고 modify의 다음 위치를 nextNode로 지정합니다.
- 그리고 다시 modify는 modify의 다음 위치를 가리킬 수 있게 합니다.
- 이렇게 마지막 위치까지 확인한 뒤, head의 다음 위치를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N) (3 <= N <= 2 * 10^5)

### 1823. Find the Winner of the Circular Game ```MEDIUM```
- 이 문제는 재귀를 통해 해결할 수 있는데 n명이 사람 중 한명을 제거하고 다시 n-1 명의 사람을 대상으로 k번째 사람을 제거하는 것을 반복하는 것입니다.
- 만약 한사람이 남았다면 해당 위치의 값을 0 반환하고
- n명이 남아 있는 상황에서 k번째 사람을 제거하면, (n-1)명이 남게 됩니다. 이 상황에서 재귀적으로 다음 사람을 찾습니다.
- josephusHelper(n - 1, k)는 n-1명이 남았을 때의 안전한 위치를 반환하고, 여기에 k를 더하여 현재 n명이 있을 때의 위치를 조정합니다. 모듈로 연산 % n은 원형 구조에서 위치를 순환시키기 위해 사용됩니다.
- 시간 복잡도: O(N) (N <= 500)

### 1701. Average Waiting Time ```MEDIUM```
- 손님의 도착 시간과 음식 조리 시간이 주어졌을 때 평균 대기 시간을 구하는 문제
- 손님은 시간 순으로 도착하기 때문에 별도의 정렬은 필요없고 전체 손님 목록을 순회하면서
- 현재 시간이 손님 도착 시간보다 작다면 현재 시간을 손님의 도착 시간으로 변경하고
- 현재 시간에 대기 시간을 더한 뒤, 최종 대기 시간에 현재 시간에서 도착 시간을 뺀 값을 합해줍니다.
- 최종 대기 시간을 손님의 수로 나누어 반환하면 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N) (N <= 10^5)

### 1598. Crawler Log Folder ```EASY```
- 디렉토리 이동에 대한 명령어가 배열로 주어졌을 때, 주어진 명령을 모두 수행 후 다시 root 폴더로 돌아오기 위해 이동해야 하는 횟수를 구하는 문제
- 문자열 "./" 이 들어온 경우 그대로 다음 문자를 확인하고
- 문자열 "../"이 들어온 경우는 상위 폴더로 이동하기 때문에 root 폴더랑 가까워지므로 -1을 하는데 0인 경우 0으로 둡니다.
- 그외 다른 디렉토리로 이동하는 경우 해당 디렉토리의 하위 디렉토리로 이동한다고 했기 때문에 root 와 멀어지므로 +1을 해줍니다.
- 이렇게 계산한 값을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N) (N <= 1000)

### 1190. Reverse Substrings Between Each Pair of Parentheses  ```MEDIUM```
- 괄호로 묶인 문자열이 주어졌을 때 뒤집기 과정을 거쳐 새로운 문자열을 반환하는 문제
- ')'를 만날 때까지 문자를 stack 에 쌓고
- ')'가 나온 경우 '('가 나올 때까지 큐에 문자를 넣은 뒤
- '('를 만난 경우 큐에 있는 문자를 다시 stack에 넣습니다.
- 이후 최종적으로 모든 문자를 확인하면 stack에서 문자를 꺼내 문자열 맨앞에 붙여 새로운 문자를 만든 뒤 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N) (N <= 2000)

### 1717. Maximum Score From Removing Substrings ```MEDIUM```
- 문자열과 'ab'를 지울 때 얻을 수 있는 x 포인트, 'ba'를 지울 때 얻을 수 있는 y 포인트가 주어졌을 때 받을 수 있는 최대 포인트를 구하는 문제
- 이 문제는 greedy 방식의 문제라는 것을 알았지만 해결은 다른 사람의 풀이를 참조했습니다.
- 먼저 'ab'를 지울 때의 포인트인 x와 'ba'를 지울 때의 포인트인 y를 비교하여 y가 더 큰 경우 x, y를 바꾸고 문자열도 뒤집어서 항상 'ab'를 지울 때 더 많은 포인트를 얻을 수 있도록 합니다.
- 그런 다음 문자열을 앞에서부터 순서대로 한 문자씩 확인하면서
- a도 b도 아닌 경우 지금까지 나온 a, b 개수보다 작은 개수에 더 작은 포인트를 곱해 최종 포인트에 더해주고 a, b의 개수를 0으로 초기화 합니다.
- 만약 a가 나온 경우 a의 개수를 증가 시키고
- b가 나온 경우는 a의 개수가 0보다 큰 경우 ab를 만들 수 있다고 가정하여 a의 개수를 감소시키고 'ab'를 찾았을 때 얻을 수 있는 x 포인트를 최종 포인트에 더해줍니다.
- 만약 a의 개수가 0인 경우 b만 등장했으므로 b 카운트를 증가시킵니다.
- 최종적으로 a, b 개수 중 작은 개수에 더 적은 포인트인 y를 곱한 값을 더해 최종 포인트 값을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N) (N <= 100000)

### 1481. Least Number of Unique Integers after K Removals ```MEDIUM```
- 배열과 정수 k가 주어졌을 때 정확히 k개를 삭제했을 때 남아있는 unique 하지 않은 수의 개수를 구하는 문제
- 배열을 먼저 나온 숫자를 키로 나온 개수를 값으로 하여 map에 저장한 뒤,
- 값을 리스트로 꺼내 오름차순으로 정렬합니다.
- 값의 개수를 uniqueCount로 지정하고 하나씩 꺼내
- k보다 작거나 같은 경우 k에서 해당 개수를 빼고 uniqueCount도 하나 감소합니다.
- 만약 k보다 큰 경우라면 반복을 종료하고 이때 uniqueCount를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N) (N <= 10^5) 

### 2418. Sort the People ```EASY```
- 이름 배열과 키 배열이 주어졌을 때 키가 큰 순서대로 이름 배열을 정렬하여 반환하는 문제
- 키가 중복되지 않는다는 조건 하에 키를 key로 하고 이름을 value로 한 map을 생성합니다.
- 이후 키 배열을 정렬하고 뒤에서부터 해당 키에 맞는 사용자 이름을 찾아 정답 배열에 넣은 뒤 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N) (N <= 1000)

### ```EASY```



