# 문제 풀이

### 2678. Number of Senior Citizens ```EASY```
- 승객 정보(전화번호 + 성별 + 나이 + 좌석) 목록이 주어졌을 때 60세가 넘는 승객의 수를 구하는 문제
- 승객 정보에서 11, 12번째 문자를 찾아서 나이인 숫자로 변환한 뒤, 60이 넘는 경우를 찾아 그 수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### 1508. Range Sum of Sorted Subarray Sums ```MEDIUM```
- 주어진 숫자 배열의 모든 부분합을 구한 뒤 오름차순 정렬했을 때 left와 right 를 포함한 사이 숫자의 합을 구하는 문제
- 먼저 나올 수 있는 모든 부분합의 수인 n * (n + 1) / 2 크기의 배열을 만들고 처음부터 이중 for 문을 돌면서 부분합을 구해 배열에 저장합니다.
- 이후 이를 오름차순으로 정렬하고 left 부터 right까지 돌면서 해당 위치의 수를 기존 값에 더한 뒤 10 ^ 9 + 7로 나눈 수를 합으로 구합니다.
- 이렇게 반복해서 구해진 합을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n^2) (n <= 1000)
 
### 273. Integer to English Words ```HARD```
- 숫자가 주어졌을 때 해당 숫자를 영어로 읽은 경우를 문자로 출력하는 문제
- 해당 숫자에 대해 "Billion", "Milloion", "Thousand", "Hundred" 를 적절히 붙여햐 하기 때문에 그 구분점이 되는 숫자보다 큰 경우 해당 수로 나눈 뒤 몫에 해당하는 부분을 다시 재귀 함수에 파라미터로 전달합니다.
- 이후 해당 더 큰 부분에 대해 문자열로 정리가 되면 그 이후 "Billion", "Milloion", "Thousand", "Hundred" 를 추가하고 해당 수로 나눈 나머지를 원래 수로 대체합니다.
- 그런 다음 계속해서 "Billion", "Milloion", "Thousand", "Hundred"로 구분될 수 있는 수로 나눈 뒤 위 과정을 반복합니다.
- 만약 숫자가 100보다 작고 20보다 큰 경우에는 숫자를 10으로 나눈 뒤 tens에 해당 하는 숫자를 찾아 문자를 추가하고 
- 20보다 작고 10보다 큰 경우에는 숫자에서 10을 뺀 뒤, teens에 해당하는 문자열을 추가합니디.
- 마지막으로 10보다 작고 0보다 큰 수가 남았다면 ones에서 해당하는 숫자의 문자를 찾아 추가한 뒤 최종적으로 해당 값에서 마지막 공백을 제거하고 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(logN) (N <= 2 ^31 - 1)

### 703. Kth Largest Element in a Stream ```EASY```
- 주어진 숫자들을 추가하여 k 번째로 큰 수를 추가할 때마다 반환하는 문제
- KthLargest 라는 클래스의 생성자에서 k와 초기 배열을 받고 클래스 내부에 k+1 배열을 만들어 추가합니다.
- 추가하는 add 메서드는 힙이 이미 k개의 요소로 가득 차 있다면 (size == k), 새로 추가하려는 값 val이 현재 힙의 루트(최소값)보다 작으면 val은 힙에 추가될 필요가 없습니다. 이 경우 힙의 최소값인 heap[1]을 반환합니다.
- 그렇지 않다면 pop()을 호출하여 최소값을 제거하고 새로운 값을 힙에 추가할 준비를 합니다.
- 그리고 나서 새로운 값을 힙 배열의 다음 빈 자리에 추가합니다. 여기서 size는 배열의 현재 크기를 나타내며, 추가 후 1 증가합니다.
- 새로 추가된 요소는 힙의 맨 마지막에 위치하게 됩니다. 이 요소가 힙의 조건을 만족하도록 상위 노드와 비교하여 자리를 바꿉니다(상향 조정). 이 과정은 힙 트리에서 새로운 요소가 적절한 위치를 찾을 때까지 반복됩니다.
- 힙의 루트에 있는 값(최소값)을 반환합니다. 이 값이 현재 k번째로 큰 값입니다.
- pop 메서드는 힙의 루트(최소값)를 제거하고, 마지막 요소를 루트로 이동시킨 후 힙의 크기를 1 줄입니다.
- 루트로 이동된 요소가 힙의 조건을 만족할 때까지 하위 노드와 비교하여 자리를 바꿉니다(하향 조정). 이 과정은 힙 트리에서 루트의 요소가 적절한 위치를 찾을 때까지 반복됩니다.
- 시간 복잡도: O(logK) (K <= 10000)

### 40. Combination Sum II ```MEDIUM```
- 후보자 숫자 배열과 타겟 숫자가 주어졌을 때 후보자 숫자를 더해 타겟 숫자가 되는 숫자 배열의 모음을 구하는 문제
- 이 문제는 백트래킹을 사용하여 해결할 수 있습니다.
- 먼저 재귀 호출을 하는 함수를 생성하는데 파라미터로 현재 위치(인덱스), 후보자 배열, 타겟 숫자, 정답 목록, 현재까지 모인 숫자 배열을 가집니다.
- target 이 0인 경우 현재까지의 숫자 배열을 정답 배열에 저장한 뒤 재귀를 종료합니다.
- 그렇지 않은 경우 현재 인덱스부터 전체 후보자 개수만큼 반복하면서
- 현재 인덱스보다 i가 크고 i번째 후보자 수와 i - 1의 후보자 수가 같은 경우 재귀 함수를 호출해도 결과가 동일하기 때문에 다음 수를 확인하고 (continue)
- 만약 i번째 후보자 수가 target 보다 큰 경우 합을 구해도 계속 target 보다 크기 때문에 반복을 중단합니다. (break)
- 위 2가지 경우에 해당하지 않는다면 해당 후보자 수를 선택한 것으로 하고 선택한 배열에 추가합니다.
- 그리고 재귀 함수를 호출하는데 이때 인덱스는 i + 1로 증가시키고 target은 현재 뽑은 i번째 후보자 수를 뺀 값을 전달합니다.
- 이렇게 재귀를 돌고 나면 선택한 배열에서 마지막 수를 제거하여 다음 값들을 추가해 확인할 수 있도록 합니다.
- n개의 수에 대해 선택하고 다음으로 갈지, 선택하지 않고 다음으로 갈지 2가지 경우의 수가 존재하고 최악의 경우 모든 조합을 고려해야 하기 때문에 2 ^ n 시간 복잡도를 가집니다.
- 시간 복잡도: O(2 ^ n) (n <= 100)

### 58. Length of Last Word ```EASY```
- 문자열이 주어졌을 때 ' ' 기준으로 마지막 단어의 길이를 구하는 문제
- 앞뒤 공백ㅇ르 제거한 다음 뒤에서부터 확인하여 ' '를 만날 때까지 길이를 증가시키다가 ' '를 만나면 지금까지 길이를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 10000)

### 860. Lemonade Chage ```EASY```
- 5, 10, 20 으로 지불할 돈이 주어졌을 때 5달러 레몬에이드를 사고 정확하게 돈을 거슬러 줄 수 있는지를 구하는 문제
- bills를 하나씩 돌면서 bill이 5이면 five 변수의 개수를 증가시키고
- bill이 10이면 five 개수가 0보다 작거나 같은 경우는 거슬러줄 수 없으므로 false 를 반환하고 거슬러줄 수 있다면 five--, ten++ 시킵니다.
- bill이 20이면 ten의 개수가 0보다 클 때는 five 개수를 확인해 five가 0보다 작거나 같으면 false 반환, 아닌 경우 five--, ten-- 시킵니다.
- bill이 20이고 ten이 없다면 five의 개수를 확인해서 3개 미만이면 false를 반환하고 아니면 five - 3을 합니다.
- 중간에 반환되지 않은 경우 모두 거스름 돈을 준 것으로 판단해 true 를 반환합니다.
- 시간 복잡도: O(n) (n <= 100000)

### 624. Maximum Distance in Arrays ```MEDIUM```
- 오름차순으로 정렬된 숫자 배열의 배열이 주어졌을 때 서로 다른 배열에서 값을 하나씩 뽑아 둘 사이의 절댓값의 최댓값을 구하는 문제
- 최솟값, 최솟값이 나온 리스트의 인덱스, 두번째 최솟값, 최댓값, 최댓값이 나온 리스트의 인덱스, 두번째 최댓값을 각각 저장할 변수를 정의합니다.
- 전체 리스트를 돌면서 현재 리스트의 최솟값, 최댓값을 구하고
- 최솟값보다 현재 최솟값이 작다면 원래 최솟값을 두번째 최솟값으로 옮기고 현재 최솟값을 최솟값으로 지정한 뒤, 최솟값이 나온 리스트 인덱스도 갱신합니다.
- 위 경우가 아니라면 현재 최솟값이 두번째 최솟값보다 작은지 확인하고 그렇다면 두번째 최솟값을 현재 최솟값으로 갱신합니다.
- 그리고 최댓값보다 현재 최댓값이 크다면 원래 최댓값을 두번째 최댓값으로 옮기고 현재 최댓값을 최댓값으로 지정한 뒤, 최댓값이 나온 리스트 인덱스도 갱신합니다.
- 위 경우가 아니라면 현재 최댓값이 두번째 최댓값보다 큰지 확인하고 그렇다면 두번째 최댓값을 현재 최댓값으로 갱신합니다.
- 마지막으로 최솟값 인덱스와 최댓값 인덱스가 같다면 (최솟값 - 두번째 최댓값) 의 절댓값과 (최댓값 - 두번째 최솟값) 의 절댓값 중 더 큰값을 반환하고 두 인덱스가 다르다면 (최댓값 - 최솟값) 을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100000)

### 1937. Maximum Number of Points with Cost ```MEDIUM```
- 이차원 배열이 주어졌을 때 각 row의 값을 다른 row의 값과 더하고 col 떨어진 만큼 뺀다고 했을 때 구할 수 있는 최댓값을 구하는 문제
- 먼저 이전 row 정보를 담을 previousRow와 현재 row 정보를 담을 currentRow 를 만든 다음
- 각 row를 돌면서 왼쪽에서 한번 오른쪽에서 한번 최댓값을 확인합니다.
- runningMax라는 값을 통해 현재 row의 최대 값을 구하는데 먼저 왼쪽에서 차례로 돌면서 runningMax - 1 과 이전 row의 현재 위치 값 중 더 큰 값을 runningMax로 지정하고 해당 값을 현재 row의 위치 값으로 저장합니다.
- 다음으로 다시 runningMax라는 값을 0으로 초기화 하고 오른쪽에서 왼쪽으로 확인합니다. 이때 현재 row의 위치 값으로 저장 전 왼쪽에서 오른쪽으로 확인할 때의 값과 비교해 큰 값을 찾고 그 값에 실제 현재 위치의 값을 더해줍니다.
- 그리고 currentRow를 previousRow로 변경합니다.
- 마지막으로 마지막 previousRow에서 max 값을 찾아 문제를 해결할 수 있습니다.
- 이 문제는 dp와 슬라이딩 원도우 방식을 조합하여 해결할 수 있습니다.
- 시간 복잡도: O(n * m) (n, m <= 100000, n * m <= 100000)

### 264. Ugly Number II ```MEDIUM```
- 2, 3, 5를 소수로 가지는 n 번째 수를 구하는 문제
- 이 문제는 dp를 통해 해결할 수 있는데
- 먼저 dp 배열을 n+1 크기만큼 만들고 dp[1] = 1을 지정합니다.
- 그리고 반복할 때마다 더할 인덱스를 p2, p3, p5로 지정합니다.
- 2부터 n까지 반복하면서 이미 구한 수인 dp[p2], dp[p3], dp[p5]의 수에 각각 2, 3, 5를 곱해 현재 수들을 구하고 그중 가장 작은 수를 dp[i]에 추가합니다.
- 그리고 해당 수가 2의 배수였다면 p2를 3의 배수였다면 p3를 5의 배수였다면 p5를 1 증가시킵니다.
- 이렇게 해당하는 모든 수를 구한 뒤 dp[n]을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1690)

### 650. 2 Keys Keyboard ```MEDIUM```
- 숫자 n 이 주어졌을 때 복사, 붙여넣기로 n개의 A 문자를 만드는 최소 횟수를 구하는 문제
- 이 문제는 가장 큰 소인수를 찾아 단순히 필요한 연산 수를 더하는 방법으로 문제를 해결할 수 있습니다.
- 먼저 주어진 수가 1이라면 바로 0을 반환합니다.
- 이후 주어진 숫자가 1보다 큰 경우 반복을 하는데 주어진 숫자를 factor 의 배수인지 확인합니다.
- 배수가 맞다면 steps에 factor를 더하고 주어진 숫자는 factor로 나는 몫으로 변경합니다.
- 이렇게 반복하다가 주어진 수가 factor의 배수가 아니라면 더이상 factor로 나눌 수 없기 때문에 factor를 증가시킵니다.
- 이런 과정을 처음 주어진 숫자가 1보다 클 동안 반복하고 최종적으로 steps를 반환하여 문제를 해결할 수 있습니다.
- 이 방법은 우선 (전체 복사 + 붙여 넣기) 2가지 연산을 기준으로 그 배수들을 모두 찾은 뒤 더이상 없다면 연산 횟수를 증가 시키는 방식으로 이해할 수 있습니다.
- 예를 들어 n = 12 라고 하면 2로 나누고 6을 다시 2로 나누고 3은 2로 나눌 수 없기 때문에 3으로 나눈 2 + 2 + 3 = 7 연산으로 해결할 수 있음을 알 수 있습니다.
- 시간 복잡도: O(√n) (n <= 1000)

### 1140. Stone Game II ```MEDIUM```
- 돌의 개수가 배열로 주어졌을 때 앨리스가 얻을 수 있는 최대 돌의 개수를 구하는 문제
- 돌은 각 턴에 1에서 2M 사이의 무더기에서 돌을 가져갈 수 있습니다. 돌을 가져간 후 M은 max(M, X)로 업데이트 합니다.
- 이 문제는 **다이나믹 프로그래밍(DP)**과 **깊이 우선 탐색(DFS)**을 조합한 방법으로 해결할 수 있습니다. Alice가 얻을 수 있는 최대 돌의 개수를 구하기 위해, DFS를 사용해 모든 가능한 경우를 탐색하고, 그 결과를 DP 테이블에 저장합니다.
- 누적 합 배열인 s에서 s[i]는 piles[0]부터 piles[i-1]까지의 돌 개수의 합을 저장합니다. 이를 통해 특정 구간의 돌 개수를 빠르게 계산할 수 있습니다.
- DFS 방식으로 각 상태에서 최적의 결과를 찾고 동일한 상태를 여러 번 계산하는 것을 방지하기 위해, 계산된 결과를 f에 저장합니다. f[i][m]은 현재 인덱스 i와 현재 M = m일 때 Alice가 얻을 수 있는 최대 돌의 개수를 나타냅니다.
- DFS 함수는 현재 인덱스 i와 현재 M 값을 가지고, 남은 돌무더기에서 Alice가 최적의 방법으로 가져갈 수 있는 최대 돌 개수를 계산합니다.
- Alice가 현재 남은 돌무더기를 모두 가져갈 수 있다면(```m * 2 >= n - i```) 바로 남은 돌무더기 수를 반환합니다.
- 현재 남은 모든 돌무더기를 가져갈 수 없지만 이미 최적의 값이 구해졌다면 그 값을 반환합니다.
- 두 경우가 모두 아니라면 for 루프를 돌면서 Alice가 현재 턴에 가져갈 수 있는 모든 가능한 돌의 개수를 구합니다. x는 Alice가 가져갈 수 있는 돌무더기 수를 의미합니다 (1부터 2 * m까지).
- 각 x에 대해, Bob이 다음 턴에서 최적으로 행동한다고 가정하고, Bob이 가져간 후 남은 돌 개수를 계산합니다. 이를 통해 Alice가 최대한 많이 가져갈 수 있는 경우를 찾습니다.
- Alice의 최적 선택을 찾기 위해, 각 x에 대해 가능한 최대 돌 개수를 계산한 후, 그 중 최대값을 선택합니다. 이 값을 res에 저장합니다.
- 최종 결과를 배열 f에 저장하고 반환합니다.
- 시간 복잡도: O(n ^ 2) (n <= 100)

### 1460. Make Two Arrays Equal by Reversing Subarrays ```EASY```
- 두 배열이 주어졌을 때 부분 배열을 찾아 reverse 해서 원래 target 배열을 만들 수 있는지 여부를 구하는 문제
- 이 문제는 두 배열에 동일한 수가 들어있는 경우 항상 가능하기 때문에 두 배열의 수가 같은지 비교하면 문제를 해결할 수 있습니다.
- 먼저 배열에서 나올 수 있는 수의 최대 값인 1000까지를 담을 수 있는 buffer 배열을 만들고
- target의 각 수에 해당하는 인덱스 값을 증가시킵니다.
- 그런 다음 arr의 각 수에 해당하는 buffer 배열 위치의 크기가 0이라면 기존에 나오지 않은 숫자이거나 이미 다 찾은 경우로 false를 반환하고 아닌 경우 buffer에서 해당 인덱스 값을 감소시킵니다.
- 이 순회를 모두 통과하면 true를 반환하고 target, arr 배열을 2변 번갈아 비교해 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000)

### 476. Number Complement ```EASY```
- 숫자가 주어졌을 때 이진수로 바꾼 뒤, 0과 1을 뒤집어 나온 10진수 수를 구하는 문제
- 이 문제는 bit 연산을 통해 해결할 수 있습니다.
- 정수 num의 비트 보수를 찾는 기능을 수행합니다. (비트 보수란, 이진수 표현에서 1을 0으로, 0을 1로 변환한 결과입니다.)
- 먼저 ```Integer.highestOneBit(num)``` 이 메서드는 주어진 num에서 가장 높은 자리의 1 비트만 남기고 나머지 비트를 모두 0으로 만드는 비트를 반환합니다. 예를 들어, num = 5일 때, 이진수로 101입니다. 여기서 가장 높은 자리의 1 비트는 100이므로, Integer.highestOneBit(5)는 100을 반환합니다.
- ```(Integer.highestOneBit(num) << 1) - 1``` highestOneBit 결과를 왼쪽으로 한 칸 이동시켜, 가장 높은 자리의 1 비트 뒤에 0을 추가합니다. 그런 다음 -1을 수행하여 모든 비트를 1로 채웁니다. 예를 들어, num = 5일 때, highestOneBit이 100이라면, << 1로 1000이 됩니다. 여기서 -1을 하면 0111이 됩니다. 이 0111이 바로 m입니다.
- ```num ^ m``` XOR 연산(^)을 사용하여 num과 m을 비교합니다. 이 연산은 두 비트가 다르면 1, 같으면 0이 됩니다. 결과적으로, 이 연산은 num의 비트 보수를 계산합니다. 예를 들어, num = 5 (101)이고, m = 7 (0111)이면, 101 ^ 0111 = 010이 됩니다. 즉, num의 보수는 2입니다.
- 시간 복잡도: O(1)

### 145. Binary Tree Postorder Traversal ```EASY```
- TreeNode가 주어졌을 때 후위순회(left -> right -> middle)를 통해 값을 읽어 리스트로 반환하는 문제
- TreeNode를 재귀 함수에 전달하여 값을 확인하면서 먼저 현재 root가 null 인 경우 재귀를 멈추고
- 그렇기 않다면 왼쪽부터 비교해서 재귀를 돌고 그 다음 오른쪽 노드를 확인하여 재귀를 돈 뒤, 마지막으로 현재 노드의 값을 List에 넣은 뒤 최종적으로 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### 590. N-ary Tree Postorder Traversal ```EASY```
- Node와 그 하위 노드들이 List로 주어졌을 때 post order 방식으로 읽어 값을 반환하는 문제
- 145와 유사하게 현재 Node 가 null 인 경우 바로 return, 현재 node의 children이 null 인 경우 현재 node의 값만 저장한 뒤 바로 return
- 현재 node의 children이 null 이 아닌 경우 for 문으로 반복하며 재귀 호출 후 마지막으로 현재 node의 값을 리스트에 저장한 뒤 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 10000)

### 1514. Path with Maximum Probability ```MEDIUM```
- n개의 노드가 방향 없이 연결되어 있고 연결된 간선에 값이 주어졌을 때 start_node에서 end_node까지 연결되는 값의 최대값을 구하는 문제
- 이 문제는 BFS로 해결하려고 했지만 시간 초과로 다른 방식을 사용하였습니다.
- 먼저 maxProb 배열을 선언하고, start_node의 확률을 1.0으로 초기화합니다. 이 배열은 각 노드에 도달할 수 있는 최대 확률을 저장합니다.
- 그리고 그래프에서 최대 n-1번의 반복을 수행하며, 각 간선을 확인하고 해당 간선이 더 높은 확률의 경로를 제공하는지 검사합니다. 각 간선 (u, v)에 대해, u에서 v로, 또는 v에서 u로 가는 경로의 확률을 계산하고, 만약 계산된 확률이 기존의 maxProb보다 크면 이를 업데이트합니다.
- 어떤 반복에서 더 이상 확률이 업데이트되지 않으면(updated가 false), 알고리즘은 더 이상 반복할 필요가 없으므로 루프를 종료합니다.
- end_node에 저장된 최대 확률 값을 반환합니다.
- 시간 복잡도: O(n * e) (n <= 10^4, e <= 2 * 10^4)

### 1905. Count Sub Islands ```MEDIUM```
- 물과 섬을 나타내는 2개의 그리드가 주어졌을 때 2번째 그리드의 섬 중 1번째 그리드의 섬에 포함되는 개수를 구하는 문제
- 이 문제는 DFS 방식으로 해결하였습니다.
- 먼저 DFS 방식으로 두번째 그리드에서 섬을 찾아 그 수를 세는데 두번째 그리드의 섬 일부를 확인할 때 만약 첫번째 그리드의 섬에 포함되지 않는 경우 isNotContain을 true로 설정해 해당 섬 자체를 count 하지 않도록 하고
- 그렇지 않고 연결된 모든 섬을 확인하는 동안 첫번째 그리드에서도 모두 섬이었다면 그때만 수를 세어 최종적으로 반환하면 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N * M) (N, M <= 500)

### ```EASY```



