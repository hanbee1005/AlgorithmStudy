# 문제 풀이

### 2678. Number of Senior Citizens ```EASY```
- 승객 정보(전화번호 + 성별 + 나이 + 좌석) 목록이 주어졌을 때 60세가 넘는 승객의 수를 구하는 문제
- 승객 정보에서 11, 12번째 문자를 찾아서 나이인 숫자로 변환한 뒤, 60이 넘는 경우를 찾아 그 수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### 1508. Range Sum of Sorted Subarray Sums ```MEDIUM```
- 주어진 숫자 배열의 모든 부분합을 구한 뒤 오름차순 정렬했을 때 left와 right 를 포함한 사이 숫자의 합을 구하는 문제
- 먼저 나올 수 있는 모든 부분합의 수인 n * (n + 1) / 2 크기의 배열을 만들고 처음부터 이중 for 문을 돌면서 부분합을 구해 배열에 저장합니다.
- 이후 이를 오름차순으로 정렬하고 left 부터 right까지 돌면서 해당 위치의 수를 기존 값에 더한 뒤 10 ^ 9 + 7로 나눈 수를 합으로 구합니다.
- 이렇게 반복해서 구해진 합을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n^2) (n <= 1000)
 
### 273. Integer to English Words ```HARD```
- 숫자가 주어졌을 때 해당 숫자를 영어로 읽은 경우를 문자로 출력하는 문제
- 해당 숫자에 대해 "Billion", "Milloion", "Thousand", "Hundred" 를 적절히 붙여햐 하기 때문에 그 구분점이 되는 숫자보다 큰 경우 해당 수로 나눈 뒤 몫에 해당하는 부분을 다시 재귀 함수에 파라미터로 전달합니다.
- 이후 해당 더 큰 부분에 대해 문자열로 정리가 되면 그 이후 "Billion", "Milloion", "Thousand", "Hundred" 를 추가하고 해당 수로 나눈 나머지를 원래 수로 대체합니다.
- 그런 다음 계속해서 "Billion", "Milloion", "Thousand", "Hundred"로 구분될 수 있는 수로 나눈 뒤 위 과정을 반복합니다.
- 만약 숫자가 100보다 작고 20보다 큰 경우에는 숫자를 10으로 나눈 뒤 tens에 해당 하는 숫자를 찾아 문자를 추가하고 
- 20보다 작고 10보다 큰 경우에는 숫자에서 10을 뺀 뒤, teens에 해당하는 문자열을 추가합니디.
- 마지막으로 10보다 작고 0보다 큰 수가 남았다면 ones에서 해당하는 숫자의 문자를 찾아 추가한 뒤 최종적으로 해당 값에서 마지막 공백을 제거하고 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(logN) (N <= 2 ^31 - 1)

### 703. Kth Largest Element in a Stream ```EASY```
- 주어진 숫자들을 추가하여 k 번째로 큰 수를 추가할 때마다 반환하는 문제
- KthLargest 라는 클래스의 생성자에서 k와 초기 배열을 받고 클래스 내부에 k+1 배열을 만들어 추가합니다.
- 추가하는 add 메서드는 힙이 이미 k개의 요소로 가득 차 있다면 (size == k), 새로 추가하려는 값 val이 현재 힙의 루트(최소값)보다 작으면 val은 힙에 추가될 필요가 없습니다. 이 경우 힙의 최소값인 heap[1]을 반환합니다.
- 그렇지 않다면 pop()을 호출하여 최소값을 제거하고 새로운 값을 힙에 추가할 준비를 합니다.
- 그리고 나서 새로운 값을 힙 배열의 다음 빈 자리에 추가합니다. 여기서 size는 배열의 현재 크기를 나타내며, 추가 후 1 증가합니다.
- 새로 추가된 요소는 힙의 맨 마지막에 위치하게 됩니다. 이 요소가 힙의 조건을 만족하도록 상위 노드와 비교하여 자리를 바꿉니다(상향 조정). 이 과정은 힙 트리에서 새로운 요소가 적절한 위치를 찾을 때까지 반복됩니다.
- 힙의 루트에 있는 값(최소값)을 반환합니다. 이 값이 현재 k번째로 큰 값입니다.
- pop 메서드는 힙의 루트(최소값)를 제거하고, 마지막 요소를 루트로 이동시킨 후 힙의 크기를 1 줄입니다.
- 루트로 이동된 요소가 힙의 조건을 만족할 때까지 하위 노드와 비교하여 자리를 바꿉니다(하향 조정). 이 과정은 힙 트리에서 루트의 요소가 적절한 위치를 찾을 때까지 반복됩니다.
- 시간 복잡도: O(logK) (K <= 10000)

### 40. Combination Sum II ```MEDIUM```
- 후보자 숫자 배열과 타겟 숫자가 주어졌을 때 후보자 숫자를 더해 타겟 숫자가 되는 숫자 배열의 모음을 구하는 문제
- 이 문제는 백트래킹을 사용하여 해결할 수 있습니다.
- 먼저 재귀 호출을 하는 함수를 생성하는데 파라미터로 현재 위치(인덱스), 후보자 배열, 타겟 숫자, 정답 목록, 현재까지 모인 숫자 배열을 가집니다.
- target 이 0인 경우 현재까지의 숫자 배열을 정답 배열에 저장한 뒤 재귀를 종료합니다.
- 그렇지 않은 경우 현재 인덱스부터 전체 후보자 개수만큼 반복하면서
- 현재 인덱스보다 i가 크고 i번째 후보자 수와 i - 1의 후보자 수가 같은 경우 재귀 함수를 호출해도 결과가 동일하기 때문에 다음 수를 확인하고 (continue)
- 만약 i번째 후보자 수가 target 보다 큰 경우 합을 구해도 계속 target 보다 크기 때문에 반복을 중단합니다. (break)
- 위 2가지 경우에 해당하지 않는다면 해당 후보자 수를 선택한 것으로 하고 선택한 배열에 추가합니다.
- 그리고 재귀 함수를 호출하는데 이때 인덱스는 i + 1로 증가시키고 target은 현재 뽑은 i번째 후보자 수를 뺀 값을 전달합니다.
- 이렇게 재귀를 돌고 나면 선택한 배열에서 마지막 수를 제거하여 다음 값들을 추가해 확인할 수 있도록 합니다.
- n개의 수에 대해 선택하고 다음으로 갈지, 선택하지 않고 다음으로 갈지 2가지 경우의 수가 존재하고 최악의 경우 모든 조합을 고려해야 하기 때문에 2 ^ n 시간 복잡도를 가집니다.
- 시간 복잡도: O(2 ^ n) (n <= 100)

### 58. Length of Last Word ```EASY```
- 문자열이 주어졌을 때 ' ' 기준으로 마지막 단어의 길이를 구하는 문제
- 앞뒤 공백ㅇ르 제거한 다음 뒤에서부터 확인하여 ' '를 만날 때까지 길이를 증가시키다가 ' '를 만나면 지금까지 길이를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 10000)

### 860. Lemonade Chage ```EASY```
- 5, 10, 20 으로 지불할 돈이 주어졌을 때 5달러 레몬에이드를 사고 정확하게 돈을 거슬러 줄 수 있는지를 구하는 문제
- bills를 하나씩 돌면서 bill이 5이면 five 변수의 개수를 증가시키고
- bill이 10이면 five 개수가 0보다 작거나 같은 경우는 거슬러줄 수 없으므로 false 를 반환하고 거슬러줄 수 있다면 five--, ten++ 시킵니다.
- bill이 20이면 ten의 개수가 0보다 클 때는 five 개수를 확인해 five가 0보다 작거나 같으면 false 반환, 아닌 경우 five--, ten-- 시킵니다.
- bill이 20이고 ten이 없다면 five의 개수를 확인해서 3개 미만이면 false를 반환하고 아니면 five - 3을 합니다.
- 중간에 반환되지 않은 경우 모두 거스름 돈을 준 것으로 판단해 true 를 반환합니다.
- 시간 복잡도: O(n) (n <= 100000)

### 624. Maximum Distance in Arrays ```MEDIUM```
- 오름차순으로 정렬된 숫자 배열의 배열이 주어졌을 때 서로 다른 배열에서 값을 하나씩 뽑아 둘 사이의 절댓값의 최댓값을 구하는 문제
- 최솟값, 최솟값이 나온 리스트의 인덱스, 두번째 최솟값, 최댓값, 최댓값이 나온 리스트의 인덱스, 두번째 최댓값을 각각 저장할 변수를 정의합니다.
- 전체 리스트를 돌면서 현재 리스트의 최솟값, 최댓값을 구하고
- 최솟값보다 현재 최솟값이 작다면 원래 최솟값을 두번째 최솟값으로 옮기고 현재 최솟값을 최솟값으로 지정한 뒤, 최솟값이 나온 리스트 인덱스도 갱신합니다.
- 위 경우가 아니라면 현재 최솟값이 두번째 최솟값보다 작은지 확인하고 그렇다면 두번째 최솟값을 현재 최솟값으로 갱신합니다.
- 그리고 최댓값보다 현재 최댓값이 크다면 원래 최댓값을 두번째 최댓값으로 옮기고 현재 최댓값을 최댓값으로 지정한 뒤, 최댓값이 나온 리스트 인덱스도 갱신합니다.
- 위 경우가 아니라면 현재 최댓값이 두번째 최댓값보다 큰지 확인하고 그렇다면 두번째 최댓값을 현재 최댓값으로 갱신합니다.
- 마지막으로 최솟값 인덱스와 최댓값 인덱스가 같다면 (최솟값 - 두번째 최댓값) 의 절댓값과 (최댓값 - 두번째 최솟값) 의 절댓값 중 더 큰값을 반환하고 두 인덱스가 다르다면 (최댓값 - 최솟값) 을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100000)

### 1937. Maximum Number of Points with Cost ```MEDIUM```
- 이차원 배열이 주어졌을 때 각 row의 값을 다른 row의 값과 더하고 col 떨어진 만큼 뺀다고 했을 때 구할 수 있는 최댓값을 구하는 문제
- 먼저 이전 row 정보를 담을 previousRow와 현재 row 정보를 담을 currentRow 를 만든 다음
- 각 row를 돌면서 왼쪽에서 한번 오른쪽에서 한번 최댓값을 확인합니다.
- runningMax라는 값을 통해 현재 row의 최대 값을 구하는데 먼저 왼쪽에서 차례로 돌면서 runningMax - 1 과 이전 row의 현재 위치 값 중 더 큰 값을 runningMax로 지정하고 해당 값을 현재 row의 위치 값으로 저장합니다.
- 다음으로 다시 runningMax라는 값을 0으로 초기화 하고 오른쪽에서 왼쪽으로 확인합니다. 이때 현재 row의 위치 값으로 저장 전 왼쪽에서 오른쪽으로 확인할 때의 값과 비교해 큰 값을 찾고 그 값에 실제 현재 위치의 값을 더해줍니다.
- 그리고 currentRow를 previousRow로 변경합니다.
- 마지막으로 마지막 previousRow에서 max 값을 찾아 문제를 해결할 수 있습니다.
- 이 문제는 dp와 슬라이딩 원도우 방식을 조합하여 해결할 수 있습니다.
- 시간 복잡도: O(n * m) (n, m <= 100000, n * m <= 100000)

### 264. Ugly Number II ```MEDIUM```
- 2, 3, 5를 소수로 가지는 n 번째 수를 구하는 문제
- 이 문제는 dp를 통해 해결할 수 있는데
- 먼저 dp 배열을 n+1 크기만큼 만들고 dp[1] = 1을 지정합니다.
- 그리고 반복할 때마다 더할 인덱스를 p2, p3, p5로 지정합니다.
- 2부터 n까지 반복하면서 이미 구한 수인 dp[p2], dp[p3], dp[p5]의 수에 각각 2, 3, 5를 곱해 현재 수들을 구하고 그중 가장 작은 수를 dp[i]에 추가합니다.
- 그리고 해당 수가 2의 배수였다면 p2를 3의 배수였다면 p3를 5의 배수였다면 p5를 1 증가시킵니다.
- 이렇게 해당하는 모든 수를 구한 뒤 dp[n]을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1690)

### ```EASY```



