# 문제 풀이

### 2678. Number of Senior Citizens ```EASY```
- 승객 정보(전화번호 + 성별 + 나이 + 좌석) 목록이 주어졌을 때 60세가 넘는 승객의 수를 구하는 문제
- 승객 정보에서 11, 12번째 문자를 찾아서 나이인 숫자로 변환한 뒤, 60이 넘는 경우를 찾아 그 수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### 1508. Range Sum of Sorted Subarray Sums ```MEDIUM```
- 주어진 숫자 배열의 모든 부분합을 구한 뒤 오름차순 정렬했을 때 left와 right 를 포함한 사이 숫자의 합을 구하는 문제
- 먼저 나올 수 있는 모든 부분합의 수인 n * (n + 1) / 2 크기의 배열을 만들고 처음부터 이중 for 문을 돌면서 부분합을 구해 배열에 저장합니다.
- 이후 이를 오름차순으로 정렬하고 left 부터 right까지 돌면서 해당 위치의 수를 기존 값에 더한 뒤 10 ^ 9 + 7로 나눈 수를 합으로 구합니다.
- 이렇게 반복해서 구해진 합을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n^2) (n <= 1000)
 
### 273. Integer to English Words ```HARD```
- 숫자가 주어졌을 때 해당 숫자를 영어로 읽은 경우를 문자로 출력하는 문제
- 해당 숫자에 대해 "Billion", "Milloion", "Thousand", "Hundred" 를 적절히 붙여햐 하기 때문에 그 구분점이 되는 숫자보다 큰 경우 해당 수로 나눈 뒤 몫에 해당하는 부분을 다시 재귀 함수에 파라미터로 전달합니다.
- 이후 해당 더 큰 부분에 대해 문자열로 정리가 되면 그 이후 "Billion", "Milloion", "Thousand", "Hundred" 를 추가하고 해당 수로 나눈 나머지를 원래 수로 대체합니다.
- 그런 다음 계속해서 "Billion", "Milloion", "Thousand", "Hundred"로 구분될 수 있는 수로 나눈 뒤 위 과정을 반복합니다.
- 만약 숫자가 100보다 작고 20보다 큰 경우에는 숫자를 10으로 나눈 뒤 tens에 해당 하는 숫자를 찾아 문자를 추가하고 
- 20보다 작고 10보다 큰 경우에는 숫자에서 10을 뺀 뒤, teens에 해당하는 문자열을 추가합니디.
- 마지막으로 10보다 작고 0보다 큰 수가 남았다면 ones에서 해당하는 숫자의 문자를 찾아 추가한 뒤 최종적으로 해당 값에서 마지막 공백을 제거하고 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(logN) (N <= 2 ^31 - 1)

### 703. Kth Largest Element in a Stream ```EASY```
- 주어진 숫자들을 추가하여 k 번째로 큰 수를 추가할 때마다 반환하는 문제
- KthLargest 라는 클래스의 생성자에서 k와 초기 배열을 받고 클래스 내부에 k+1 배열을 만들어 추가합니다.
- 추가하는 add 메서드는 힙이 이미 k개의 요소로 가득 차 있다면 (size == k), 새로 추가하려는 값 val이 현재 힙의 루트(최소값)보다 작으면 val은 힙에 추가될 필요가 없습니다. 이 경우 힙의 최소값인 heap[1]을 반환합니다.
- 그렇지 않다면 pop()을 호출하여 최소값을 제거하고 새로운 값을 힙에 추가할 준비를 합니다.
- 그리고 나서 새로운 값을 힙 배열의 다음 빈 자리에 추가합니다. 여기서 size는 배열의 현재 크기를 나타내며, 추가 후 1 증가합니다.
- 새로 추가된 요소는 힙의 맨 마지막에 위치하게 됩니다. 이 요소가 힙의 조건을 만족하도록 상위 노드와 비교하여 자리를 바꿉니다(상향 조정). 이 과정은 힙 트리에서 새로운 요소가 적절한 위치를 찾을 때까지 반복됩니다.
- 힙의 루트에 있는 값(최소값)을 반환합니다. 이 값이 현재 k번째로 큰 값입니다.
- pop 메서드는 힙의 루트(최소값)를 제거하고, 마지막 요소를 루트로 이동시킨 후 힙의 크기를 1 줄입니다.
- 루트로 이동된 요소가 힙의 조건을 만족할 때까지 하위 노드와 비교하여 자리를 바꿉니다(하향 조정). 이 과정은 힙 트리에서 루트의 요소가 적절한 위치를 찾을 때까지 반복됩니다.
- 시간 복잡도: O(logK) (K <= 10000)

### 40. Combination Sum II ```MEDIUM```
- 후보자 숫자 배열과 타겟 숫자가 주어졌을 때 후보자 숫자를 더해 타겟 숫자가 되는 숫자 배열의 모음을 구하는 문제
- 이 문제는 백트래킹을 사용하여 해결할 수 있습니다.
- 먼저 재귀 호출을 하는 함수를 생성하는데 파라미터로 현재 위치(인덱스), 후보자 배열, 타겟 숫자, 정답 목록, 현재까지 모인 숫자 배열을 가집니다.
- target 이 0인 경우 현재까지의 숫자 배열을 정답 배열에 저장한 뒤 재귀를 종료합니다.
- 그렇지 않은 경우 현재 인덱스부터 전체 후보자 개수만큼 반복하면서
- 현재 인덱스보다 i가 크고 i번째 후보자 수와 i - 1의 후보자 수가 같은 경우 재귀 함수를 호출해도 결과가 동일하기 때문에 다음 수를 확인하고 (continue)
- 만약 i번째 후보자 수가 target 보다 큰 경우 합을 구해도 계속 target 보다 크기 때문에 반복을 중단합니다. (break)
- 위 2가지 경우에 해당하지 않는다면 해당 후보자 수를 선택한 것으로 하고 선택한 배열에 추가합니다.
- 그리고 재귀 함수를 호출하는데 이때 인덱스는 i + 1로 증가시키고 target은 현재 뽑은 i번째 후보자 수를 뺀 값을 전달합니다.
- 이렇게 재귀를 돌고 나면 선택한 배열에서 마지막 수를 제거하여 다음 값들을 추가해 확인할 수 있도록 합니다.
- n개의 수에 대해 선택하고 다음으로 갈지, 선택하지 않고 다음으로 갈지 2가지 경우의 수가 존재하고 최악의 경우 모든 조합을 고려해야 하기 때문에 2 ^ n 시간 복잡도를 가집니다.
- 시간 복잡도: O(2 ^ n) (n <= 100)

### ```EASY```



