# 문제 풀이

### 1497. Check If Array Paris Are Divisible by k ```MEDIUM```
- 크기가 n인 숫자 배열과 k 가 주어졌을 때 k로 나누어 떨어지는 n/2개의 묶음을 구할 수 있는지를 확인하는 문제
- 먼저 k 크기의 배열을 만들어 숫자를 k로 나눈 나머지의 개수를 저장할 배열을 생성합니다.
- 주어진 배열을 순회하면서 숫자를 k로 나누고 그 숫자가 음수일 수 있으니 k를 더한 뒤 다시 k로 나눈 나머지를 구해 나머지 위치의 숫자를 증가시킵니다.
- 이후 만약 짝을 이뤄야 하는데 나머지가 0인 (즉, k로 나누어 떨어지는 수의 개수)가 홀수이면 바로 false를 반환합니다.
- 그렇지 않은 경우 나머지가 i인 원소의 개수는 나머지가 k - i인 원소의 개수와 같아야 합니다. 두 원소를 더하면 k로 나누어떨어지기 때문입니다.
- 그렇지 않으면 바로 false를 반환하고 모든 경우를 확인하고 난 뒤 최종적으로 true를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 10^5)

### 1331. Rank Transform of an Array ```EASY```
- 배열이 주어젔을 때 작은 숫자 순으로 순위를 메겨 반환하는 문제
- 먼저 주어진 배열에서 최솟값과 최댓값을 구한 다음
- 최대, 최소 차이가 200이 넘으면서 배열의 길이는 10 미만인 경우 배열을 정렬한 뒤 중복을 확인하면서 순위를 메깁니다.
- tmp 배열로 원본 배열을 복사한 뒤 원본 배열을 정렬하고 하나씩 반복하면서 값을 가지고 이전에 나온 값인지 확인한 뒤 순위를 저장하는 방식으로 정답을 구해 반환합니다.
- 그렇지 않은 경우는 다른 방식으로 순위를 구합니다.
- 배열 값이 min에서 max 사이의 값들을 기준으로 새로운 nums 배열을 생성합니다. 이 배열은 각 값이 몇 번째 순위인지를 나타냅니다.
- 그 후 nums 배열을 사용해 각 값에 대한 순위를 결정하여 answer 배열에 기록합니다.
- 시간 복잡도: O(n^2) (n <= 10^5)

### ```EASY```



