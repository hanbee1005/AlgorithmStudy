# 문제 풀이

### 1497. Check If Array Paris Are Divisible by k ```MEDIUM```
- 크기가 n인 숫자 배열과 k 가 주어졌을 때 k로 나누어 떨어지는 n/2개의 묶음을 구할 수 있는지를 확인하는 문제
- 먼저 k 크기의 배열을 만들어 숫자를 k로 나눈 나머지의 개수를 저장할 배열을 생성합니다.
- 주어진 배열을 순회하면서 숫자를 k로 나누고 그 숫자가 음수일 수 있으니 k를 더한 뒤 다시 k로 나눈 나머지를 구해 나머지 위치의 숫자를 증가시킵니다.
- 이후 만약 짝을 이뤄야 하는데 나머지가 0인 (즉, k로 나누어 떨어지는 수의 개수)가 홀수이면 바로 false를 반환합니다.
- 그렇지 않은 경우 나머지가 i인 원소의 개수는 나머지가 k - i인 원소의 개수와 같아야 합니다. 두 원소를 더하면 k로 나누어떨어지기 때문입니다.
- 그렇지 않으면 바로 false를 반환하고 모든 경우를 확인하고 난 뒤 최종적으로 true를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 10^5)

### 1331. Rank Transform of an Array ```EASY```
- 배열이 주어젔을 때 작은 숫자 순으로 순위를 메겨 반환하는 문제
- 먼저 주어진 배열에서 최솟값과 최댓값을 구한 다음
- 최대, 최소 차이가 200이 넘으면서 배열의 길이는 10 미만인 경우 배열을 정렬한 뒤 중복을 확인하면서 순위를 메깁니다.
- tmp 배열로 원본 배열을 복사한 뒤 원본 배열을 정렬하고 하나씩 반복하면서 값을 가지고 이전에 나온 값인지 확인한 뒤 순위를 저장하는 방식으로 정답을 구해 반환합니다.
- 그렇지 않은 경우는 다른 방식으로 순위를 구합니다.
- 배열 값이 min에서 max 사이의 값들을 기준으로 새로운 nums 배열을 생성합니다. 이 배열은 각 값이 몇 번째 순위인지를 나타냅니다.
- 그 후 nums 배열을 사용해 각 값에 대한 순위를 결정하여 answer 배열에 기록합니다.
- 시간 복잡도: O(n^2) (n <= 10^5)

### 1813. Sentence Similarity III ```MEDIUM```
- 문자열 2개가 주어졌을 때 중간에 문자열을 추가해서 비슷해질 수 있는지를 구하는 문제
- 문자열 2개를 먼저 빈 문자를 기준으로 자른 뒤 더 긴 문자를 words1로 지정합니다. 길이가 더 작은 문자는 words2로 저장합니다.
- 앞에서부터 한 단어씩 비교하면서 앞쪽에서 같은 개수를 세서 start 변수에 저장합니다.
- 위와 동일하게 뒤에서부터 한 단어씩 비교하면서 뒤쪽에서 같은 개수를 세서 end 변수에 저장합니다.
- 이후 앞에서 같은 단어와 뒤에서 같은 단어의 수를 더해 그 개수가 처음 주어진 문자열 중 길이가 더 짧은 문자열의 문자 수보다 더 크거나 같은 경우 true를 아닌 경우 false를 반환하도록 하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### 2696. Minimum String Length After Removing Substrings ```EASY```
- 문자열이 주어졌을 때 'AB' 또는 'CD'를 제거한 가장 짧은 문자열의 길이를 구하는 문제
- 이 문제는 구현된 Stack을 사용해도 되지만 stack 과 유사한 배열을 만들어 문제를 해결할 수 있습니다.
- 먼저 문자열의 길이 + 1 크기 만큼의 배열을 생성한 뒤, 남은 문자열의 길이를 -1로 지정합니다.
- 문자를 하나씩 돌면서 남은 문자열의 길이가 -1 보다 크면서 마지막 문자가 A 이고 현재 문제가 B 이거나 마지막 문자가 C 이고 현재 문자가 D인 경우는 제거를 해야하므로 마지막 문자의 길이를 -1 합니다.
- 그렇지 않은 경우는 마지막 문자의 길이를 +1 한 다음 해당하는 위치에 현재 문자를 추가합니다.
- 이렇게 모든 문자를 확인한 뒤 마지막 문자의 길이 + 1 한 값을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### 1963. Minimum Number of Swaps to Make the String Balanced ```MEDIUM```
- 정확히 n/2 개의 여는 괄호와 닫는 괄호로 이루어진 길이가 n인 문자열이 주어졌을 때 균형잡힌 문자열을 만들기 위해 스왑하는 최소 횟수를 구하는 문제
- n/2 개의 여는 괄호와 닫는 괄호로 이루어져 있기 때문에 2개의 닫는 괄호와 하나의 여는 괄호를 스왑해야 균형을 맞출 수 있습니다. 즉, 불균형한 닫는 괄호 두개마다 한번의 스왑이 필요합니다.
- 먼저 여는 괄호의 수를 세는 opening 변수와 균형이 맞지 않는 닫는 괄호의 수를 세는 unbalanced 변수를 선언합니다.
- 주어진 문자열의 문자를 하나씩 확인하면서 여는 괄호의 경우 opening 변수의 값을 증가시키고 닫는 괄호의 경우 여는 괄호가 있다면 opening 변수의 수를 감소시켜 짝을 맞추고 그렇지 않은 경우 unbalanced 값을 증가 시킵니다.
- 최종적으로 unbalanced / 2로 스왑을 통해 해결할 수 있는 쌍을 계산합니다. 만약 불균형한 닫는 괄호가 홀수라면, 하나의 스왑으로 해결할 수 없으므로 unbalanced % 2를 더해 추가적인 스왑을 처리하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 10^6)

### 921. Minimum Add to Make Parentheses Valid ```MEDIUM```
- (, )로 이루어진 문자열이 주어졌을 때 유효한 문자를 만들 수 있도록 문자를 이동하는 최소 횟수를 구하는 문제
- 이 문제에서 이야기하는 유효한 문자는 여는 괄호와 닫는 괄호의 수가 동일한 문자입니다.
- 따라서 문자열의 문자를 하나씩 확인하면서 여는 괄호가 나온 경우 여는 괄호의 수를 증가시킵니다.
- 닫는 괄호가 나온 경우는 여는 괄호의 수가 0보다 큰지 확인하고 크다면 여는 괄호와 짝을 이룰 수 있기 때문에 여는 괄호의 수를 감소시킵니다.
- 만약 여는 괄호의 수가 0 이하인 경우는 짝이 맞지 않기 때문에 닫는 괄호의 수를 증가시킵니다.
- 최종적으로 짝을 이루지 못한 여는 괄호의 수와 닫는 괄호의 수를 더해 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000)

### 962. Maximum Width Ramp ```MEDIUM```
- 정수 배열이 주어졌을 때, i < j 이고 nums[i] <= nums[j] 일 때 j - i 의 최댓값을 구하는 문제
- maxOnRight 배열은 주어진 배열 nums의 각 인덱스 i에 대해 오른쪽에 있는 값 중에서 가장 큰 값을 저장합니다.
- 배열의 가장 마지막 값은 그대로 저장하고 배열의 뒤쪽에서부터 순차적으로 maxOnRight를 채웁니다. maxOnRight[i]는 nums[i]와 maxOnRight[i + 1] 중 더 큰 값을 저장하게 됩니다. 즉, i 이후의 최대값을 계속 추적합니다.
- 그리고 left와 right라는 두 개의 포인터를 사용합니다.
- right는 배열의 끝까지 순차적으로 이동하며, left는 right보다 작은 인덱스들 중에서 조건을 만족하는 최소한의 인덱스 위치를 찾습니다. 
- nums[left] <= maxOnRight[right]일 때만 right - left의 값을 계산하여 최대 너비 maxRamp를 업데이트합니다.
- 만약 nums[left] > maxOnRight[right]라면, left를 증가시키며 조건을 만족하는 left를 찾습니다. right는 매 반복마다 증가하며 전체 배열을 탐색합니다.
- 이렇게 찾은 최대 maxRamp를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 5 * 10^4)

### 2530. Maximal Score After Applying K Operations ```MEDIUM```
- 정수 배열과 k 가 주어졌을 때 k 번 연산을 해서 가장 점수가 큰 경우를 구하는 문제
- 주어진 정수 배열에서 가장 큰 수를 구해 매번 연산을 진행하면 되기 때문에 가장 큰 수를 구할 수 있는 우선 순위 큐를 사용하였습니다.
- 먼저 주어진 정수 배열의 수를 모두 우선 순위 큐에 넣은 다음 k 번 반복하면서 큐에서 수를 꺼내 점수에 더하고 꺼낸 수에 2를 더한 뒤 3으로 나눠 올림처리 없이 올림한 수를 다시 큐에 넣습니다.
- 이렇게 반복한 뒤 점수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 10^5)

### 2938. Separate Black and White Balls ```MEDIUM```
- 0과 1로 이루어진 문자열이 주어졌을 때 0을 왼쪽에 1을 오른쪽에 배치하기 위해 swap 해야 하는 최소 수를 구하는 문제
- 이 문제는 문자열을 돌면서 해당 문자가 0인 경우 이전에 나온 black의 수를 모두 swap 해야하므로 swap 변수에 더하고 1인 경우 black의 수를 증가시키는 방식으로 swap 수를 구해 반환하여 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 10^5)

### 1405. Longest Happy String ```MEDIUM```
- a, b, c 각각의 개수가 주어졌을 때 조건을 만족하는 최대 길이의 문자열을 구하는 문제
- 먼저 최대 a + b + c 의 길이만큼 길어질 수 있기 때문에 해당 길이만큼 반복하면서 각 문자를 붙일 수 있는 경우를 구하고 그에 맞게 문자를 붙인 뒤 다른 조건들을 조정하는 과정을 통해 문제를 해결할 수 있습니다.
- 이때 각 문자의 연속되는 수를 구하게 되는데 a를 예로 들면 다음과 같을 때 붙일 수 있습니다. 
  + a의 개수가 b, c의 개수보다 크거나 같으면서 연속된 문자 a의 개수가 2가 아닌 경우
  + 연속된 b의 개수가 2개 이면서 a의 개수가 0보다 큰 경우
  + 연속된 c의 개수가 2개 이면서 a의 개수가 0보다 큰 경우
- 위 경우에 해당한다면 a 문자를 붙이고 a의 개수를 1 감소 시킨 뒤, 연속된 a문자의 수를 1 증가시키고 b,c 문자는 a를 붙임으로써 더 이상 연속된 문자가 아니게 되므로 0으로 지정합니다.
- b,c 도 동일한 방식으로 조건을 확인한 뒤 추가해서 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 300)

### 670. Maximum Swap ```MEDIUM```
- 숫자가 주어졌을 때 각 자리의 수를 한번만 이동 시켜 최대 수를 구하는 문제
- 먼저 주어진 수의 각 자리를 char로 변환하여 배열에 저장하고 주어진 숫자의 길이를 구합니다.
- 그리고 뒤에서부터 확인하면서 각 수의 마지막 인덱스를 별도의 배열로 저장합니다.
- 주어진 문자열의 길이만큼 돌면서 현재 인덱스보다 더 뒤에 큰 수가 있는지 확인하고 더 큰 수가 있다면 문자열을 swap한 뒤 바로 반환합니다. 더 큰 수는 9부터 확인합니다.
- 중간에 swap 과정을 거치지 못하면 원래 주어졌던 숫자를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 9)

### 1593. Split a String into the Max Number of Unique Substrings ```MEDIUM```
- 문자열이 주어졌을 때 겹치지 않는 부분 문자로 나눠 가장 많이 구할 수 있는 부분 문자의 수를 구하는 문제
- 먼저 최대 고유 분할 개수를 저장하는 변수 res를 -1로 초기화합니다.
- 그리고 현재까지 고유한 부분 문자열을 저장하는 해시셋 set을 생성합니다.
- 이후 backtrace 메서드에서 재귀적으로 문자열을 분할합니다.
- startIndex가 문자열의 길이와 같아지면, 모든 부분 문자열이 처리된 것입니다. 이때 현재 고유한 부분 문자열의 개수(set.size())를 사용해 res를 업데이트하고 재귀를 종료합니다.
- i를 startIndex부터 문자열의 끝까지 순회하며 부분 문자열(cur)을 만듭니다. 
- s.substring(startIndex, i + 1)은 현재 분할한 부분 문자열이고 이 부분 문자열이 set에 없다면 추가하고, 백트래킹을 재귀적으로 호출합니다.
- 백트래킹이 끝나면 다시 set에서 해당 문자열을 제거하여 원상복구합니다.
- if(s.length() - 1 - i + set.size() < res) 조건은 이미 최댓값보다 작아질 가능성이 있는 경우, 더 이상 백트래킹을 진행하지 않고 중단하여 불필요한 탐색을 줄입니다.
- 이렇게 백트래킹 방식으로 모든 가능한 부분 문자열을 찾은 뒤 그 개수를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(2^n) (n <= 16)

### 2583. Kth Largest Sum in a Binary Tree ```MEDIUM```
- 이진 트리의 루트 노드와 k 가 주어졌을 때, 트리의 각 level 별로 합을 구해 k 번째로 큰 합을 구하는 문제
- k 개의 합을 담을 우선 순위 큐 pq를 정의합니다. pq에는 큰 합부터 k개를 담습니다.
- 각 노드를 BFS로 순회할 큐 q를 정의합니다. 그리고 초기에 root 노드를 저장합니다.
- 큐가 빈 값이 아닐 동안 돌면서 큐의 사이즈만큼 큐에서 노드를 뽑아 그 값을 더하고 왼쪽 노드와 오른쪽 노드가 있는 경우 다시 큐에 담습니다. 이렇게 해서 각 level의 합을 구할 수 있고 각 level에 속하는 노드들만 한번씩 큐에 담기게 됩니다.
- 이렇게 큐의 크기만큼 반복하며 합을 구한 뒤 합을 담은 pq의 사이즈가 k보다 작은 경우 구한 합을 추가하고 그렇지 않은 경우 pq의 최소값보다 지금의 합이 크다면 최소값을 빼고 지금의 합을 pq에 추가합니다.
- 이렇게 모든 노드를 확인한 뒤, pq의 사이즈가 k보다 작다면 -1을 아니면 pq의 최소값을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 10^5)

### 2641. Cousins in Binary Tree II ```MEDIUM```
- TreeNode 가 주어졌을 때 부모가 같지 않은 같은 레벨 노드의 합으로 각 노드의 값을 변경한 뒤 root 노드를 반환하는 문제
- 이 문제는 BFS 로 노드를 탐색하면서 현재 레벨의 전체 합을 구한 뒤 같은 부모 아래 있는 노드들의 합을 구해 전체 합에서 뺀 수를 해당 노드에 저장하는 방식으로 문제를 해결할 수 있습니다.
- 큐를 생성하여 현재 레벨에 있는 모든 노드를 담은 뒤, 큐의 크기만큼 돌면서 현재 같은 레벨의 노드를 모두 확인하는데 먼저 같은 부모 아래 있는 왼쪽, 오른쪽 노드의 합을 구해 다음 레벨의 합에 합쳐 놓고 현재 노드의 왼쪽, 오른쪽 노드의 값을 -(왼쪽, 오른쪽 노드의 합)으로 지정한 뒤 현재 레벨의 전체 합을 현재 노드의 값에 더합니다. 
- 그리고 왼쪽, 오른쪽 노드에서 null 이 아닌 경우 큐에 담습니다. 현재 레벨의 모든 노드를 확인하고 나면 다음 레벨의 합을 현재 레벨의 합으로 지정한 뒤, 다시 큐를 확인해 다음 레벨도 위와 같이 확인하고 모든 노드를 확인하면 루트 노드를 반환해 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 10^5)

### 951. Flip Equivalent Binary Trees ```MEDIUM```
- 두개의 트리 노드가 주어졌을 때 한 노드의 양쪽 노드를 flip 하여 두개의 트리가 같아질 수 있는 경우 true, 아닌 경우 flase 를 반환하는 문제
- 두 노드의 값이 같고, 왼쪽 서브트리와 오른쪽 서브트리가 서로 일치하거나,
- 두 노드의 값이 같고, 왼쪽 서브트리가 다른 트리의 오른쪽 서브트리와 일치하며, 오른쪽 서브트리가 다른 트리의 왼쪽 서브트리와 일치해야 합니다.
- 계속 재귀로 두 트리 노드를 비교하면서 두 노드가 모두 null인 경우, 이는 두 노드가 동일하다는 뜻이므로 true를 반환합니다.
- 두 노드 중 하나만 null이거나, 두 노드의 값이 다르면 false를 반환합니다.
- 그리고 노드의 값이 같을 때, 두 트리의 서브트리 구조를 두 가지 방식으로 검사합니다:
  + 서브트리가 그대로 대응되는 경우: checker(node1.left, node2.left)와 checker(node1.right, node2.right)를 각각 호출하여 확인합니다.
  + 서브트리가 뒤집혀 대응되는 경우: checker(node1.left, node2.right)와 checker(node1.right, node2.left)를 각각 호출하여 확인합니다.
- 두 경우 중 하나라도 참이면 해당 노드에서의 트리가 뒤집기 동등하다는 뜻이므로, 두 경우의 논리적 OR (||) 결과를 반환합니다.
- 시간 복잡도: O(n) (n <= 100)

### 2501. Longest Square Streak in an Array ```MEDIUM```
- 주어진 int 배열 nums에서 가장 긴 제곱 수열의 길이를 구하는 문제
- 변수 초기화:
  + result: 가장 긴 제곱 수열의 길이를 저장합니다. 초기값은 -1입니다.
  + max: 주어진 숫자의 최대값으로, 100,000으로 설정됩니다.
  + isExisted[]: 주어진 숫자 배열에 존재하는 숫자를 표시하는 배열로, 특정 숫자가 nums에 포함되어 있는지 확인하는 데 사용됩니다.
  + isVisited[]: 특정 숫자가 이미 수열의 일부로 처리되었는지 추적하여 중복 계산을 방지합니다.
- 숫자 존재 확인:
  + isExisted 배열에 nums 배열의 숫자를 모두 기록하여 존재 여부를 추적합니다.
- 제곱 수열 탐색:
  + for 루프를 통해 2부터 최대값의 제곱근(max)까지 숫자를 순회합니다.
  + 현재 숫자가 nums에 포함되어 있고, 아직 방문하지 않았다면 제곱 수열을 시작합니다.
  + 내부 while 루프에서 현재 숫자의 제곱(j)이 nums에 존재하면 수열의 길이를 늘리고 isVisited에 방문 여부를 기록합니다.
  + 수열의 길이가 1보다 크면 result를 갱신하여 가장 긴 수열 길이를 저장합니다.
- 시간 복잡도: O(n + sqrt(max) * log(log(max)) (n <= 10^5, max <= 10^5)

### 2684. Maximum Number of Moves in a Grid ```MEDIUM```
- grid 배열이 주어졌을 때 조건에 맞춰 가장 많이 움직일 수 있는 수를 구하는 문제
  + 현재 위치에서 (row - 1, col + 1), (row, col + 1), (row + 1, col + 1) 로 이동할 때 이동하고자 하는 위치의 값이 더 큰 경우 이동 가능
- 이 문제는 dp 방식으로 해결이 가능합니다.
- 변수 초기화:
  + m과 n은 격자의 행과 열의 수를 저장합니다.
  + res는 도달할 수 있는 가장 오른쪽 열의 인덱스를 저장하는 변수입니다.
  + dp 배열은 각 행에서 해당 열까지 도달 가능한 최대 이동 수를 저장합니다.
- 열 반복:
  + 열을 왼쪽에서 오른쪽으로 순차적으로 탐색합니다. j는 현재 탐색 중인 열을 나타냅니다.
  + leftTop은 왼쪽 대각선 위의 셀에서 온 이동 횟수를 저장합니다.
  + found는 현재 열에 도달 가능한 셀이 하나라도 있는지를 확인하는 플래그입니다.
- 행 반복:
  + 현재 열(j)의 모든 행(i)을 순회합니다.
  + 이동 가능 여부 검사:
    - cur은 현재 셀로 오는 최대 이동 수를 저장합니다.
    - 왼쪽 대각선 위, 바로 왼쪽, 왼쪽 대각선 아래의 셀에서 현재 셀로 이동 가능한지 확인하며, 각 셀이 조건을 만족하면 cur을 갱신합니다.
  + dp[i]를 cur로 업데이트하여 현재 셀로 오는 최대 이동 횟수를 기록합니다.
- 결과 갱신 및 반복 종료:
  + found가 false면, 현재 열에 도달할 수 있는 셀이 없다는 뜻이므로 for 반복문을 종료합니다.
  + res는 이동이 가능한 열의 가장 오른쪽 열 번호로 갱신됩니다.
- 결과 반환:
  + 마지막으로, 도달할 수 있는 가장 오른쪽 열의 인덱스를 반환합니다.
- 시간 복잡도: O(n * m) (n,m <= 1000, n * m <= 10^5)

### 884. Uncommon Words From Two Sentences ```EASY```
- 두 문자열이 주어졌을 때 중복되지 않게 등장하고 다른 문자열에서 한번도 나오지 않은 문자를 배열로 반환하는 문제
- 먼저 두개의 리스트를 만들고 첫번째 문자열부터 문자를 확인하여 이미 나온 문자라면 리스트(res)에서 제거하고 이미 나온 문자 리스트(seen)에 저장합니다. 나온적도 없고 본적(2번이상 나온적)도 없다면 res에 저장합니다.
- 두번째 문자열도 위와 동일한 방식으로 비교하여 res와 seen 배열에 담습니다.
- 최종적으로 res 에 들어있는 문자열을 배열로 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### ```EASY```


