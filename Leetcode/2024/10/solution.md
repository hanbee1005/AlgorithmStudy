# 문제 풀이

### 1497. Check If Array Paris Are Divisible by k ```MEDIUM```
- 크기가 n인 숫자 배열과 k 가 주어졌을 때 k로 나누어 떨어지는 n/2개의 묶음을 구할 수 있는지를 확인하는 문제
- 먼저 k 크기의 배열을 만들어 숫자를 k로 나눈 나머지의 개수를 저장할 배열을 생성합니다.
- 주어진 배열을 순회하면서 숫자를 k로 나누고 그 숫자가 음수일 수 있으니 k를 더한 뒤 다시 k로 나눈 나머지를 구해 나머지 위치의 숫자를 증가시킵니다.
- 이후 만약 짝을 이뤄야 하는데 나머지가 0인 (즉, k로 나누어 떨어지는 수의 개수)가 홀수이면 바로 false를 반환합니다.
- 그렇지 않은 경우 나머지가 i인 원소의 개수는 나머지가 k - i인 원소의 개수와 같아야 합니다. 두 원소를 더하면 k로 나누어떨어지기 때문입니다.
- 그렇지 않으면 바로 false를 반환하고 모든 경우를 확인하고 난 뒤 최종적으로 true를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 10^5)

### 1331. Rank Transform of an Array ```EASY```
- 배열이 주어젔을 때 작은 숫자 순으로 순위를 메겨 반환하는 문제
- 먼저 주어진 배열에서 최솟값과 최댓값을 구한 다음
- 최대, 최소 차이가 200이 넘으면서 배열의 길이는 10 미만인 경우 배열을 정렬한 뒤 중복을 확인하면서 순위를 메깁니다.
- tmp 배열로 원본 배열을 복사한 뒤 원본 배열을 정렬하고 하나씩 반복하면서 값을 가지고 이전에 나온 값인지 확인한 뒤 순위를 저장하는 방식으로 정답을 구해 반환합니다.
- 그렇지 않은 경우는 다른 방식으로 순위를 구합니다.
- 배열 값이 min에서 max 사이의 값들을 기준으로 새로운 nums 배열을 생성합니다. 이 배열은 각 값이 몇 번째 순위인지를 나타냅니다.
- 그 후 nums 배열을 사용해 각 값에 대한 순위를 결정하여 answer 배열에 기록합니다.
- 시간 복잡도: O(n^2) (n <= 10^5)

### 1813. Sentence Similarity III ```MEDIUM```
- 문자열 2개가 주어졌을 때 중간에 문자열을 추가해서 비슷해질 수 있는지를 구하는 문제
- 문자열 2개를 먼저 빈 문자를 기준으로 자른 뒤 더 긴 문자를 words1로 지정합니다. 길이가 더 작은 문자는 words2로 저장합니다.
- 앞에서부터 한 단어씩 비교하면서 앞쪽에서 같은 개수를 세서 start 변수에 저장합니다.
- 위와 동일하게 뒤에서부터 한 단어씩 비교하면서 뒤쪽에서 같은 개수를 세서 end 변수에 저장합니다.
- 이후 앞에서 같은 단어와 뒤에서 같은 단어의 수를 더해 그 개수가 처음 주어진 문자열 중 길이가 더 짧은 문자열의 문자 수보다 더 크거나 같은 경우 true를 아닌 경우 false를 반환하도록 하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### 2696. Minimum String Length After Removing Substrings ```EASY```
- 문자열이 주어졌을 때 'AB' 또는 'CD'를 제거한 가장 짧은 문자열의 길이를 구하는 문제
- 이 문제는 구현된 Stack을 사용해도 되지만 stack 과 유사한 배열을 만들어 문제를 해결할 수 있습니다.
- 먼저 문자열의 길이 + 1 크기 만큼의 배열을 생성한 뒤, 남은 문자열의 길이를 -1로 지정합니다.
- 문자를 하나씩 돌면서 남은 문자열의 길이가 -1 보다 크면서 마지막 문자가 A 이고 현재 문제가 B 이거나 마지막 문자가 C 이고 현재 문자가 D인 경우는 제거를 해야하므로 마지막 문자의 길이를 -1 합니다.
- 그렇지 않은 경우는 마지막 문자의 길이를 +1 한 다음 해당하는 위치에 현재 문자를 추가합니다.
- 이렇게 모든 문자를 확인한 뒤 마지막 문자의 길이 + 1 한 값을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### 1963. Minimum Number of Swaps to Make the String Balanced ```MEDIUM```
- 정확히 n/2 개의 여는 괄호와 닫는 괄호로 이루어진 길이가 n인 문자열이 주어졌을 때 균형잡힌 문자열을 만들기 위해 스왑하는 최소 횟수를 구하는 문제
- n/2 개의 여는 괄호와 닫는 괄호로 이루어져 있기 때문에 2개의 닫는 괄호와 하나의 여는 괄호를 스왑해야 균형을 맞출 수 있습니다. 즉, 불균형한 닫는 괄호 두개마다 한번의 스왑이 필요합니다.
- 먼저 여는 괄호의 수를 세는 opening 변수와 균형이 맞지 않는 닫는 괄호의 수를 세는 unbalanced 변수를 선언합니다.
- 주어진 문자열의 문자를 하나씩 확인하면서 여는 괄호의 경우 opening 변수의 값을 증가시키고 닫는 괄호의 경우 여는 괄호가 있다면 opening 변수의 수를 감소시켜 짝을 맞추고 그렇지 않은 경우 unbalanced 값을 증가 시킵니다.
- 최종적으로 unbalanced / 2로 스왑을 통해 해결할 수 있는 쌍을 계산합니다. 만약 불균형한 닫는 괄호가 홀수라면, 하나의 스왑으로 해결할 수 없으므로 unbalanced % 2를 더해 추가적인 스왑을 처리하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 10^6)

### ```EASY```



