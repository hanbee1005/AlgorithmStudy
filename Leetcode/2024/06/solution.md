# 문제 풀이

### 1122. Relative Sort Array ```EASY```
- 최대 나올 수 있는 수가 1000이므로 1001 크기의 배열을 만든 뒤
- 첫번째 배열을 돌면서 해당 수를 인덱스로 한 위치의 값을 증가시켜 해당 수가 몇개 나오는지 구합니다.
- 그런 다음 두번째 배열을 돌면서 수를 뽑아 그 수의 개수가 0보다 크다면 그 개수만큼 반복하면서 정답 배열을 채워줍니다.
- 이후 다시 수의 개수가 담긴 배열을 반복하면서 두번째 배열에는 없었지만 첫번째 배열에 존재했던 수들을 찾아 그 개수만큼 정답 배열을 채워주고 최종적으로 정답 배열을 반환합니다.
- 배열을 여러번 돌기는 하지만 최대가 1001이기 때문에 시간이 오래 걸리는 작업은 아닙니다.
- 시간 복잡도: O(N) (N <= 1001)

### 1207. Unique Number Of Occurrences ```EASY```
- 배열을 확인하면서 해당 숫자가 나온 횟수가 유일한 경우 true, 그렇지 않다면 false를 반환하는 문제
- 숫자가 음수인 경우도 존재하기 떄문에 먼저 나올 수 있는 수의 범위의 2배만큼 배열을 생성한 뒤 양수인 경우 해당 숫자의 위치를, 음수인 경우 -1을 곱하고 1000을 더한 위치의 값을 증가시켜서 나온 횟수를 구합니다.
- 그런 다음 해당 인덱스에 담긴 숫자에 해당하는 값이 나온 적이 있는지 확인하기 위해 boolean 타입의 배열을 생성하고 숫자를 확인하면서 0이 아니면서 이미 나온적이 있다면 false 를 그대로 반환하고 아닌 경우 해당 횟수의 인덱스를 true 바꾼 뒤 전체 인덱스를 확인합니다.
- 이 방법 대신 arr 배열의 크기만큼 다시 인덱스를 구해서 확인하면 더 시간을 줄일 수 있습니다.
- 시간 복잡도: O(N) (N <= 2001)

### 2037. Minimum Number Of Moves To Seat Everyone ```EASY```
- 
- 시간 복잡도: O() ()