# 문제 풀이

### 1122. Relative Sort Array ```EASY```
- 최대 나올 수 있는 수가 1000이므로 1001 크기의 배열을 만든 뒤
- 첫번째 배열을 돌면서 해당 수를 인덱스로 한 위치의 값을 증가시켜 해당 수가 몇개 나오는지 구합니다.
- 그런 다음 두번째 배열을 돌면서 수를 뽑아 그 수의 개수가 0보다 크다면 그 개수만큼 반복하면서 정답 배열을 채워줍니다.
- 이후 다시 수의 개수가 담긴 배열을 반복하면서 두번째 배열에는 없었지만 첫번째 배열에 존재했던 수들을 찾아 그 개수만큼 정답 배열을 채워주고 최종적으로 정답 배열을 반환합니다.
- 배열을 여러번 돌기는 하지만 최대가 1001이기 때문에 시간이 오래 걸리는 작업은 아닙니다.
- 시간 복잡도: O(N) (N <= 1001)

### 1207. Unique Number Of Occurrences ```EASY```
- 배열을 확인하면서 해당 숫자가 나온 횟수가 유일한 경우 true, 그렇지 않다면 false를 반환하는 문제
- 숫자가 음수인 경우도 존재하기 떄문에 먼저 나올 수 있는 수의 범위의 2배만큼 배열을 생성한 뒤 양수인 경우 해당 숫자의 위치를, 음수인 경우 -1을 곱하고 1000을 더한 위치의 값을 증가시켜서 나온 횟수를 구합니다.
- 그런 다음 해당 인덱스에 담긴 숫자에 해당하는 값이 나온 적이 있는지 확인하기 위해 boolean 타입의 배열을 생성하고 숫자를 확인하면서 0이 아니면서 이미 나온적이 있다면 false 를 그대로 반환하고 아닌 경우 해당 횟수의 인덱스를 true 바꾼 뒤 전체 인덱스를 확인합니다.
- 이 방법 대신 arr 배열의 크기만큼 다시 인덱스를 구해서 확인하면 더 시간을 줄일 수 있습니다.
- 시간 복잡도: O(N) (N <= 2001)

### 2037. Minimum Number Of Moves To Seat Everyone ```EASY```
- 두 배열이 주어졌을 때 첫번째 배열에 맞게 두번째 배열의 모든 값을 이동시키는 최소 이동 거리를 구하는 문제
- 두 배열에서 겹치는 숫자는 이동할 필요가 없기 때문에 겹치는 숫자를 확인하여 해당 위치의 값을 0으로 변환한 뒤
- 두 배열을 정렬하고 처음부터 확인하면서 두 배열을 같은 위치의 값의 차를 구해 모두 합하여 반환하면 문제를 해결할 수 있습니다.
- 다른 방식으로 속도를 더 개선할 수 있는데
  + 먼저 두 배열을 확인하여 위치의 최대값을 찾아 해당 크기만큼의 different 배열을 생성합니다.
  + 그리고 seats 배열을 돌면서 각 seat에 해당하는 위치의 값을 증가시키고
  + students 배열을 돌면서 각 student에 해당하는 위치의 값을 감소시킵니다.
  + different 배열을 돌면서 맞지 않는 수의 절댓값을 정답에 이동 횟수에 추가하고 맞지 않는 수는 different 값을 추가합니다.
  + 이렇게 함으로써 최소 이동거리를 구할 수 있고 이를 반환하여 문제를 효율적으로 해결할 수 있습니다.
- 시간 복잡도: O(N^2) (N <= 100)

### 645. Set Mismatch ```EASY```
- 배열이 주어졌을 때 배열의 크기만큼 1부터 n개의 수가 하나씩 들어있는데 그중 중복된 하나의 수와 나오지 않은 하나의 수를 찾아 리턴하는 문제
- 주어진 배열에서 숫자를 꺼내 해당 숫자 인덱스의 값을 증가시켜 몇번 나왔는지 확인합니다.
- 이후 해당 배열을 돌면서 2번 나온 경우 answer[0]에, 0번 나온 경우 answer[1]에 추가한 뒤 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 10^4)

### 169. Majority Element ```EASY```
- n 크기의 배열이 주어졌을 때, n/2번 이상 나온 수를 구하는 문제
- 이 문제는 해당 숫자들을 오름차순으로 정렬한 뒤 [n/2] 인덱스의 수를 구하면 해결되는 문제입니다.
- 시간 복잡도: O(1) (Arrays.sort 시간 제외)

### ```EASY```








