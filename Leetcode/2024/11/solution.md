# 문제 풀이

### 1957. Delete Chatacters to Make Fancy String ```EASY```
- 문자열이 주어졌을 때 연속으로 3개 겹치는 문자가 없도록 문자를 제거한 문자열을 반환하는 문제
- 문자열을 한 문자씩 확인하면서 현재 문자가 이전 마지막에 나온 문자와 다르다면 해당 문자를 결과 문자에 추가하고 마지막 문자를 현재 문자로 지정한 뒤, 해당 문자가 나온 개수를 1로 지정합니다.
- 현재 문자와 이전 문자가 같다면 이전에 나온 문자가 2개보다 작을 때만 결과 문자에 추가하고 개수를 증가시킵니다.
- 최종적으로 만들어진 문자열을 반환합니다.
- 시간 복잡도: O(n)(n <= 10^5)

### 3163. String Compression III ```MEDIUM```
- 문자열이 주어졌을 때 같은 문자의 수와 해당 문자를 구해 문자열로 반환하는 문제 (개수가 9가 넘으면 나눠서)
- 처음 문자열을 돌면서 앞에서부터 같은 문자의 수를 센 다음
- 개수가 9보다 크다면 (9 + 해당 문자)를 이어붙이고 9보다 작을 때까지 반복한 다음
- 남은 개수와 해당 문자를 이어 붙인 뒤 다시 개수를 0으로 하고 다음 문자부터 확인하여
- 최종적으로 만들어진 문자를 반환하면 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 2 * 10^5)

### 2914. Minimum Number of Changes to Make Binary String Beautiful ```MEDIUM```
- 0,1 로 이루어진 문자열이 주어졌을 때 같은 문자로 이루어진 같은 짝수 길이의 서브 문자열로 나눠 아름다운 문자열을 만들기 위해 변경해야 하는 최소 문자 수를 구하는 문제
- 문자열의 문자를 2씩 증가시키며 차례로 확인하여 현재 문자와 다음 문자가 다르면 변경을 해줘야 하므로 개수를 증가 시키는 방식으로 개수를 확인해 반환하면 문제를 해결할 수 있습니다.
- 2씩 증가시키는 이유는 짝수 길이를 구해야 하기 때문에 최소 짝수 길이에 해당하는 두 문자가 같은지 다른지를 확인하기 위함입니다.
- 시간 복잡도: O(n/2) (n <= 10^5)

### 3011. Find if Array Can Be Sorted ```MEDIUM```
- 정수 배열이 주어졌을 때, 이진수로 변환했을 때 1의 개수가 같은 숫자들끼리만 인접한 위치에서 교환하여 배열을 정렬할 수 있는지 여부를 판단하는 문제
- 먼저 원본 배열 nums를 values 배열로 복사하여 작업합니다. 원본 배열을 변경하지 않기 위함입니다.
- 첫번째는 배열을 한 번 순회하면서 가능한 한 큰 숫자들을 오른쪽으로 이동시켜 정렬합니다.
  + 인덱스 i를 0부터 n - 2까지 순회합니다.
  + 만약 values[i] <= values[i + 1]이면 이미 정렬되어 있으므로 다음으로 넘어갑니다.
  + 그렇지 않으면 (values[i] > values[i + 1]) 두 요소를 교환해야 합니다.
  + 교환이 가능한지 확인하기 위해 두 숫자의 비트 카운트를 비교합니다.
  + Integer.bitCount(values[i])와 Integer.bitCount(values[i + 1])이 같지 않으면 교환 불가하므로 false를 반환합니다.
  + 같으면 두 요소를 교환합니다.
- 두번째는 배열을 역순으로 순회하면서 가능한 한 작은 숫자들을 왼쪽으로 이동시켜 정렬합니다.
  + 인덱스 i를 n - 1부터 1까지 감소시키며 순회합니다.
  + 만약 values[i] >= values[i - 1]이면 이미 정렬되어 있으므로 다음으로 넘어갑니다.
  + 그렇지 않으면 (values[i] < values[i - 1]) 두 요소를 교환해야 합니다.
  + 교환이 가능한지 확인하기 위해 두 숫자의 비트 카운트를 비교합니다.
  + Integer.bitCount(values[i])와 Integer.bitCount(values[i - 1])이 같지 않으면 교환 불가하므로 false를 반환합니다.
  + 같으면 두 요소를 교환합니다.
- 두 번의 패스를 모두 통과하여 false를 반환하지 않았다면, 배열을 주어진 제약 조건 하에서 정렬할 수 있으므로 true를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### 2275. Largest Combination with Bitwise AND Greater Than Zero ```MEDIUM```
- 정수 배열에서 같은 비트 위치에 '1'이 있는 숫자들의 최대 개수를 찾는 문제 (= 여러 숫자들 중에서 비트 AND 연산을 했을 때 0이 아닌 결과를 만드는 가장 큰 조합의 크기를 찾는 문제)
- 주어진 정수를 순회하면서 find 함수에서 숫자 n의 각 비트 위치에서 '1'의 개수를 ans 배열에 누적합니다.
  + 비트 검사: n의 가장 오른쪽 비트가 '1'인지 확인합니다.
  + 카운트 누적: 현재 비트 위치 j에 해당하는 ans[j]에 '1'이면 1을 더합니다.
  + 비트 이동: n을 오른쪽으로 1비트 시프트하여 다음 비트를 검사합니다.
  + 인덱스 감소: j를 1 감소하여 다음 비트 위치로 이동합니다.
  + 반복 종료: n이 0이 되면 반복을 종료합니다.
- 그런 다음 각 자리의 1인 수 중 가장 큰 값을 구해 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 10^5)

### 1829. Maximum XOR for Each Query ```MEDIUM```
- 정수 배열 nums와 정수 maximumBit가 주어졌을 때, 각 쿼리마다 k_i를 찾아 xorr ^ k_i의 값을 최대화하고, 마지막 원소를 제거하는 과정을 반복하여 결과 배열을 반환하는 문제
- 변수 초기화:
  + n은 배열 nums의 길이입니다.
  + xorr은 nums 배열의 모든 원소들의 XOR 값을 저장할 변수입니다.
    - 초기값은 nums[0]으로 설정합니다.
  + maxXor은 (1 << maximumBit) - 1로 계산되며, 이는 maximumBit 길이의 모든 비트가 1인 수를 의미합니다.
    - 예를 들어, maximumBit = 3이면, (1 << 3) - 1 = 7 (0b111)입니다.
- 모든 원소들의 XOR 계산:
  + xorr에 nums의 모든 원소를 XOR 연산하여 누적합니다.
  + 이로써 전체 배열의 XOR 값을 구합니다.
- 결과 배열 ans 생성 및 계산:
  + ans는 결과를 저장할 배열로, 크기는 n입니다.
  + 첫 번째 반복에서 (i = 0):
    - ans[0] = xorr ^ maxXor;
      + 전체 배열의 XOR 값 xorr과 maxXor을 XOR 연산합니다.
      + 이는 k_i 값을 의미합니다.
    - 그 후에 xorr에서 nums의 마지막 원소부터 역순으로 XOR을 제거합니다.
      + xorr ^= nums[n - 1 - i];
      + 이는 다음 쿼리에서 배열의 마지막 원소를 제거한 상태의 XOR 값을 구하기 위함입니다.
  + 이를 반복하여 각 쿼리마다 k_i 값을 계산하고, xorr 값을 업데이트합니다.
- 최종 결과 반환:
  + 계산된 ans 배열을 반환합니다.
- 시간 복잡도: O(n) (n <= 10^5)

### 2601. Prime Subtraction Operation ```MEDIUM```
- 배열이 주어졌을 때 각 인덱스의 수보다 작은 소수를 빼서 오름차순 배열로 정리가 되는지 구하는 문제
- 먼저 주어진 배열에서 나올 수 있는 최댓값이 1000이기 때문에 그보다 작은 모든 소수를 구해둡니다.
- 그리고 주어진 배열을 순회하면서 이전 값보다 현재 값이 작다면 오름차순이 될 수 없으므로 바로 false를 반환합니다.
- 그렇지 않은 경우 이분 탐색으로 num - prev 보다 작은 가장 큰 소수의 인덱스를 구합니다.
  + num - prev 로 하는 이유는 현재숫자(num)에서 소수를 빼서 그 값이 이전 값(prev)보다 커야하기 때문입니다.
  + num - p > prev -> num - prev > p
- 이렇게 구한 index가 -1이 아니라면 현재 숫자에서 해당 인덱스의 소수를 뺀 다음 이전 값에 계산된 값을 넣어줍니다.
- 이렇게 중간에 반환되지 않고 모든 수를 확인하면 오름차순으로 정렬되었다고 보고 true를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 1000)

### 2070. Most Beatiful Item for Each Query ```MEDIUM```
- price와 beauty로 이루어진 item 배열을 받아서 queries 배열의 값보다 price가 작은 item 중에 가장 큰 beauty를 찾아 반환하는 문제
- 변수 초기화
  + maxI: Integer.MAX_VALUE로 초기화하여 최대값을 나타냅니다.
  + res: 가격 구간과 해당 구간의 최대 아름다움을 저장하는 리스트입니다.
  + res.add(new int[] {0, 0, maxI}): 가격 0부터 최대값까지 아름다움이 0인 초기 구간을 추가합니다.
- 아이템 정렬
  + 아이템을 가격 기준(a[0])으로 오름차순 정렬합니다. 이를 통해 가격이 낮은 순서대로 아이템을 처리할 수 있습니다.
- 가격 구간과 최대 아름다움 생성
  + 각 아이템을 순회하며 다음을 수행합니다:
    - price: 현재 아이템의 가격.
    - beauty: 현재 아이템의 아름다움.
    - lastBracket: res 리스트의 마지막 구간.
  + 조건 검사:
    - 현재 아름다움이 마지막 구간의 아름다움보다 큰 경우:
      + lastBracket[2] = price;: 이전 구간의 상한 가격을 현재 가격으로 설정하여 구간을 닫습니다.
      + res.add(new int[] {price, beauty, maxI});: 새로운 구간을 추가합니다.
  + 결과:
    - 아름다움이 증가하는 지점마다 새로운 구간을 생성하여 가격 구간별 최대 아름다움을 저장합니다.
- 쿼리 처리
  + 각 쿼리에 대해 최대 아름다움 찾기:
    - x: 현재 쿼리의 가격 제한.
    - 역순으로 res 리스트를 탐색하여, 가격이 x 이하인 첫 번째 구간을 찾습니다.
      + 조건: res.get(i)[0] <= x
      + 동작:
        - 해당 구간의 아름다움 res.get(i)[1]을 결과 배열 ans에 저장합니다.
        - **break;**로 반복문을 종료합니다.
- 각 쿼리에 대한 최대 아름다움 배열을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N log N + M * N) (N <= 10^5, M <= 10^5)

### 2563. Count the Number of Fair Pairs ```MEDIUM```
- 정수 배열과 lower, upper가 주어졌을 때 배열의 두 합이 lower 이상 upper 이하인 쌍의 수를 구하는 문제
- 먼저 정수 배열을 오름차순으로 정렬한 뒤, 합이 upper 이하인 쌍의 개수에서 합이 lower - 1 이하인 쌍의 개수를 빼면 lower 이상 upper 이하인 쌍의 수를 구할 수 있습니다.
- upper 이하인 쌍의 개수와 lower - 1 이하인 쌍의 개수를 구하는 방법은 다음과 같습니다.
- 투 포인터 알고리즘을 사용하여 시작 인덱스를 하나씩 증가시키고 그 안에서 끝 인덱스를 감소시키며 적정 값을 찾습니다.
  + 시작 인덱스의 값과 끝 인덱스의 값을 더해 구하려는 합보다 큰 경우는 끝 인덱스를 감소시킵니다. (반복)
  + 위 반복이 끝나면 현재 시작 인덱스(i)에 대해 가능한 끝 인덱스(j)의 범위 (i부터 j까지) 만큼을 결과에 더합니다.
- 이후 이 값을 반환하면 주어진 배열에서 어떤 숫자 이하의 쌍의 개수를 구할 수 있습니다.
- 시간 복잡도: O(N log N) (N <= 10^5)

### 2490. Circular Sentence ```EASY```
- 문장이 주어졌을 때 " " 기준으로 나눠진 단어의 앞,뒤 단어와 비교하여 앞 문자열의 끝 문자와 현재 문자열의 시작 문자, 현 문자열의 끝 문자와 뒤 문자열의 시작 문자가 같은지를 비교하는 문제
- 먼저 전체 문장의 시작 문자와 끝 문자가 다르면 바로 false 반환
- 전체 문장에서 첫 " "의 인덱스를 찾아서 없다면 하나의 문자열이고 앞에서 문자열의 시작과 끝이 같은지 확인했으니 바로 true 반환
- 그리고 " "이 없을 때까지 " "의 앞 인덱스와 뒤 인덱스의 문자열이 다른지 비교해서 다르면 바로 false 반환
- 그렇지 않으면 다음 " "의 인덱스를 찾아서 반복하고 모두 검사한 경우 true를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 250)

### 1652. Defuse the Bomb ```EASY```
- 정수 배열과 k가 주어졌을 때 현재 위치에서 k가 양수이면 오른쪽으로 k개, 음수이면 왼쪽으로 k개 더한 배열을 반환하는 문제
- 기본 설정
  + n: code 배열의 길이입니다.
  + answer: 결과를 저장할 배열로, 초기값은 0으로 채워져 있습니다.
  + start, end: 합산할 구간의 시작과 끝 인덱스를 나타냅니다.
  + k == 0인 경우: 모든 원소를 0으로 대체하므로, 초기화된 answer 배열을 그대로 반환합니다.
- k의 부호에 따른 start와 end 설정
  + k > 0인 경우:
    - 합산할 구간은 현재 위치의 다음 원소부터 시작합니다.
    - start = 1, end = k
  + k < 0인 경우:
    - 합산할 구간은 현재 위치의 이전 원소부터 시작합니다.
    - start = n - |k|, end = n - 1
- 초기 합 계산
  + 처음 합산 구간의 합을 계산하여 sum에 저장합니다.
  + 원형 배열이므로, 인덱스가 배열의 범위를 벗어나지 않습니다.
- 각 위치별로 합산하여 answer 배열 채우기
  + 반복문: 배열의 모든 원소에 대해 실행합니다.
  + answer[i] = sum: 현재 합산된 값을 결과 배열에 저장합니다.
  + 합 업데이트:
    - 합에서 이전 구간의 첫 번째 원소를 빼고, 새로운 구간의 마지막 원소를 더합니다.
    - sum -= code[start % n];
    - sum += code[(end + 1) % n];
  + 인덱스 갱신:
    - start와 end를 증가시켜 다음 구간으로 이동합니다.
    - % n 연산을 사용하여 배열의 범위를 벗어나지 않도록 합니다.
- 시간 복잡도: O(n) (n <= 100)

### 2461. Maximum Sum of Distinct Subarrays With Length K```MEDIUM```
- 정수 배열이 주어졌을 때 k개씩 묶은 서브 배열에서 중복된 값이 없이 가장 큰 합을 구하는 문제
- 먼저 주어진 정수 중 가장 큰 값을 찾고 그 값까지 담을 수 있는 배열을 생성합니다. 이 배열에는 해당 수가 몇번 나오는지 세기 위한 용도입니다.
- 그리고 0부터 k-1 인덱스까지 확인하면서 해당 숫자가 이미 나온 경우 ```counts[nums[i]] >= 1``` 중복된 숫자 카운트(dupCount)를 증가시키고 해당 숫자의 개수를 증가시키고 현재 합에 추가합니다.
- k-1 인덱스까지 확인한 뒤 중복된 숫자 카운트가 0이라면 현재 합을 최종 합으로 우선 지정합니다.
- 이제 k부터 마지막 인덱스까지 돌면서 해당 숫자가 이미 나온 경우 ```counts[nums[i]] >= 1``` 중복된 숫자 카운트(dupCount)를 증가시키고 해당 숫자의 개수를 증가시키고 현재 합에 추가합니다.
- 그리고 처음에 있던 수가 중복인 경우 ```counts[nums[i-k]] > 1``` 중복된 숫자 카운트(dupCount)를 감소시키고 해당 숫자의 개수도 빼고 현재 합에서도 뺍니다.
- 마지막으로 중복된 숫자의 개수가 0인 경우 최종 합과 현재 합 중 더 큰 수를 최종 합으로 지정합니다.
- 이렇게 마지막 인덱스까지 확인한 뒤 최종 합을 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 10^5)

### 796. Rotate String ```EASY```
- 문자열이 주어졌을 때 shift 해서 목표 문자열을 만들 수 있는지 구하는 문제
- 주어진 대상 문자열과 목표 문자열의 길이가 다르면 바로 false
- 아닌 경우 대상 문자열 2개를 이어 붙이고 그 문자열에 목표 문자열이 추가되어 있는지 여부를 확인하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(N * M) (N, M <= 100)

### 1684. Count the Number of Consistent Strings ```EASY```
- 허용된 문자열과 문자열 배열이 주어졌을 때, 배열에서 허용된 문자열에 있는 문자로만 이루어진 문자열의 개수를 구하는 문제
- 허용된 문자열에 있는 알파벳을 찾아 해당 알파벳 인덱스를 true로 변경합니다.
- 문자열 배열의 각 문자열을 하나씩 확인하면서 문자열의 문자가 true로 이미 나왔던 문자인지 확인합니다.
- 이전에 나오지 않았다면 바로 다른 문자열을 확인합니다.
- 모두 이전에 나온 문자였다면 answer의 값을 증가시키고 배열의 모든 문자열을 확인한 뒤 최종적으로 answer을 반환합니다.
- 시간 복잡도: O(N * M) (N <= 10^4, M <= 10)

### ```EASY```

