# 문제 풀이

### 1957. Delete Chatacters to Make Fancy String ```EASY```
- 문자열이 주어졌을 때 연속으로 3개 겹치는 문자가 없도록 문자를 제거한 문자열을 반환하는 문제
- 문자열을 한 문자씩 확인하면서 현재 문자가 이전 마지막에 나온 문자와 다르다면 해당 문자를 결과 문자에 추가하고 마지막 문자를 현재 문자로 지정한 뒤, 해당 문자가 나온 개수를 1로 지정합니다.
- 현재 문자와 이전 문자가 같다면 이전에 나온 문자가 2개보다 작을 때만 결과 문자에 추가하고 개수를 증가시킵니다.
- 최종적으로 만들어진 문자열을 반환합니다.
- 시간 복잡도: O(n)(n <= 10^5)

### 3163. String Compression III ```MEDIUM```
- 문자열이 주어졌을 때 같은 문자의 수와 해당 문자를 구해 문자열로 반환하는 문제 (개수가 9가 넘으면 나눠서)
- 처음 문자열을 돌면서 앞에서부터 같은 문자의 수를 센 다음
- 개수가 9보다 크다면 (9 + 해당 문자)를 이어붙이고 9보다 작을 때까지 반복한 다음
- 남은 개수와 해당 문자를 이어 붙인 뒤 다시 개수를 0으로 하고 다음 문자부터 확인하여
- 최종적으로 만들어진 문자를 반환하면 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 2 * 10^5)

### 2914. Minimum Number of Changes to Make Binary String Beautiful ```MEDIUM```
- 0,1 로 이루어진 문자열이 주어졌을 때 같은 문자로 이루어진 같은 짝수 길이의 서브 문자열로 나눠 아름다운 문자열을 만들기 위해 변경해야 하는 최소 문자 수를 구하는 문제
- 문자열의 문자를 2씩 증가시키며 차례로 확인하여 현재 문자와 다음 문자가 다르면 변경을 해줘야 하므로 개수를 증가 시키는 방식으로 개수를 확인해 반환하면 문제를 해결할 수 있습니다.
- 2씩 증가시키는 이유는 짝수 길이를 구해야 하기 때문에 최소 짝수 길이에 해당하는 두 문자가 같은지 다른지를 확인하기 위함입니다.
- 시간 복잡도: O(n/2) (n <= 10^5)

### 3011. Find if Array Can Be Sorted ```MEDIUM```
- 정수 배열이 주어졌을 때, 이진수로 변환했을 때 1의 개수가 같은 숫자들끼리만 인접한 위치에서 교환하여 배열을 정렬할 수 있는지 여부를 판단하는 문제
- 먼저 원본 배열 nums를 values 배열로 복사하여 작업합니다. 원본 배열을 변경하지 않기 위함입니다.
- 첫번째는 배열을 한 번 순회하면서 가능한 한 큰 숫자들을 오른쪽으로 이동시켜 정렬합니다.
  + 인덱스 i를 0부터 n - 2까지 순회합니다.
  + 만약 values[i] <= values[i + 1]이면 이미 정렬되어 있으므로 다음으로 넘어갑니다.
  + 그렇지 않으면 (values[i] > values[i + 1]) 두 요소를 교환해야 합니다.
  + 교환이 가능한지 확인하기 위해 두 숫자의 비트 카운트를 비교합니다.
  + Integer.bitCount(values[i])와 Integer.bitCount(values[i + 1])이 같지 않으면 교환 불가하므로 false를 반환합니다.
  + 같으면 두 요소를 교환합니다.
- 두번째는 배열을 역순으로 순회하면서 가능한 한 작은 숫자들을 왼쪽으로 이동시켜 정렬합니다.
  + 인덱스 i를 n - 1부터 1까지 감소시키며 순회합니다.
  + 만약 values[i] >= values[i - 1]이면 이미 정렬되어 있으므로 다음으로 넘어갑니다.
  + 그렇지 않으면 (values[i] < values[i - 1]) 두 요소를 교환해야 합니다.
  + 교환이 가능한지 확인하기 위해 두 숫자의 비트 카운트를 비교합니다.
  + Integer.bitCount(values[i])와 Integer.bitCount(values[i - 1])이 같지 않으면 교환 불가하므로 false를 반환합니다.
  + 같으면 두 요소를 교환합니다.
- 두 번의 패스를 모두 통과하여 false를 반환하지 않았다면, 배열을 주어진 제약 조건 하에서 정렬할 수 있으므로 true를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### 2275. Largest Combination with Bitwise AND Greater Than Zero ```MEDIUM```
- 정수 배열에서 같은 비트 위치에 '1'이 있는 숫자들의 최대 개수를 찾는 문제 (= 여러 숫자들 중에서 비트 AND 연산을 했을 때 0이 아닌 결과를 만드는 가장 큰 조합의 크기를 찾는 문제)
- 주어진 정수를 순회하면서 find 함수에서 숫자 n의 각 비트 위치에서 '1'의 개수를 ans 배열에 누적합니다.
  + 비트 검사: n의 가장 오른쪽 비트가 '1'인지 확인합니다.
  + 카운트 누적: 현재 비트 위치 j에 해당하는 ans[j]에 '1'이면 1을 더합니다.
  + 비트 이동: n을 오른쪽으로 1비트 시프트하여 다음 비트를 검사합니다.
  + 인덱스 감소: j를 1 감소하여 다음 비트 위치로 이동합니다.
  + 반복 종료: n이 0이 되면 반복을 종료합니다.
- 그런 다음 각 자리의 1인 수 중 가장 큰 값을 구해 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 10^5)

### ```EASY```


