# 문제 풀이

### 1957. Delete Chatacters to Make Fancy String ```EASY```
- 문자열이 주어졌을 때 연속으로 3개 겹치는 문자가 없도록 문자를 제거한 문자열을 반환하는 문제
- 문자열을 한 문자씩 확인하면서 현재 문자가 이전 마지막에 나온 문자와 다르다면 해당 문자를 결과 문자에 추가하고 마지막 문자를 현재 문자로 지정한 뒤, 해당 문자가 나온 개수를 1로 지정합니다.
- 현재 문자와 이전 문자가 같다면 이전에 나온 문자가 2개보다 작을 때만 결과 문자에 추가하고 개수를 증가시킵니다.
- 최종적으로 만들어진 문자열을 반환합니다.
- 시간 복잡도: O(n)(n <= 10^5)

### 3163. String Compression III ```MEDIUM```
- 문자열이 주어졌을 때 같은 문자의 수와 해당 문자를 구해 문자열로 반환하는 문제 (개수가 9가 넘으면 나눠서)
- 처음 문자열을 돌면서 앞에서부터 같은 문자의 수를 센 다음
- 개수가 9보다 크다면 (9 + 해당 문자)를 이어붙이고 9보다 작을 때까지 반복한 다음
- 남은 개수와 해당 문자를 이어 붙인 뒤 다시 개수를 0으로 하고 다음 문자부터 확인하여
- 최종적으로 만들어진 문자를 반환하면 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 2 * 10^5)

### 2914. Minimum Number of Changes to Make Binary String Beautiful ```MEDIUM```
- 0,1 로 이루어진 문자열이 주어졌을 때 같은 문자로 이루어진 같은 짝수 길이의 서브 문자열로 나눠 아름다운 문자열을 만들기 위해 변경해야 하는 최소 문자 수를 구하는 문제
- 문자열의 문자를 2씩 증가시키며 차례로 확인하여 현재 문자와 다음 문자가 다르면 변경을 해줘야 하므로 개수를 증가 시키는 방식으로 개수를 확인해 반환하면 문제를 해결할 수 있습니다.
- 2씩 증가시키는 이유는 짝수 길이를 구해야 하기 때문에 최소 짝수 길이에 해당하는 두 문자가 같은지 다른지를 확인하기 위함입니다.
- 시간 복잡도: O(n/2) (n <= 10^5)

### 3011. Find if Array Can Be Sorted ```MEDIUM```
- 정수 배열이 주어졌을 때, 이진수로 변환했을 때 1의 개수가 같은 숫자들끼리만 인접한 위치에서 교환하여 배열을 정렬할 수 있는지 여부를 판단하는 문제
- 먼저 원본 배열 nums를 values 배열로 복사하여 작업합니다. 원본 배열을 변경하지 않기 위함입니다.
- 첫번째는 배열을 한 번 순회하면서 가능한 한 큰 숫자들을 오른쪽으로 이동시켜 정렬합니다.
  + 인덱스 i를 0부터 n - 2까지 순회합니다.
  + 만약 values[i] <= values[i + 1]이면 이미 정렬되어 있으므로 다음으로 넘어갑니다.
  + 그렇지 않으면 (values[i] > values[i + 1]) 두 요소를 교환해야 합니다.
  + 교환이 가능한지 확인하기 위해 두 숫자의 비트 카운트를 비교합니다.
  + Integer.bitCount(values[i])와 Integer.bitCount(values[i + 1])이 같지 않으면 교환 불가하므로 false를 반환합니다.
  + 같으면 두 요소를 교환합니다.
- 두번째는 배열을 역순으로 순회하면서 가능한 한 작은 숫자들을 왼쪽으로 이동시켜 정렬합니다.
  + 인덱스 i를 n - 1부터 1까지 감소시키며 순회합니다.
  + 만약 values[i] >= values[i - 1]이면 이미 정렬되어 있으므로 다음으로 넘어갑니다.
  + 그렇지 않으면 (values[i] < values[i - 1]) 두 요소를 교환해야 합니다.
  + 교환이 가능한지 확인하기 위해 두 숫자의 비트 카운트를 비교합니다.
  + Integer.bitCount(values[i])와 Integer.bitCount(values[i - 1])이 같지 않으면 교환 불가하므로 false를 반환합니다.
  + 같으면 두 요소를 교환합니다.
- 두 번의 패스를 모두 통과하여 false를 반환하지 않았다면, 배열을 주어진 제약 조건 하에서 정렬할 수 있으므로 true를 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 100)

### 2275. Largest Combination with Bitwise AND Greater Than Zero ```MEDIUM```
- 정수 배열에서 같은 비트 위치에 '1'이 있는 숫자들의 최대 개수를 찾는 문제 (= 여러 숫자들 중에서 비트 AND 연산을 했을 때 0이 아닌 결과를 만드는 가장 큰 조합의 크기를 찾는 문제)
- 주어진 정수를 순회하면서 find 함수에서 숫자 n의 각 비트 위치에서 '1'의 개수를 ans 배열에 누적합니다.
  + 비트 검사: n의 가장 오른쪽 비트가 '1'인지 확인합니다.
  + 카운트 누적: 현재 비트 위치 j에 해당하는 ans[j]에 '1'이면 1을 더합니다.
  + 비트 이동: n을 오른쪽으로 1비트 시프트하여 다음 비트를 검사합니다.
  + 인덱스 감소: j를 1 감소하여 다음 비트 위치로 이동합니다.
  + 반복 종료: n이 0이 되면 반복을 종료합니다.
- 그런 다음 각 자리의 1인 수 중 가장 큰 값을 구해 반환하여 문제를 해결할 수 있습니다.
- 시간 복잡도: O(n) (n <= 10^5)

### 1829. Maximum XOR for Each Query ```MEDIUM```
- 정수 배열 nums와 정수 maximumBit가 주어졌을 때, 각 쿼리마다 k_i를 찾아 xorr ^ k_i의 값을 최대화하고, 마지막 원소를 제거하는 과정을 반복하여 결과 배열을 반환하는 문제
- 변수 초기화:
  + n은 배열 nums의 길이입니다.
  + xorr은 nums 배열의 모든 원소들의 XOR 값을 저장할 변수입니다.
    - 초기값은 nums[0]으로 설정합니다.
  + maxXor은 (1 << maximumBit) - 1로 계산되며, 이는 maximumBit 길이의 모든 비트가 1인 수를 의미합니다.
    - 예를 들어, maximumBit = 3이면, (1 << 3) - 1 = 7 (0b111)입니다.
- 모든 원소들의 XOR 계산:
  + xorr에 nums의 모든 원소를 XOR 연산하여 누적합니다.
  + 이로써 전체 배열의 XOR 값을 구합니다.
- 결과 배열 ans 생성 및 계산:
  + ans는 결과를 저장할 배열로, 크기는 n입니다.
  + 첫 번째 반복에서 (i = 0):
    - ans[0] = xorr ^ maxXor;
      + 전체 배열의 XOR 값 xorr과 maxXor을 XOR 연산합니다.
      + 이는 k_i 값을 의미합니다.
    - 그 후에 xorr에서 nums의 마지막 원소부터 역순으로 XOR을 제거합니다.
      + xorr ^= nums[n - 1 - i];
      + 이는 다음 쿼리에서 배열의 마지막 원소를 제거한 상태의 XOR 값을 구하기 위함입니다.
  + 이를 반복하여 각 쿼리마다 k_i 값을 계산하고, xorr 값을 업데이트합니다.
- 최종 결과 반환:
  + 계산된 ans 배열을 반환합니다.
- 시간 복잡도: O(n) (n <= 10^5)

### ```EASY```


